<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>兔酱碎碎念/大三寒假记事（二）之二十岁苦乐记</title>
    <link href="/2021/02/05/%E5%85%94%E9%85%B1%E7%A2%8E%E7%A2%8E%E5%BF%B5/%E5%A4%A7%E4%B8%89%E5%AF%92%E5%81%87%E8%AE%B0%E4%BA%8B%EF%BC%88%E4%BA%8C%EF%BC%89%E4%B9%8B%E4%BA%8C%E5%8D%81%E5%B2%81%E8%8B%A6%E4%B9%90%E8%AE%B0/"/>
    <url>/2021/02/05/%E5%85%94%E9%85%B1%E7%A2%8E%E7%A2%8E%E5%BF%B5/%E5%A4%A7%E4%B8%89%E5%AF%92%E5%81%87%E8%AE%B0%E4%BA%8B%EF%BC%88%E4%BA%8C%EF%BC%89%E4%B9%8B%E4%BA%8C%E5%8D%81%E5%B2%81%E8%8B%A6%E4%B9%90%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p><code>和朋友吐吐槽</code></p><p>很庆幸身边有这么好的闺蜜、高中同桌和老铁在我身边。</p><p>今天突然内心崩溃了，和你们吐吐槽抱怨一下鸡零狗碎的心事（孤独感、毕业去向、家里情况），你们总会很在意地、和我语重心长地说很多。给我这个看似无坚不摧实则脆弱不堪的小朋友极致的温柔。</p><p>我爱你们。爱死你们。</p><p><code>夜晚和家人促膝长谈</code></p><p>有时候爸妈也不会很理解你，也许这种不理解是双向的。</p><p>但是今天晚上也坐在一起说了很多。给他们讲了很多毕业以后走的路，他们也是一脸开心。</p><p>爸爸从来没有像今天一样想把我留在身边。他告诉我外地人不好，找男朋友不要找外地的（哈哈哈…为了留我在身边，这种发言也是很有趣了）；还告诉我尽量在本省上班，还说不然考这里普通本科大学的研究生然后留在本校当老师。</p><p>夜晚才是我们一家人促膝长谈的时刻。昨天晚上，爸爸居然在我们面前哭了。我觉得是他给自己心理压力太大，其实他已经做的很好了。这种感觉，我懂（应该懂吧）。</p><p>总之，今天说完心里话，整个家里又多了一份安适。每次都是。</p><p><code>未来的期盼</code></p><p>未来也逐渐明朗。</p><p>今天突然看见了印象笔记里刚上大一时总结的四年的大学课程。当时的我应该对这些课程很疑惑，而现在已经考过了期末；当初还标记了考研课程当重点课程来学，当时学的时候也的确在意了（相对于其他非专业课或者重点非专业课来说），可事实还是没有很认真hhh。现在看来，当初还真是天真可爱，现在已经是大三的老油条了。</p><p>自从前天早上犯贱地进了黑名单以后，看了很多毕业以后的路。不敢不想考研、不甘于公务员、大公司进不了、小公司只是螺丝钉……</p><p>现在我的想法是考公务员，留在本省。慢慢地有自己的生活，而不是生存。健身、美食、外出、早起…每一个都能让我充满活力。</p><p><code>下学期计划</code></p><ul><li>脱单</li><li>实习</li><li>考公</li><li>六级</li><li>奖学金</li></ul>]]></content>
    
    
    <categories>
      
      <category>鱼酱碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>兔酱碎碎念/大三寒假记事（一）之回忆大学时光</title>
    <link href="/2021/01/17/%E5%85%94%E9%85%B1%E7%A2%8E%E7%A2%8E%E5%BF%B5/%E5%A4%A7%E4%B8%89%E5%AF%92%E5%81%87%E8%AE%B0%E4%BA%8B%EF%BC%88%E4%B8%80%EF%BC%89%E4%B9%8B%E5%9B%9E%E5%BF%86%E5%A4%A7%E5%AD%A6%E6%97%B6%E5%85%89/"/>
    <url>/2021/01/17/%E5%85%94%E9%85%B1%E7%A2%8E%E7%A2%8E%E5%BF%B5/%E5%A4%A7%E4%B8%89%E5%AF%92%E5%81%87%E8%AE%B0%E4%BA%8B%EF%BC%88%E4%B8%80%EF%BC%89%E4%B9%8B%E5%9B%9E%E5%BF%86%E5%A4%A7%E5%AD%A6%E6%97%B6%E5%85%89/</url>
    
    <content type="html"><![CDATA[<p>我这个人真的是太爱复盘了，而且随着长大越来越爱回想从某个时间节点往后都干了些什么。直到今天已经进入寒假半个月多了，期间也做了不少，但是学习却迟迟没有开始。先总结一下最近都干了一些什么吧。</p><p><code>最近的寒假生活</code></p><p>一月一号回家，当然先在家躺尸了两天 ~ 然后就开始了练车的日子。包括上大同考试的三天，整个流程直到十号结束。</p><p>期间有一天特别冷，那天没有去练车，而是约了闺蜜出来一起玩。吃了小南同学放假前就想念的肉蟹煲 ~ 然后下午去轮滑场玩。算是轮滑入门了，下次可以比这次还滑的快一些 ~ </p><p>练车真的不是什么好事情。这次科三是冬天练的，每天去练车都要等公交，一天下来要等四趟555…真的好冷…马丁靴也一点都不暖和。介于想买一双nike，所以今年冬天的雪地靴计划取消辽 ~ 去大同模拟也很冷，除了模拟的时间在模拟车上，其他时间都在大巴上，冻死人…模拟那三天是朝七晚九的生活。每次练车都想着：这辈子都不可能再练车了！QAQ可能唯一比较安慰我的就是晚上可以在宾馆里睡，条件比较好。不论怎么样，科三考过了，也算是不白瞎这一段时间这么辛苦！昨天晚上不想玩手机，想着早睡但是又睡不着，索性点开了自己的博客。发现上一篇博客里的寒假计划之一就是考过科三，真的是顿时感觉寒假进行到现在也不是一点收获都没有的，有一点小开心~(≧▽≦)/ ~ </p><p>考完科三，也就是从十号到现在都在家里躺尸。期间也有和妈妈、闺蜜一起去逛街。其他时间就是很平平无奇的假期躺尸生活：玩游戏、看剧、翻墙。这段时间晚上都会刷碗，偶尔也会给爸妈做个小饭，这一切的一切都起源于不想挨骂招嫌弃。虽然已经招嫌弃了…在他们眼里我就像是一个无业游民。说实话，我都觉得自己也像无业游民，每天混吃混喝、不学无术…所以之后的一天我去找了找寒假工，但是因为疫情，直到现在还在等通知。</p><p><code>在校生活</code></p><p>刚刚结束的大三上像极了我大一上学期：都没有翻书好好学习。大一上的时候顾着玩游戏，大三上顾着谈恋爱。所以这两个学期的成绩仅限于没有挂科。</p><p>其他三个学期都有三等奖学金</p><p>大二一整年有一个三好学生奖状</p><p>所以大三下可以来一个三等奖学金吗！？？？</p><p>除此之外的荣誉还有大学刚入学时的军训标兵、四级证</p><p>所以可以来一个六级证吗！？？？</p><p><code>长假</code></p><p>大一</p><ul><li>寒假——【玩】炫舞时代</li><li>暑假——【赚钱】英语补习班老师</li></ul><p>大二</p><ul><li>寒假——【玩】在家里躺尸</li><li>暑假——【学习】学习前端、考驾照</li></ul><p>大三</p><ul><li>现在在寒假中ing…文章刚开始也记录了一些这个寒假的生活，这里就不赘述了。在以后的博客里应该还会有相对简单的复盘</li></ul><p>在长假里呢，玩、赚钱、学习都有，我自己还是比较满意的。对于上面说的三年在校生活，我也比较满意，毕竟我过了我想要的大学生活 ~ 简简单单的学习、拿到了奖学金、也有一段大学恋爱。接下来怎么样，还需要继续生活，走着瞧瞧啦 ~ owo</p><p>其实，我自己也有些反对把考驾照也列入学习中，因为本来这就是生活的一部分。但是它又确实是假期生活中比较亮眼的地方，单单称之为生活又欠妥的(´･ω･`)姑且就先把驾照列入学习叭 ~ </p><p>接下来还请继续加油 ~ ❤ </p>]]></content>
    
    
    <categories>
      
      <category>鱼酱碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>兔酱碎碎念/告别2020</title>
    <link href="/2020/12/31/%E5%85%94%E9%85%B1%E7%A2%8E%E7%A2%8E%E5%BF%B5/%E5%91%8A%E5%88%AB2020/"/>
    <url>/2020/12/31/%E5%85%94%E9%85%B1%E7%A2%8E%E7%A2%8E%E5%BF%B5/%E5%91%8A%E5%88%AB2020/</url>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_12/001.jpg" srcset="/img/loading.gif" alt=""></p><p>今天是2020年的最后一天，今天这个日子给我的感觉很微妙，这种微妙超过了以往的任何一年。</p><p>可能是自己已经大三、也可能是因为要告别前任、也可能是因为…总之，越来越在意跨年这个日子了（不止跨年），也越来越在意身边的亲人和陪伴我的铁哥们了。</p><p>昨天和我老铁吃了烧烤+可乐桶，我没有喝很多，反倒是她，喝了一瓶40°和一瓶14°的，我喝了两瓶锐澳，可乐桶只沾了一点，因为酒真的是太难喝。</p><p>本来觉得喝了酒，头晕晕的，准备很早休息，结果，玩了几把荒野乱斗越玩越清醒。一转眼，已经过了凌晨十二点，已经进入2020的最后一天了。结果更加难以入睡。</p><p>放下手机好几次，结果都是脑海里各种想法冒出来，止都止不住。于是开始思考人生<del>（胡思乱想）</del>，将近半个小时过去了，再次拿起手机，玩一阵手机。如此往复，直到早上六点。</p><p><code>ᓚᘏᗢ 告别前任、找回自我</code></p><p>昨天熬夜玩手机除了打游戏，还点开了许久没有点开的博客，逛了很久。逛博客的时光总是很快乐，不会觉得自己孤独，甚至还觉得一个人很棒，觉得对象也只是个可有可无的人罢了。大三开学之前的我，和谈恋爱后的自己好像判若两人。谈了恋爱以后丢了很多以前的快乐。以前会学习（哪怕不算最认真的那个）、有健身意识、会逛博客（热衷于生活博和技术博，尤其是和我年龄相仿，兴趣相投的），谈恋爱后好像只剩下了他的生活，我迷失了自己（哪怕最后知道了他并没有很爱我）。分手以后，并没有很快回到以前的那个自己，而是陷入他会回来的幻想中，甚至想着只要他回来我就抓住他不再让他走，这个幻想直到今天的此时此刻。但是，我现在已经知道，一切都不可能了，他不会回来，他也不值得我去爱，他不配得到我的爱。过了今天，就踏入了新的一年，在2021，我不再有所幻想，取而代之的是找寻自我，回归真正的自己。要说这段恋爱很失败，的确是很失败。但是也教会了我很多，也第一次让我感受了两个人的生活是什么样子的。</p><p>lsc，再见，希望你以后再也找不见像我一样爱你的人，希望你的生活并不快乐。</p><p>以后的我，依旧是那个爱逛博客，爱健身，爱学习的我</p><p>以后的我，依旧有亲人、铁兄弟陪着的我</p><p>可能唯一变化的就是从明天起要规划着搞钱</p><p><code>ᓚᘏᗢ 憧憬の未来</code></p><p>我想要一间属于自己的房子，公寓楼的四十平一小层的就好，我想要一个自己的归属感，或许这个家不会离爸妈很远。想开一家面包甜品店，店里的甜品一定要非常好吃。以后的生活想要有健身陪着我。</p><p>今天晚上踏上火车，即将解锁寒假生活。</p><p><code>寒假计划</code></p><ul><li>赚一些小钱</li><li>学习前端职业知识</li><li>考科三</li></ul><p>在赚小钱上：今年寒假可以得到大同，做家教/甜点/服务员（最好不要）</p><p>在学习上：曾经也一直想着在校实习，结果也没有成功实现过。我觉得是因为缺少勇气和意志力，其次是缺少技术。寒假也想去找前端实习，我不怕实习地方是在外地。今年开学以后就有春招了，这个寒假不能浪费（突然想起还有六级）</p><p>总之，</p><p>2020的最后一天记下这篇博客。</p><p>告别过去，迎接2021！</p>]]></content>
    
    
    <categories>
      
      <category>鱼酱碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue/Vue</title>
    <link href="/2020/11/28/Vue/Vue/"/>
    <url>/2020/11/28/Vue/Vue/</url>
    
    <content type="html"><![CDATA[<h1 id="一、邂逅Vuejs"><a href="#一、邂逅Vuejs" class="headerlink" title="一、邂逅Vuejs"></a>一、邂逅Vuejs</h1><ol><li><p>简单认识</p><ul><li>渐进式框架</li><li>Vue核心库以及其生态系统（如：Core+Vue-router+Vuex）可以满足更多的业务逻辑</li><li>特点功能<ul><li>解耦视图和数据</li><li>可复用的组件</li><li>前端路由技术</li><li>状态管理</li><li>虚拟DOM</li></ul></li></ul></li><li><p>Vue.js安装</p><ol><li>CDN引入<ul><li>开发环境版本</li><li>生产环境版本</li></ul></li><li>下载和引用</li><li>NPM安装</li></ol></li><li><p>Hello Vuejs</p><ul><li>javascript代码创建了一个Vue对象</li><li>创建对象的时候传入了一些options：{}<ul><li>el属性：决定了vue对象挂载到哪一个元素上</li><li>data属性：通常会存储一些数据<ul><li>数据可以直接定义</li><li>或者来自网络，从服务器加载</li></ul></li></ul></li></ul></li><li><p>Vue列表显示</p><ul><li>html代码中使用v-for指令</li><li>是响应式的</li><li>不需要在JavaScript中完成dom的拼接了</li></ul></li><li><p>案例：计数器</p><ul><li>methods属性：用于vue对象中定义新方法</li><li>@click指令：监听某个元素的点击事件，通常执行的是methods中定义的方法</li></ul></li><li><p>Vue中的MVVM</p><ul><li>View层<ul><li>视图层</li><li>前端开发中通常就是dom层</li><li>给用户展示各种信息</li></ul></li><li>Model层<ul><li>数据层</li><li>数据可能是固定的死数据，更多来自服务器，网络请求下来的数据</li></ul></li><li>VueModel层<ul><li>视图模型层</li><li>view和model沟通的桥梁</li><li>一方面实现了DataBinding，数据绑定，将Model的改变实时反映到view中</li><li>另一方面实现了DomListener，DOM监听，当Dom发生一些事件是可以监听到，并在需要的情况下改变对应的data</li></ul></li></ul></li><li><p>计数器的MVVM</p><ul><li>计数器的MVVM<ul><li>view依旧是dom</li><li>model是抽离出来的obj</li><li>viewModel就是我们创建的vue对象实例</li></ul></li><li>工作流程<ul><li>viewModel通过DataBinding让obj中的数据实时显示在dom中</li><li>其次viewModel通过DOMListener监听Dom时间，通过methods操作改变obj中的数据</li></ul></li></ul><div class="hljs"><pre><code class="hljs django"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>当前计数：</span><span class="hljs-template-variable">&#123;&#123;counter&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="xml">    <span class="hljs-comment">&lt;!--&lt;button v-on:click="counter++"&gt;+&lt;/button&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">"counter<span class="hljs-symbol">&amp;#45;</span><span class="hljs-symbol">&amp;#45;</span>"</span>&gt;</span>-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>--&gt;</span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">"add"</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">"sub"</span>&gt;</span>-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"../js/vue.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><span class="xml">    const obj = &#123;</span><span class="xml">        counter:0,</span><span class="xml">    &#125;</span><span class="xml">    const app = new Vue(&#123;</span><span class="xml">        el:'#app',</span><span class="xml">        data:obj,</span><span class="xml">        methods:&#123;</span><span class="xml">            add:function () &#123;</span><span class="xml">                console.log('add被执行');</span><span class="xml">                this.counter++</span><span class="xml">            &#125;,</span><span class="xml">            sub:function () &#123;</span><span class="xml">                console.log('sub被执行');</span><span class="xml">                this.counter--</span><span class="xml">            &#125;</span><span class="xml">        &#125;</span><span class="xml">    &#125;)</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span></code></pre></div></li><li><p>创建vue实例传入的options</p><ul><li>el</li><li>data</li><li>methods</li></ul></li><li><p>vue的生命周期</p></li></ol><h1 id="二、基本语法"><a href="#二、基本语法" class="headerlink" title="二、基本语法"></a>二、基本语法</h1><p>vue的template：</p><div class="hljs"><pre><code class="hljs django"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;message&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"../js/vue.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><span class="xml">    const app = new Vue(&#123;</span><span class="xml">        el: "#app",</span><span class="xml">        data:&#123;</span><span class="xml">            message: "欢迎你！"</span><span class="xml">        &#125;</span><span class="xml">    &#125;)</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span></code></pre></div><h2 id="1-插值操作mustache"><a href="#1-插值操作mustache" class="headerlink" title="1.插值操作mustache"></a>1.插值操作mustache</h2><ol><li><p>mustache语法</p><ul><li>解析双大括号的内容</li><li>大括号内可不仅可以直接写变量，还可以写表达式</li></ul><div class="hljs"><pre><code class="hljs crystal">直接写变量：<span class="hljs-template-variable">&#123;&#123;message&#125;&#125;</span>变量拼接：<span class="hljs-template-variable">&#123;&#123;firstName + lastName&#125;&#125;</span>变量中间加空格<span class="hljs-template-variable">&#123;&#123;firstName + <span class="hljs-string">' '</span> + lastName&#125;&#125;</span>等同于<span class="hljs-template-variable">&#123;&#123;firstName&#125;&#125;</span> <span class="hljs-template-variable">&#123;&#123;lastName&#125;&#125;</span>变量显示两遍：<span class="hljs-template-variable">&#123;&#123;counter * <span class="hljs-number">2</span>&#125;&#125;</span></code></pre></div></li><li><p>v-once指令</p><ul><li>html标签中使用了v-once时，当改变了data中的数据，页面显示不会变化</li></ul></li><li><p>v-html指令</p><ul><li>当data中的数据为HTML语句时，可以让页面直接解析</li></ul></li><li><p>v-text指令</p><ul><li>显示data中的数据</li></ul><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-text</span>=<span class="hljs-string">"message"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span> 如果message值为2，则页面显示二号标签的2</code></pre></div></li><li><p>v-pre指令</p><ul><li>大括号不再解析，而是直接显示标签中间的内容</li></ul><div class="hljs"><pre><code class="hljs django"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-pre</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;message&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span> 页面直接显示</span><span class="hljs-template-variable">&#123;&#123;message&#125;&#125;</span></code></pre></div></li><li><p>v-blind指令</p><ul><li>基本使用：data的数据绑定到html的属性上<ul><li>如：绑定到图片的src中，链接标签的href中</li></ul></li><li>语法糖：<code>:</code></li></ul></li></ol><h2 id="2-动态绑定属性v-bind"><a href="#2-动态绑定属性v-bind" class="headerlink" title="2.动态绑定属性v-bind"></a>2.动态绑定属性v-bind</h2><ol><li>bind动态绑定class（对象语法）<ul><li>class后面跟的是一个对象</li><li>用法<ul><li>通过大括号直接绑定一个类；可以传入多个值；和普通的类同时存在，并不冲突；复杂时，可以放在一个method或者computed中</li></ul></li></ul></li><li>bind动态绑定class（数组语法）<ul><li>class后面跟的是一个数组</li></ul></li><li>绑定style（对象语法）<ul><li>如：动态绑定style中的font-size和color属性值</li></ul></li><li>绑定style（数组语法）<ul><li>style后跟数组</li></ul></li></ol><h2 id="3-计算属性computed"><a href="#3-计算属性computed" class="headerlink" title="3.计算属性computed"></a>3.计算属性computed</h2><ol><li>基本使用<ul><li>computed：</li></ul></li><li>复杂操作<ul><li>计算书的总价格</li></ul></li></ol><h2 id="4-ES6补充"><a href="#4-ES6补充" class="headerlink" title="4.ES6补充"></a>4.ES6补充</h2><ol><li><p>let/var</p><ul><li>JavaScript中用关键字let修复了var的问题</li><li>块级作用域<ul><li>JS中使用var声明变量时，对于if/for等块定义来说是没有作用域的，往往会引发一些问题</li><li>用函数function（）、或者使用let来声明变量可以避免问题的发生</li></ul></li></ul></li><li><p>const的使用</p><ul><li>被const修饰的标识符为常量，而且在声明的时候就必须赋值，但不可以被再次赋值</li><li>建议：es6开发中，优先使用const，只有需要改变某一个标识符的时候才使用let</li></ul></li><li><p>对象增强写法</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">//1.属性的简写</span><span class="hljs-keyword">let</span> name = <span class="hljs-string">'why'</span><span class="hljs-keyword">let</span> age = <span class="hljs-number">18</span><span class="hljs-comment">//es6之前</span><span class="hljs-keyword">let</span> obj1 = &#123;name:name,age:age&#125;<span class="hljs-built_in">console</span>.log(obj1);<span class="hljs-comment">//es6之后</span><span class="hljs-keyword">let</span> obj2 = &#123;name,age&#125;<span class="hljs-built_in">console</span>.log(obj2);<span class="hljs-comment">//2.方法的简写</span><span class="hljs-comment">//es6之前</span><span class="hljs-keyword">let</span> obj1 = &#123;test:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'obj1的test函数'</span>);&#125;&#125;obj1.test()<span class="hljs-comment">//es6之后</span><span class="hljs-keyword">let</span> obj2 = &#123;test()&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'obj2的test函数'</span>);&#125;&#125;</code></pre></div></li></ol><h2 id="5-事件监听v-on"><a href="#5-事件监听v-on" class="headerlink" title="5.事件监听v-on"></a>5.事件监听v-on</h2><ol><li><p>交互</p><ul><li>监听点击、拖拽、键盘事件等</li><li>v-on指令实现监听</li></ul></li><li><p>v-on</p><ul><li><p>作用：绑定事件监听器</p></li><li><p>缩写：@</p></li><li><p>v-on基础</p><div class="hljs"><pre><code class="hljs django"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;counter&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"increment"</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"decrement"</span>&gt;</span>-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"../js/vue.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><span class="xml">  const app = new Vue(&#123;</span><span class="xml">    el: '#app',</span><span class="xml">    data: &#123;</span><span class="xml">      counter: 0</span><span class="xml">    &#125;,</span><span class="xml">    methods: &#123;</span><span class="xml">      increment() &#123;</span><span class="xml">        this.counter++</span><span class="xml">      &#125;,</span><span class="xml">      decrement() &#123;</span><span class="xml">        this.counter--</span><span class="xml">      &#125;</span><span class="xml">    &#125;</span><span class="xml">  &#125;)</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></code></pre></div></li><li><p>v-on参数</p><ul><li>当通过methods中定义方法，以供@click调用时，需要注意参数问题<ol><li>情况一：如果该方法不需要额外参数，那么方法后的()可以不添加。但是注意：如果方法本身中有一个参数，那么会默认将原生事件event参数传递进去</li><li>情况二：如果需要同时传入某个参数，同时需要event时，可以通过$event传入事件</li></ol></li></ul><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>  <span class="hljs-comment">&lt;!--1.事件调用的方法没有参数--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"btn1Click()"</span>&gt;</span>按钮1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"btn1Click"</span>&gt;</span>按钮1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>  <span class="hljs-comment">&lt;!--2.在事件定义时, 写方法时省略了小括号, 但是方法本身是需要一个参数的, </span><span class="hljs-comment">  这个时候, Vue会默认将浏览器生产的event事件对象作为参数传入到方法--&gt;</span>  <span class="hljs-comment">&lt;!--&lt;button @click="btn2Click(123)"&gt;按钮2&lt;/button&gt;--&gt;</span>  <span class="hljs-comment">&lt;!--&lt;button @click="btn2Click()"&gt;按钮2&lt;/button&gt;--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"btn2Click"</span>&gt;</span>按钮2<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>  <span class="hljs-comment">&lt;!--3.方法定义时, 我们需要event对象, 同时又需要其他参数--&gt;</span>  <span class="hljs-comment">&lt;!-- 在调用方式, 如何手动的获取到浏览器参数的event对象: $event--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"btn3Click(abc, $event)"</span>&gt;</span>按钮3<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"../js/vue.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">  <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="actionscript">    el: <span class="hljs-string">'#app'</span>,</span>    data: &#123;<span class="actionscript">      message: <span class="hljs-string">'你好啊'</span>,</span>      abc: 123    &#125;,    methods: &#123;      btn1Click() &#123;<span class="javascript">        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"btn1Click"</span>);</span>      &#125;,      btn2Click(event) &#123;<span class="javascript">        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'--------'</span>, event);</span>      &#125;,      btn3Click(abc, event) &#123;<span class="javascript">        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'++++++++'</span>, abc, event);</span>      &#125;    &#125;  &#125;)<span class="actionscript">  <span class="hljs-comment">// 如果函数需要参数,但是没有传入, 那么函数的形参为undefined</span></span><span class="actionscript">  <span class="hljs-comment">// function abc(name) &#123;</span></span><span class="actionscript">  <span class="hljs-comment">//   console.log(name);</span></span><span class="actionscript">  <span class="hljs-comment">// &#125;</span></span><span class="actionscript">  <span class="hljs-comment">//</span></span><span class="actionscript">  <span class="hljs-comment">// abc()</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div></li><li><p>v-on修饰符</p><ul><li>处理获取到event的事件的修饰符<ol><li><code>.stop</code>：调用event.stopPropagation()</li><li><code>.prevent</code>：调用event.preventDefault()</li><li><code>.{keyCode | keyAlias}</code>：只当事件是从特定键触发时才触发回调</li><li><code>.native</code>：监听组件根元素的原生事件</li><li><code>.once</code>：只触发一次回调</li></ol></li></ul><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>  <span class="hljs-comment">&lt;!--1. .stop修饰符的使用--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"divClick"</span>&gt;</span>    aaaaaaa    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.stop</span>=<span class="hljs-string">"btnClick"</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-comment">&lt;!--2. .prevent修饰符的使用--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"baidu"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"提交"</span> @<span class="hljs-attr">click.prevent</span>=<span class="hljs-string">"submitClick"</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>  <span class="hljs-comment">&lt;!--3. .监听某个键盘的键帽--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> @<span class="hljs-attr">keyup.enter</span>=<span class="hljs-string">"keyUp"</span>&gt;</span>  <span class="hljs-comment">&lt;!--4. .once修饰符的使用--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.once</span>=<span class="hljs-string">"btn2Click"</span>&gt;</span>按钮2<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"../js/vue.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">  <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="actionscript">    el: <span class="hljs-string">'#app'</span>,</span>    data: &#123;<span class="actionscript">      message: <span class="hljs-string">'你好啊'</span></span>    &#125;,    methods: &#123;      btnClick() &#123;<span class="javascript">        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"btnClick"</span>);</span>      &#125;,      divClick() &#123;<span class="javascript">        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"divClick"</span>);</span>      &#125;,      submitClick() &#123;<span class="javascript">        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'submitClick'</span>);</span>      &#125;,      keyUp() &#123;<span class="javascript">        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'keyUp'</span>);</span>      &#125;,      btn2Click() &#123;<span class="javascript">        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'btn2Click'</span>);</span>      &#125;    &#125;  &#125;)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div></li></ul></li></ol><h2 id="6-条件判断v-if"><a href="#6-条件判断v-if" class="headerlink" title="6.条件判断v-if"></a>6.条件判断v-if</h2><ol><li><p>v-if、v-else-if、v-else</p><ul><li>在dom中渲染/销毁元素组件</li><li>v-if后面的条件为false时，对应的元素以及其子元素不会渲染。也就是根本没有不会有对应的标签出现在DOM中</li></ul><div class="hljs"><pre><code class="hljs django"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"score&gt;=90"</span>&gt;</span>优秀<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">"score&gt;=80"</span>&gt;</span>良好<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">"score&gt;=60"</span>&gt;</span>及格<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">v-else</span>&gt;</span>不及格<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;result&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"../js/vue.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><span class="xml">  const app = new Vue(&#123;</span><span class="xml">    el: '#app',</span><span class="xml">    data: &#123;</span><span class="xml">      score: 99</span><span class="xml">    &#125;,</span><span class="xml">    computed: &#123;</span><span class="xml">      result() &#123;</span><span class="xml">        let showMessage = '';</span><span class="xml">        if (this.score &gt;= 90) &#123;</span><span class="xml">          showMessage = '优秀'</span><span class="xml">        &#125; else if (this.score &gt;= 80) &#123;</span><span class="xml">          showMessage = '良好'</span><span class="xml">        &#125;</span><span class="xml">        // ...</span><span class="xml">        return showMessage</span><span class="xml">      &#125;</span><span class="xml">    &#125;</span><span class="xml">  &#125;)</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></code></pre></div></li><li><p>v-show</p><ul><li>与v-if相似</li><li>区别<ul><li>pv-if当条件为false时，压根不会有对应的元素在DOM中</li><li>v-show当条件为false时，仅仅是将元素的display属性设置为none而已</li></ul></li><li>选择<ul><li>当需要在显示与隐藏之间切片很频繁时，使用v-show</li><li>当只有一次切换时，通过使用v-if</li></ul></li></ul></li></ol><h2 id="7-循环遍历v-for"><a href="#7-循环遍历v-for" class="headerlink" title="7.循环遍历v-for"></a>7.循环遍历v-for</h2><ol><li><p>v-for遍历数组</p><ul><li>如果在遍历的过程中不需要使用索引值：v-for=”movie in movies”</li><li>如果在遍历的过程中，我们需要拿到元素在数组中的索引值：v-for=(item, index) in items</li></ul><div class="hljs"><pre><code class="hljs django"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span></span><span class="xml">  <span class="hljs-comment">&lt;!--1.在遍历的过程中,没有使用索引值(下标值)--&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"item in names"</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;item&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><span class="xml">  <span class="hljs-comment">&lt;!--2.在遍历的过程中, 获取索引值--&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(item, index) in names"</span>&gt;</span></span><span class="xml">      </span><span class="hljs-template-variable">&#123;&#123;index+1&#125;&#125;</span><span class="xml">.</span><span class="hljs-template-variable">&#123;&#123;item&#125;&#125;</span><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"../js/vue.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><span class="xml">  const app = new Vue(&#123;</span><span class="xml">    el: '#app',</span><span class="xml">    data: &#123;</span><span class="xml">      names: ['why', 'kobe', 'james', 'curry']</span><span class="xml">    &#125;</span><span class="xml">  &#125;)</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></code></pre></div></li><li><p>v-for遍历对象</p><div class="hljs"><pre><code class="hljs django"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span></span><span class="xml">  <span class="hljs-comment">&lt;!--1.在遍历对象的过程中, 如果只是获取一个值, 那么获取到的是value--&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"item in info"</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;item&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><span class="xml">  <span class="hljs-comment">&lt;!--2.获取key和value 格式: (value, key) --&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(value, key) in info"</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;value&#125;&#125;</span><span class="xml">-</span><span class="hljs-template-variable">&#123;&#123;key&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><span class="xml">  <span class="hljs-comment">&lt;!--3.获取key和value和index 格式: (value, key, index) --&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(value, key, index) in info"</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;value&#125;&#125;</span><span class="xml">-</span><span class="hljs-template-variable">&#123;&#123;key&#125;&#125;</span><span class="xml">-</span><span class="hljs-template-variable">&#123;&#123;index&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"../js/vue.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><span class="xml">  const app = new Vue(&#123;</span><span class="xml">    el: '#app',</span><span class="xml">    data: &#123;</span><span class="xml">      info: &#123;</span><span class="xml">        name: 'why',</span><span class="xml">        age: 18,</span><span class="xml">        height: 1.88</span><span class="xml">      &#125;</span><span class="xml">    &#125;</span><span class="xml">  &#125;)</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></code></pre></div></li><li><p>组件的key属性</p><ul><li>官方推荐我们在使用v-for时，给对应的元素或组件添加上一个:key属性</li><li>以节点中间插入节点说明我们需要使用key来给每个节点做一个唯一标识</li><li>总之，key的作用主要是为了高效的更新虚拟DOM</li></ul></li><li><p>检测数组更新</p><ul><li>Vue中包含了一组观察数组编译的方法，使用它们改变数组也会触发视图的更新<ul><li>push()</li><li>pop()</li><li>shift()</li><li>unshift()</li><li>splice()</li><li>sort()</li><li>reverse()</li></ul></li></ul></li></ol><h2 id="8-高级函数"><a href="#8-高级函数" class="headerlink" title="8.高级函数"></a>8.高级函数</h2><ol><li>filter</li><li>map</li><li>reduce</li></ol><div class="hljs"><pre><code class="hljs haxe"><span class="hljs-number">1.</span>filter函数的使用<span class="hljs-comment">// 10, 20, 40, 50</span>let <span class="hljs-keyword">new</span><span class="hljs-type">Nums</span> = nums.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> </span>(n) &#123;  <span class="hljs-keyword">return</span> n &lt; <span class="hljs-number">100</span>&#125;)<span class="hljs-comment">// console.log(newNums);</span><span class="hljs-comment">// 2.map函数的使用</span><span class="hljs-comment">// 20, 40, 80, 100</span>let <span class="hljs-keyword">new</span><span class="hljs-type">2Nums</span> = <span class="hljs-keyword">new</span><span class="hljs-type">Nums</span>.map(<span class="hljs-function"><span class="hljs-keyword">function</span> </span>(n) &#123; <span class="hljs-comment">// 20</span>  <span class="hljs-keyword">return</span> n * <span class="hljs-number">2</span>&#125;)console.log(<span class="hljs-keyword">new</span><span class="hljs-type">2Nums</span>);<span class="hljs-comment">// 3.reduce函数的使用</span><span class="hljs-comment">// reduce作用对数组中所有的内容进行汇总</span>let total = <span class="hljs-keyword">new</span><span class="hljs-type">2Nums</span>.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span> </span>(preValue, n) &#123;  <span class="hljs-keyword">return</span> preValue + n&#125;, <span class="hljs-number">0</span>)console.log(total);</code></pre></div><h2 id="9-表单绑定v-model"><a href="#9-表单绑定v-model" class="headerlink" title="9.表单绑定v-model"></a>9.表单绑定v-model</h2><ol><li><p>基本使用</p><ul><li>使用v-model指令实现表单元素和数据双向绑定</li></ul><div class="hljs"><pre><code class="hljs django"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"message"</span>&gt;</span></span><span class="xml">  </span><span class="hljs-template-variable">&#123;&#123;message&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"../js/vue.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><span class="xml">  const app = new Vue(&#123;</span><span class="xml">    el: '#app',</span><span class="xml">    data: &#123;</span><span class="xml">      message: '你好啊'</span><span class="xml">    &#125;</span><span class="xml">  &#125;)</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="xml">//也可以用于textarea</span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"message"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>输入的内容是：</span><span class="hljs-template-variable">&#123;&#123;message&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span></code></pre></div></li><li><p>v-model原理</p><ul><li>v-model其实是一个语法糖，它的背后本质上是包含两个操作<ul><li>v-bind绑定一个value属性</li><li>v-on指令给当前元素绑定input事件</li></ul></li></ul><div class="hljs"><pre><code class="hljs routeros">&lt;input <span class="hljs-attribute">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attribute">v-model</span>=<span class="hljs-string">"message"</span>&gt;等同于&lt;input <span class="hljs-attribute">type</span>=<span class="hljs-string">"text"</span> v-bind:<span class="hljs-attribute">value</span>=<span class="hljs-string">"message"</span> v-on:<span class="hljs-attribute">input</span>=<span class="hljs-string">"message = <span class="hljs-variable">$event</span>.target.value"</span>&gt;</code></pre></div></li><li><p>v-model：radio</p><ul><li>单选框</li></ul><div class="hljs"><pre><code class="hljs django"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"male"</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"radio"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"male"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"男"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"sex"</span>&gt;</span>男</span><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">"female"</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"radio"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"female"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"女"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"sex"</span>&gt;</span>女</span><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>您选择的性别是: </span><span class="hljs-template-variable">&#123;&#123;sex&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"../js/vue.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><span class="xml">  const app = new Vue(&#123;</span><span class="xml">    el: '#app',</span><span class="xml">    data: &#123;</span><span class="xml">      message: '你好啊',</span><span class="xml">      sex: '女'</span><span class="xml">    &#125;</span><span class="xml">  &#125;)</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></code></pre></div></li><li><p>v-model：checkbox</p><ul><li><p>单个勾选框</p><ul><li>v-model即为布尔值</li><li>此时input的value并不影响v-model的值</li></ul></li><li><p>多个勾选框</p><ul><li>因为可以选中多个，所以对应的data中属性是一个数组</li><li>当选中某一个时，就会将input的value添加到数组中</li></ul></li></ul><div class="hljs"><pre><code class="hljs django"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span></span><span class="xml">  <span class="hljs-comment">&lt;!--1.checkbox单选框--&gt;</span></span><span class="xml">  <span class="hljs-comment">&lt;!--&lt;label for="agree"&gt;--&gt;</span></span><span class="xml">    <span class="hljs-comment">&lt;!--&lt;input type="checkbox" id="agree" v-model="isAgree"&gt;同意协议--&gt;</span></span><span class="xml">  <span class="hljs-comment">&lt;!--&lt;/label&gt;--&gt;</span></span><span class="xml">  <span class="hljs-comment">&lt;!--&lt;h2&gt;您选择的是: </span></span><span class="hljs-template-variable">&#123;&#123;isAgree&#125;&#125;</span><span class="xml"><span class="hljs-comment">&lt;/h2&gt;--&gt;</span></span><span class="xml">  <span class="hljs-comment">&lt;!--&lt;button :disabled="!isAgree"&gt;下一步&lt;/button&gt;--&gt;</span></span><span class="xml">  <span class="hljs-comment">&lt;!--2.checkbox多选框--&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"篮球"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"hobbies"</span>&gt;</span>篮球</span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"足球"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"hobbies"</span>&gt;</span>足球</span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"乒乓球"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"hobbies"</span>&gt;</span>乒乓球</span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"羽毛球"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"hobbies"</span>&gt;</span>羽毛球</span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>您的爱好是: </span><span class="hljs-template-variable">&#123;&#123;hobbies&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"item in originHobbies"</span> <span class="hljs-attr">:for</span>=<span class="hljs-string">"item"</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">"item"</span> <span class="hljs-attr">:id</span>=<span class="hljs-string">"item"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"hobbies"</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;item&#125;&#125;</span><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"../js/vue.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><span class="xml">  const app = new Vue(&#123;</span><span class="xml">    el: '#app',</span><span class="xml">    data: &#123;</span><span class="xml">      message: '你好啊',</span><span class="xml">      isAgree: false, // 单选框</span><span class="xml">      hobbies: [], // 多选框,</span><span class="xml">      originHobbies: ['篮球', '足球', '乒乓球', '羽毛球', '台球', '高尔夫球']</span><span class="xml">    &#125;</span><span class="xml">  &#125;)</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></code></pre></div></li><li><p>v-model：select</p><ul><li>单选下拉菜单<ul><li>v-model绑定的是一个值</li><li>当我们选中option中的一个时，会将它对应的value赋值到mySelect中</li></ul></li><li>多选下拉菜单<ul><li>v-model绑定的是一个数组</li><li>当选中多个值时，就会将选中的option对应的value添加到数组mySelects中</li></ul></li></ul><div class="hljs"><pre><code class="hljs django"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span></span><span class="xml">  <span class="hljs-comment">&lt;!--1.选择一个--&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"abc"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"fruit"</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"苹果"</span>&gt;</span>苹果<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"香蕉"</span>&gt;</span>香蕉<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"榴莲"</span>&gt;</span>榴莲<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"葡萄"</span>&gt;</span>葡萄<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>您选择的水果是: </span><span class="hljs-template-variable">&#123;&#123;fruit&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="xml">  <span class="hljs-comment">&lt;!--2.选择多个--&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"abc"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"fruits"</span> <span class="hljs-attr">multiple</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"苹果"</span>&gt;</span>苹果<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"香蕉"</span>&gt;</span>香蕉<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"榴莲"</span>&gt;</span>榴莲<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"葡萄"</span>&gt;</span>葡萄<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>您选择的水果是: </span><span class="hljs-template-variable">&#123;&#123;fruits&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"../js/vue.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><span class="xml">  const app = new Vue(&#123;</span><span class="xml">    el: '#app',</span><span class="xml">    data: &#123;</span><span class="xml">      message: '你好啊',</span><span class="xml">      fruit: '香蕉',</span><span class="xml">      fruits: []</span><span class="xml">    &#125;</span><span class="xml">  &#125;)</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></code></pre></div></li><li><p>值绑定</p><ul><li>动态的给value赋值<ul><li>我们前面的value中的值，都是在定义input的时候直接给定的</li><li>但是真实开发中，这些input的值可能是从网络获取或定义在data中的</li><li>所以我们可以通过v-bind:value动态的给value绑定值</li><li>这就是v-bind在input中的应用</li></ul></li></ul></li><li><p>修饰符</p><ul><li>lazy修饰符<ul><li>默认情况下，v-model默认是在input事件中同步输入框的数据的。</li><li>也就是说，一旦有数据发生改变对应的data中的数据就会自动发生改变。</li><li>lazy修饰符可以让数据在失去焦点或者回车时才会更新</li></ul></li><li>number修饰符<ul><li>默认情况下，在输入框中无论我们输入的是字母还是数字，都会被当做字符串类型进行处理</li><li>但是如果我们希望处理的是数字类型，那么最好直接将内容当做数字处理。</li><li>number修饰符可以让在输入框中输入的内容自动转成数字类型</li></ul></li><li>trim修饰符<ul><li>如果输入的内容首尾有很多空格，通常我们希望将其去除</li><li>trim修饰符可以过滤内容左右两边的空格</li></ul></li></ul><div class="hljs"><pre><code class="hljs django"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span></span><span class="xml">  <span class="hljs-comment">&lt;!--1.修饰符: lazy--&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">v-model.lazy</span>=<span class="hljs-string">"message"</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;message&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="xml">  <span class="hljs-comment">&lt;!--2.修饰符: number--&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"number"</span> <span class="hljs-attr">v-model.number</span>=<span class="hljs-string">"age"</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;age&#125;&#125;</span><span class="xml">-</span><span class="hljs-template-variable">&#123;&#123;typeof age&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="xml">  <span class="hljs-comment">&lt;!--3.修饰符: trim--&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">v-model.trim</span>=<span class="hljs-string">"name"</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>您输入的名字:</span><span class="hljs-template-variable">&#123;&#123;name&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"../js/vue.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><span class="xml">  const app = new Vue(&#123;</span><span class="xml">    el: '#app',</span><span class="xml">    data: &#123;</span><span class="xml">      message: '你好啊',</span><span class="xml">      age: 0,</span><span class="xml">      name: ''</span><span class="xml">    &#125;</span><span class="xml">  &#125;)</span><span class="xml">  var age = 0</span><span class="xml">  age = '1111'</span><span class="xml">  age = '222'</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></code></pre></div></li></ol><h1 id="三、组件化开发"><a href="#三、组件化开发" class="headerlink" title="三、组件化开发"></a>三、组件化开发</h1><h2 id="1-认识组件化"><a href="#1-认识组件化" class="headerlink" title="1.认识组件化"></a>1.认识组件化</h2><ol><li>什么是组件化<ul><li>我们将一个完整的页面分成很多个组件</li><li>每个组件都用于实现页面的一个功能块</li><li>而每一个组件又可以进行细分</li></ul></li><li>vue组件化思想<ul><li>任何的应用都会被抽象成一颗组件树</li></ul></li></ol><h2 id="2-注册组件"><a href="#2-注册组件" class="headerlink" title="2.注册组件"></a>2.注册组件</h2><ul><li>创建组件构造器</li><li>注册组件</li><li>使用组件</li></ul><div class="hljs"><pre><code class="hljs xquery"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span></span><span class="xml">  <span class="hljs-comment">&lt;!--3.使用组件--&gt;</span></span><span class="xml">  </span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">my-cpn</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-cpn</span>&gt;</span></span><span class="xml">  </span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">my-cpn</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-cpn</span>&gt;</span></span><span class="xml">  </span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">my-cpn</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-cpn</span>&gt;</span></span><span class="xml">  </span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">my-cpn</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-cpn</span>&gt;</span></span><span class="xml">  </span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="xml">    </span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="xml">      </span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">my-cpn</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-cpn</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">my-cpn</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-cpn</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"../js/vue.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><span class="xml">  // 1.创建组件构造器对象</span><span class="xml">  const cpnC = Vue.extend(</span><span class="xquery">&#123;</span><span class="xquery">    template: `</span><span class="xquery">      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span><span class="xquery">        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>我是标题<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span></span><span class="xquery">        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是内容, 哈哈哈哈<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span></span><span class="xquery">        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是内容, 呵呵呵呵<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span></span><span class="xquery">      &lt;/div&gt;`</span><span class="xquery">  &#125;</span><span class="xml">)</span><span class="xml">  // 2.注册组件</span><span class="xml">  Vue.component('my-cpn', cpnC)</span><span class="xml">  const app = new Vue(</span><span class="xquery">&#123;</span><span class="xquery">    el: <span class="hljs-string">'#app'</span>,</span><span class="xquery">    data: &#123;</span><span class="xquery">      message: <span class="hljs-string">'你好啊'</span></span><span class="xquery">    &#125;</span><span class="xml">  &#125;)</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></code></pre></div><h2 id="3-局部组件和全局组件"><a href="#3-局部组件和全局组件" class="headerlink" title="3.局部组件和全局组件"></a>3.局部组件和全局组件</h2><ul><li>调用Vue.component()注册组件时，组件的注册是全局的</li><li>这意味着该组件可以在任意Vue示例下使用</li><li>如果我们注册的组件是挂载在某个实例中, 那么就是一个局部组件</li></ul><div class="hljs"><pre><code class="hljs xquery"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"../js/vue.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><span class="xml">  // 1.创建组件构造器</span><span class="xml">  const cpnC = Vue.extend(</span><span class="xquery">&#123;</span><span class="xquery">    template: `</span><span class="xquery">      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span><span class="xquery">        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>我是标题<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span></span><span class="xquery">        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是内容,哈哈哈哈啊<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span></span><span class="xquery">      &lt;/div&gt;</span><span class="xquery">    `</span><span class="xquery">  &#125;</span><span class="xml">)</span><span class="xml">  // 2.注册组件(全局组件, 意味着可以在多个Vue的实例下面使用)</span><span class="xml">  // Vue.component('cpn', cpnC)</span><span class="xml">  // 疑问: 怎么注册的组件才是局部组件了?</span><span class="xml">  const app = new Vue(</span><span class="xquery">&#123;</span><span class="xquery">    el: <span class="hljs-string">'#app'</span>,</span><span class="xquery">    data: &#123;</span><span class="xquery">      message: <span class="hljs-string">'你好啊'</span></span><span class="xquery">    &#125;</span><span class="xml">,</span><span class="xml">    components: </span><span class="xquery">&#123;</span><span class="xquery">      // cpn使用组件时的标签名</span><span class="xquery">      cpn: cpnC</span><span class="xquery">    &#125;</span><span class="xml">  &#125;)</span><span class="xml">  const app2 = new Vue(</span><span class="xquery">&#123;</span><span class="xquery">    el: <span class="hljs-string">'#app2'</span></span><span class="xquery">  &#125;</span><span class="xml">)</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></code></pre></div><h2 id="4-父组件和子组件"><a href="#4-父组件和子组件" class="headerlink" title="4.父组件和子组件"></a>4.父组件和子组件</h2><div class="hljs"><pre><code class="hljs xquery"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span></span><span class="xml">  </span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">cpn2</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn2</span>&gt;</span></span><span class="xml">  <span class="hljs-comment">&lt;!--</span></span><span class="xml"><span class="hljs-comment">&lt;cpn1&gt;&lt;/cpn1&gt;</span></span><span class="xml"><span class="hljs-comment">--&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"../js/vue.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><span class="xml">  // 1.创建第一个组件构造器(子组件)</span><span class="xml">  const cpnC1 = Vue.extend(</span><span class="xquery">&#123;</span><span class="xquery">    template: `</span><span class="xquery">      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span><span class="xquery">        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>我是标题1<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span></span><span class="xquery">        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是内容, 哈哈哈哈<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span></span><span class="xquery">      &lt;/div&gt;</span><span class="xquery">    `</span><span class="xquery">  &#125;</span><span class="xml">)</span><span class="xml">  // 2.创建第二个组件构造器(父组件)</span><span class="xml">  const cpnC2 = Vue.extend(</span><span class="xquery">&#123;</span><span class="xquery">    template: `</span><span class="xquery">      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span><span class="xquery">        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>我是标题2<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span></span><span class="xquery">        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是内容, 呵呵呵呵<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span></span><span class="xquery">        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">cpn1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn1</span>&gt;</span></span></span><span class="xquery">      &lt;/div&gt;</span><span class="xquery">    `,</span><span class="xquery">    components: &#123;</span><span class="xquery">      cpn1: cpnC1</span><span class="xquery">    &#125;</span><span class="xml">  &#125;)</span><span class="xml">  // root组件</span><span class="xml">  const app = new Vue(</span><span class="xquery">&#123;</span><span class="xquery">    el: <span class="hljs-string">'#app'</span>,</span><span class="xquery">    data: &#123;</span><span class="xquery">      message: <span class="hljs-string">'你好啊'</span></span><span class="xquery">    &#125;</span><span class="xml">,</span><span class="xml">    components: </span><span class="xquery">&#123;</span><span class="xquery">      cpn2: cpnC2</span><span class="xquery">    &#125;</span><span class="xml">  &#125;)</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></code></pre></div><ul><li>父子组件错误用法：以子标签的形式在Vue实例中使用</li></ul><h2 id="5-注册组件语法糖"><a href="#5-注册组件语法糖" class="headerlink" title="5.注册组件语法糖"></a>5.注册组件语法糖</h2><ul><li>省去了调用Vue.extend()的步骤，而是可以直接使用一个对象来代替</li></ul><div class="hljs"><pre><code class="hljs xquery"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"../js/vue.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><span class="xml">  // 1.全局组件注册的语法糖</span><span class="xml">  // 1.创建组件构造器</span><span class="xml">  // const cpn1 = Vue.extend()</span><span class="xml">  // 2.注册组件</span><span class="xml">  Vue.component('cpn1', </span><span class="xquery">&#123;</span><span class="xquery">    template: `</span><span class="xquery">      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span><span class="xquery">        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>我是标题1<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span></span><span class="xquery">        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是内容, 哈哈哈哈<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span></span><span class="xquery">      &lt;/div&gt;</span><span class="xquery">    `</span><span class="xquery">  &#125;</span><span class="xml">)</span><span class="xml">  // 2.注册局部组件的语法糖</span><span class="xml">  const app = new Vue(</span><span class="xquery">&#123;</span><span class="xquery">    el: <span class="hljs-string">'#app'</span>,</span><span class="xquery">    data: &#123;</span><span class="xquery">      message: <span class="hljs-string">'你好啊'</span></span><span class="xquery">    &#125;</span><span class="xml">,</span><span class="xml">    components: </span><span class="xquery">&#123;</span><span class="xquery">      <span class="hljs-string">'cpn2'</span>: &#123;</span><span class="xquery">        template: `</span><span class="xquery">          <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></span><span class="xquery">            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>我是标题2<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span></span><span class="xquery">            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是内容, 呵呵呵<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span></span><span class="xquery">          &lt;/div&gt;</span><span class="xquery">    `</span><span class="xquery">      &#125;</span><span class="xml">    &#125;</span><span class="xml">  &#125;)</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></code></pre></div><ol><li><p>模板的分离写法</p><ul><li>将其中的HTML分离出来写，然后挂载到对应的组件上，使结构变得更清晰</li><li>Vue提供了两种方案来定义HTML模块内容<ul><li>使用<code>&lt;script&gt;</code>标签</li><li>使用<code>&lt;template&gt;</code>标签</li></ul></li></ul><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--1.script标签, 注意:类型必须是text/x-template--&gt;</span><span class="hljs-comment">&lt;!--&lt;script type="text/x-template" id="cpn"&gt;--&gt;</span><span class="hljs-comment">&lt;!--&lt;div&gt;--&gt;</span>  <span class="hljs-comment">&lt;!--&lt;h2&gt;我是标题&lt;/h2&gt;--&gt;</span>  <span class="hljs-comment">&lt;!--&lt;p&gt;我是内容,哈哈哈&lt;/p&gt;--&gt;</span><span class="hljs-comment">&lt;!--&lt;/div&gt;--&gt;</span><span class="hljs-comment">&lt;!--&lt;/script&gt;--&gt;</span><span class="hljs-comment">&lt;!--2.template标签--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"cpn"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>我是标题<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是内容,呵呵呵<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"../js/vue.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">  <span class="hljs-comment">// 1.注册一个全局组件</span></span><span class="actionscript">  Vue.component(<span class="hljs-string">'cpn'</span>, &#123;</span><span class="actionscript">    template: <span class="hljs-string">'#cpn'</span></span>  &#125;)<span class="actionscript">  <span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><span class="actionscript">    el: <span class="hljs-string">'#app'</span>,</span>    data: &#123;<span class="actionscript">      message: <span class="hljs-string">'你好啊'</span></span>    &#125;  &#125;)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div></li></ol><h2 id="6-组件数据存放"><a href="#6-组件数据存放" class="headerlink" title="6.组件数据存放"></a>6.组件数据存放</h2><ul><li>vue组件中的数据不可以访问vue实例数据，所以组件应该有自己保存数据的地方</li><li>组件对象也有一个data属性(也可以有methods等属性）</li><li>这个data属性必须是一个函数<ul><li>首先，如果不是一个函数，Vue直接就会报错</li><li>其次，原因是在于Vue让每个组件对象都返回一个新的对象，因为如果是同一个对象的，组件在多次使用后会相互影响</li></ul></li><li>而且这个函数返回一个对象，对象内部保存着数据</li></ul><div class="hljs"><pre><code class="hljs django"><span class="xml">template id="cpn"&gt;</span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;title&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是内容,呵呵呵<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"../js/vue.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><span class="xml">  // 1.注册一个全局组件</span><span class="xml">  Vue.component('cpn', &#123;</span><span class="xml">    template: '#cpn',</span><span class="xml">    data() &#123;</span><span class="xml">      return &#123;</span><span class="xml">        title: 'abc'</span><span class="xml">      &#125;</span><span class="xml">    &#125;</span><span class="xml">  &#125;)</span><span class="xml">  const app = new Vue(&#123;</span><span class="xml">    el: '#app',</span><span class="xml">    data: &#123;</span><span class="xml">      message: '你好啊',</span><span class="xml">      // title: '我是标题'</span><span class="xml">    &#125;</span><span class="xml">  &#125;)</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></code></pre></div><h2 id="7-父子组件通信"><a href="#7-父子组件通信" class="headerlink" title="7.父子组件通信"></a>7.父子组件通信</h2><ol><li><p>父级向子级传递</p><ul><li>在组件中，使用选项props来声明需要从父级接收到的数据</li><li>props的值有两种方式<ul><li>方式一：字符串数组，数组中的字符串就是传递时的名称</li><li>方式二：对象，对象可以设置传递时的类型，也可以设置默认值等</li></ul></li></ul><div class="hljs"><pre><code class="hljs django"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span></span><span class="xml">  <span class="hljs-comment">&lt;!--&lt;cpn v-bind:cmovies="movies"&gt;&lt;/cpn&gt;--&gt;</span></span><span class="xml">  <span class="hljs-comment">&lt;!--&lt;cpn cmovies="movies" cmessage="message"&gt;&lt;/cpn&gt;--&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">cpn</span> <span class="hljs-attr">:cmessage</span>=<span class="hljs-string">"message"</span> <span class="hljs-attr">:cmovies</span>=<span class="hljs-string">"movies"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">cpn</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"cpn"</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"item in cmovies"</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;item&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;cmessage&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"../js/vue.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span><span class="xml">  // 父传子: props</span><span class="xml">  const cpn = &#123;</span><span class="xml">    template: '#cpn',</span><span class="xml">    // props: ['cmovies', 'cmessage'],</span><span class="xml">    props: &#123;</span><span class="xml">      // 1.类型限制</span><span class="xml">      // cmovies: Array,</span><span class="xml">      // cmessage: String,</span><span class="xml">      // 2.提供一些默认值, 以及必传值</span><span class="xml">      cmessage: &#123;</span><span class="xml">        type: String,</span><span class="xml">        default: 'aaaaaaaa',</span><span class="xml">        required: true</span><span class="xml">      &#125;,</span><span class="xml">      // 类型是对象或者数组时, 默认值必须是一个函数</span><span class="xml">      cmovies: &#123;</span><span class="xml">        type: Array,</span><span class="xml">        default() &#123;</span><span class="xml">          return []</span><span class="xml">        &#125;</span><span class="xml">      &#125;</span><span class="xml">    &#125;,</span><span class="xml">    data() &#123;</span><span class="xml">      return &#123;&#125;</span><span class="xml">    &#125;,</span><span class="xml">    methods: &#123;</span><span class="xml">    &#125;</span><span class="xml">  &#125;</span><span class="xml">  const app = new Vue(&#123;</span><span class="xml">    el: '#app',</span><span class="xml">    data: &#123;</span><span class="xml">      message: '你好啊',</span><span class="xml">      movies: ['海王', '海贼王', '海尔兄弟']</span><span class="xml">    &#125;,</span><span class="xml">    components: &#123;</span><span class="xml">      cpn</span><span class="xml">    &#125;</span><span class="xml">  &#125;)</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span></code></pre></div><ul><li>props数据验证<ul><li>在前面，我们的props选项是使用一个数组</li><li>我们说过，除了数组之外，我们也可以使用对象，当需要对props进行类型等验证时，就需要对象写法了</li><li>验证都支持哪些数据类型呢？<ul><li>String</li><li>Number</li><li>Boolean</li><li>Array</li><li>Object</li><li>Date</li><li>Function</li><li>Symbol</li></ul></li><li>当我们有自定义构造函数时，验证也支持自定义的类型</li></ul></li></ul></li><li><p>子级向父级传递</p><ul><li>通过自定义事件来完成</li><li>自定义事件的流程<ul><li>在子组件中，通过$emit()来触发事件</li><li>在父组件中，通过v-on来监听子组件事件</li></ul></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>兔酱碎碎念/钱和男朋友必须有一个</title>
    <link href="/2020/11/28/%E5%85%94%E9%85%B1%E7%A2%8E%E7%A2%8E%E5%BF%B5/%E9%92%B1%E5%92%8C%E7%94%B7%E6%9C%8B%E5%8F%8B%E5%BF%85%E9%A1%BB%E6%9C%89%E4%B8%80%E4%B8%AA/"/>
    <url>/2020/11/28/%E5%85%94%E9%85%B1%E7%A2%8E%E7%A2%8E%E5%BF%B5/%E9%92%B1%E5%92%8C%E7%94%B7%E6%9C%8B%E5%8F%8B%E5%BF%85%E9%A1%BB%E6%9C%89%E4%B8%80%E4%B8%AA/</url>
    
    <content type="html"><![CDATA[<p>如果没有钱和男朋友，当你无聊的时候就会真的无聊 ..(ˉ▽ˉ；)…</p><p>所以，钱和男朋友必须有一个</p><p>现在男朋友已经没了，所以该搞钱了~</p><p><span class="label label-success">ᓚᘏᗢ</span></p><p>这个学期从第十一周（11-09）开始，课就变少了，可以有大把时间来学习前端知识了</p><p>十一周：和男朋友在一起愉快度过</p><p>十二周：和男朋友的吵架分手期</p><p>十三周：走出难过的一周</p><p>今天呢，是第十三周的最后一天（11-28），该告别过去，走向新生活啦~</p><p><span class="label label-success">ᓚᘏᗢ</span></p><p>以后的每一天，都是一个崭新的鱼干</p><p>-💴make money</p><p>-💻keep studying</p>]]></content>
    
    
    <categories>
      
      <category>鱼酱碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>兔酱碎碎念/双节快乐</title>
    <link href="/2020/10/01/%E5%85%94%E9%85%B1%E7%A2%8E%E7%A2%8E%E5%BF%B5/%E5%8F%8C%E8%8A%82%E5%BF%AB%E4%B9%90/"/>
    <url>/2020/10/01/%E5%85%94%E9%85%B1%E7%A2%8E%E7%A2%8E%E5%BF%B5/%E5%8F%8C%E8%8A%82%E5%BF%AB%E4%B9%90/</url>
    
    <content type="html"><![CDATA[<p class="note note-danger">OwO 国庆和中秋组cp </p><p>一转眼已经10-01，又是一个新的开始</p><p>这个学期来了以后，发生了很多事情</p><p>其中最重要的应该就是遇见了大葱 - - -我的初恋男孩</p><p>我从来不觉得除去爸妈有谁会一直陪伴你一生 ，当然如果存在那便更好（:3）</p><p>所以，只希望我们可以相处的尽量更久更幸福一点</p><p>09-06到校 - - - 09-12初识 - - - 10-01今日</p><p>我们已经在一起 20-days</p><p>祝自己一直幸福下去&lt;3</p><p><span class="label label-success">ᓚᘏᗢ</span></p><p>虽然恋爱了，但是还是要不断提升自己，不得不说最近一直在懈怠</p><p>（没有流量、电脑白条、谈恋爱都有关系）</p><ul><li>CET-6</li><li>操作系统</li></ul><p><span class="label label-success">ᓚᘏᗢ   写于2020-11-20</span></p><p>刚写完上面那些，电脑就坏了</p><p>上周电脑刚修好，今天写博客，我们就已经结束了</p><p>一场梦而已，不对的人终会归于人海_</p>]]></content>
    
    
    <categories>
      
      <category>鱼酱碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统/操作系统</title>
    <link href="/2020/09/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2020/09/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="一、操作系统简介"><a href="#一、操作系统简介" class="headerlink" title="一、操作系统简介"></a>一、操作系统简介</h1><ol><li><p>功能</p><ol><li><p>对上/用户角度：控制软件</p><ul><li>管理应用程序</li><li>为应用程序提供服务：声卡、显卡</li><li>杀死应用程序</li></ul></li><li><p>对下：资源管理</p><ul><li><p>cpu、内存</p></li><li><p>管理外设、分配资源</p></li></ul></li></ol></li><li><p>操作系统位于硬件之上、应用程序之下</p></li><li><p>操作系统的界面属于外壳shell，主要研究内核kernel</p></li><li><p>操作系统内部组件包括</p><ul><li>cpu调度器</li><li>物理内存管理</li><li>虚拟内存管理</li><li>文件系统管理</li><li>中断处理与设备驱动</li></ul></li><li><p>特征</p><ul><li>并发：同时存在多个运行的程序</li><li>共享：应用程序“同时”访问内存、cpu</li><li>虚拟：多道程序设计技术</li><li>异步：程序执行走走停停</li></ul></li><li><p>实例</p><ol><li>UNIX家族</li><li>Linux家族<ul><li>redhat、ubuntu</li><li>移动终端、服务器大多数是linux</li></ul></li><li>Windows家族</li></ol></li><li><p>结构</p><ul><li>微内核</li><li>外核</li><li>虚拟机</li></ul></li></ol><h1 id="二、启动"><a href="#二、启动" class="headerlink" title="二、启动"></a>二、启动</h1><ul><li><p>OS起始存放在硬盘DISK</p></li><li><p>基本I/O处理系统BIOS先检测各种外设，加载bootloader</p></li><li><p>Bootloader加载OS进内存，让cpu可以执行操作系统</p></li></ul><h1 id="三、中断、异常和系统调用"><a href="#三、中断、异常和系统调用" class="headerlink" title="三、中断、异常和系统调用"></a>三、中断、异常和系统调用</h1><ol><li><p>定义</p><ul><li>系统调用(来源于应用程序)<br>应用程序主动向操作系统发出服务请求</li><li>异常(来源于不良的应用程序)<br>非法指令或者其他坏的处理状态(如:内存出错)</li><li>中断(来源于外设)<br>来自不同的硬件设备的计时器和网络的中断</li></ul></li><li><p>处理时间</p><ul><li>中断：异步</li><li>异常：同步</li><li>系统调用：异步或同步</li></ul></li><li><p>响应</p><ul><li>中断：持续，对用户应用程序是透明的</li><li>异常:杀死或者重新执行意想不到的应用程序指令</li><li>系统调用:等待和持续</li></ul></li><li><p>中断处理机制</p><ul><li>硬件<ol><li>设置中断标记[CPU初始化]</li><li>将内部、外部事件设置中断标记</li><li>中断事件的ID</li></ol></li><li>软件<ol><li>保存当前处理状态</li><li>中断服务程序处理</li><li>清除中断标记</li><li>恢复之前保存的处理状态</li></ol></li></ul></li><li><p>异常处理机制：异常编号</p><ol><li>保存现场</li><li>异常处理</li><li>杀死产生了异常的程序</li><li>重新执行异常指令</li><li>恢复现场</li></ol></li><li><p>系统调用</p><ul><li>Win32 API用于 Windows</li><li>POSIX API用于POSIX-based systems<br>(包括UNIX，LINUX，Mac OSX的所有版本)</li><li>Java API 用于JAVA虚拟机(JVM)</li></ul></li><li><p>跨越操作系统边界的开销</p><ul><li>在执行时间上的开销超过程序调用</li><li>开销<ul><li>建立中断/异常/系统调用号与对应服务<br>例程映射关系的初始化开销</li><li>建立内核堆栈</li><li>验证参数</li><li>内核态映射到用户态的地址空间<br>更新页面映射权限</li><li>内核态独立地址空间<br>TLB</li></ul></li></ul></li></ol><h1 id="四、内存"><a href="#四、内存" class="headerlink" title="四、内存"></a>四、内存</h1><h2 id="4-1计算机体系结构"><a href="#4-1计算机体系结构" class="headerlink" title="4.1计算机体系结构"></a>4.1计算机体系结构</h2><ul><li><p>CPU：程序执行控制</p><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_09/007.png" srcset="/img/loading.gif" alt=""></p></li><li><p>内存：存放代码和数据</p></li><li><p>设备：硬盘、键盘、鼠标等外设</p></li></ul><blockquote><p>cpu——&gt;缓存（速度快、容量小）——&gt;主存</p></blockquote><h2 id="4-2地址空间和地址生成"><a href="#4-2地址空间和地址生成" class="headerlink" title="4.2地址空间和地址生成"></a>4.2地址空间和地址生成</h2><ol><li>地址空间定义<ul><li>物理地址空间：硬件支持的地址空间</li><li>逻辑地址空间：一个运行的程序所拥有的内存范围</li></ul></li><li>逻辑地址生成<ul><li>C语言：编译、汇编、链接、载入（程序重定位，经过这步程序从磁盘到内存中）</li><li>编译：将基于符号的地址变为逻辑地址</li><li>操作系统：逻辑地址、物理地址之间的映射</li></ul></li><li>物理地址生成<ul><li>cpu<ul><li>运算器需要在逻辑地址的内存内容</li><li>内存管理单元MMU寻找在逻辑地址和物理地址之间的映射</li><li>控制器从总线发送在物理地址的内存内容的请求</li></ul></li><li>内存<ul><li>内存发送物理地址内存的内容给CPU</li></ul></li><li>操作系统<ul><li>建立逻辑地址和物理地址之间的映射</li></ul></li></ul></li></ol><h2 id="4-3连续内存分配"><a href="#4-3连续内存分配" class="headerlink" title="4.3连续内存分配"></a>4.3连续内存分配</h2><ol><li><p>内存碎片问题</p><ul><li>空闲内存不能被利用</li><li>外部碎片</li><li>内部碎片</li></ul></li><li><p>分区的动态分配</p><ol><li>什么时候需要内存分配<ul><li>当一个程序准许运行在内存中时，分配一个连续的区间</li><li>分配一个连续的内存区间给运行的程序以访问数据</li></ul></li><li>分配策略<ul><li>首次适配</li><li>最优适配</li><li>最差适配</li></ul></li></ol></li><li><p>碎片整理</p><ul><li>压缩式碎片整理：把运行程序在内存中移动</li><li>交换式碎片整理：主存——&gt;磁盘（虚拟内存）</li></ul></li></ol><h2 id="4-4非连续内存分配"><a href="#4-4非连续内存分配" class="headerlink" title="4.4非连续内存分配"></a>4.4非连续内存分配</h2><ol><li><p>分段</p><ul><li><p>作用：更好的分离和共享</p></li><li><p>实现：逻辑地址空间分散到多个物理地址空间</p></li><li><p>分段寻址方案——段访问机制</p><ul><li><p>段号、段内偏移</p></li><li><p>操作系统设置段表</p></li></ul></li></ul></li><li><p>分页</p><ul><li>实现<ul><li>划分物理内存至固定大小的帧Frame</li><li>划分逻辑地址空间至相同大小的页Page</li></ul></li><li>帧Frame<ul><li>帧号、帧内偏移</li><li>可以得出物理地址</li></ul></li><li>页page<ul><li>页号、页内偏移</li><li>可以得出逻辑地址</li></ul></li><li>页寻址方案——页寻址机制<ul><li>页号、页表基址</li><li>操作系统建立页表 </li><li>页表保存了逻辑地址–物理地址之间的映射关系</li><li>CPU——&gt;逻辑地址——&gt;页表——&gt;物理地址——&gt;物理内存空间</li></ul></li></ul></li><li><p>页表</p><ol><li>页表结构<ul><li>每个运行的程序都有一个页表</li></ul></li><li>地址转换的实例</li><li>TLB<ul><li>关联内存实现、具备快速访问性能，缓存及其访问的页帧转换表项、节省空间</li><li>如果TLB命中，物理页号可以很快被获取</li><li>未命中，对应的表项被更新到TLB中</li></ul></li><li>二级页表<ul><li>pageNumber分为两块p1、p2</li><li>节省空间、开销大、时间换空间</li></ul></li><li>多级页表</li><li>反向页表<ul><li>基于页寄存器的方案</li><li>基于关联内存的方案</li><li>基于哈希查找的方案</li></ul></li></ol></li></ol><h1 id="五、虚拟内存"><a href="#五、虚拟内存" class="headerlink" title="五、虚拟内存"></a>五、虚拟内存</h1><h2 id="5-1起因"><a href="#5-1起因" class="headerlink" title="5.1起因"></a>5.1起因</h2><p>内存相对于寄存器速度慢，所以内存和寄存器之间有cache</p><p>硬盘比内存容量大，但是速度慢</p><p>磁带比硬盘容量还大</p><p>计算机系统中，尤其是多道程序运行下内存不够用</p><ul><li>手动的覆盖</li><li>自动地交换</li><li>自动的虚拟存储技术</li></ul><h2 id="5-2覆盖技术"><a href="#5-2覆盖技术" class="headerlink" title="5.2覆盖技术"></a>5.2覆盖技术</h2><ol><li><p>目标</p><p>较小的可用内存中运行较大的程序。常用于多道程序系统，与分区存储管理配合使用</p></li><li><p>原理</p><ul><li>程序划分为独立程序模块</li><li>共享内存、分时执行</li><li>常用功能常驻内存、不常用功能放于外存</li></ul></li><li><p>缺点：覆盖模块从外存装入内存，实际上是以时间延长换取空间节省</p></li></ol><h2 id="5-3交换技术"><a href="#5-3交换技术" class="headerlink" title="5.3交换技术"></a>5.3交换技术</h2><ol><li><p>目标</p><p>多道程序在内存中时，让正在运行的程序或需要运行的程序获得更多的内存资源</p></li><li><p>方法</p><ul><li>暂时不能运行的程序送到外存</li></ul></li><li><p>存在的问题</p><ul><li>交换时机的确定：只当内存空间不够或者有不够的危险时</li><li>交换区的大小：足够存放进程的所有内存映像的拷贝；能对这些内存映像直接存取</li><li>程序换入时的重定位：动态地址映射</li></ul></li><li><p>覆盖发生在一个程序里，程序员需要手动指定逻辑关系；交换发生在程序之间，由操作系统内部完成，不需要程序员设置</p></li></ol><h2 id="5-4虚存技术"><a href="#5-4虚存技术" class="headerlink" title="5.4虚存技术"></a>5.4虚存技术</h2><ol><li>目标<ul><li>覆盖技术做的更好：由操作系统自动完成</li><li>交换技术做的更好：只对进程的部分内容在内存和外存之间进行交换 </li></ul></li><li>程序的局部性原理<ul><li>时间局部性：连续两次访问集中在一个较短时期</li><li>空间局部性：访问的数据在较近的区域</li></ul></li><li>基本概念<ul><li>可以在页式或段式内存管理的基础上实现<ul><li>需要执行的部分页面或者段装入到内存</li><li>执行过程中，将尚未在内存但是须执行的程序调入到内存</li><li>内存中暂时不使用的页面或段保存在外存</li></ul></li></ul></li><li>基本特征<ul><li>大的用户空间：物理内存和外存相结合</li><li>部分交换：部分虚拟地址空间进行的</li><li>不连续性：物理内存分配的不连续，虚拟地址空间使用的不连续</li></ul></li><li>实现——虚拟页式内存管理<ul><li>页表<ul><li>完成逻辑页到物理页帧的映射</li></ul></li><li>虚拟页式存储管理技术<ul><li>在页式存储管理的基础上增加请求调页和页面置换功能</li><li>运行过程中程序或者要访问的数据不在内存中，则向系统发出缺页中断请求，系统在处理这个中断时，将外存中相应页面调入内存，使得程序继续运行</li></ul></li><li>页表表项<ul><li>驻留位：表示该页是在内存还是外存</li><li>保护位：表示允许对该页做何种类型的访问</li><li>修改位：该页在内存中是否被修改过（决定是否把它的内容写回外存）</li><li>访问位：该页面被访问过则设置此位（用于页面置换算法）</li></ul></li><li>缺页中断</li><li>后备存储<ul><li>一个虚拟地址空间的页面可以被映射到一个文件（在二级存储中）的某个位置</li><li>代码段：映射到可执行二进制文件</li><li>动态加载的共享库程序段：映射到动态调用的库文件</li><li>其他段：可能被映射到交换文件</li></ul></li><li>虚拟内存性能</li></ul></li></ol><h2 id="5-5页面置换算法"><a href="#5-5页面置换算法" class="headerlink" title="5.5页面置换算法"></a>5.5页面置换算法</h2><ol><li><p>功能</p><p>当缺页中断发生，需要调入新的页面而内存已满时，选择内存中哪个物理页面被置换</p></li><li><p>目标</p><p>尽可能地减少页面的换进换出次数（即缺页中断的次数）</p></li><li><p>页面锁定</p></li><li><p>最优页面置换算法（局部页面置换算法1）</p><ol><li>基本思路<ul><li>距离下一次访问等待时间最长的逻辑页面作为置换的页面</li></ul></li><li>理想情况，可作为其他算法的性能评价的依据 </li></ol></li><li><p>先进先出算法FIFO（局部页面置换算法2）</p><ol><li>基本思路<ul><li>选择在内存中驻留时间最长的页面并淘汰之</li><li>当发生一个缺页中断时，把链首页面淘汰出去，把新的页面添加到链表的末尾</li></ul></li><li>性能较差，并且有belady现象0</li></ol></li><li><p>最近最久未使用算法LRU（局部页面置换算法3）</p><ol><li>基本思路<ul><li>选择最久未使用的那个页面，并淘汰之</li></ul></li><li>最优页面置换算法的近似，基于程序的局部性原理</li><li>LRU算法需要记录各个页面使用时间的先后顺序，开销比较大<ul><li>实现方法<ol><li>系统维护一个页面链表</li><li>设置一个活动页面栈</li></ol></li></ul></li></ol></li><li><p>时钟页面置换算法（局部页面置换算法4）</p><ol><li>基本思路<ul><li>LRU的近似，FIFO的改进</li><li>装入内存页面的页表项的访问位初始化为0，被访问置为1；各个页面组织成环形链表，指针指向最老页面</li></ul></li></ol></li><li><p>二次机会法</p><ol><li><p>修改clock算法，使它允许脏页总是在一次时钟头扫描中保留下来，同事使用脏位和使用位来指导置换</p></li><li><p>Enhanced Clock algorithm</p><table><thead><tr><th>used</th><th>dirty</th><th></th><th>used</th><th>dirty</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>—&gt;</td><td>replace   page</td><td></td></tr><tr><td>0</td><td>1</td><td>—&gt;</td><td>0</td><td>0</td></tr><tr><td>1</td><td>0</td><td>—&gt;</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>—&gt;</td><td>0</td><td>1</td></tr></tbody></table></li></ol></li><li><p>最不常用算法Least Frequently Used ，LFU（局部页面置换算法5）</p><ol><li><p>基本思路</p><p>当一个缺页中断发生时，选择访问次数最少的那个页淘汰之</p></li><li><p>实现方法</p><p>对每个页面设置一个访问计数器，每当一个页面被访问时，该页面的访问计数器加一。在发生缺页中断时，淘汰技术值最小的那个页面</p></li><li><p>LRU和LFU的区别</p><p>LRU考察的是多久未访问，时间越短越好；而LFU考察的是访问的次数或频度，访问次数越多越好</p></li></ol></li><li><p>Belady现象、LRU、FIFO、Clock的比较</p><ol><li><p>Belady现象</p><ul><li><p>现象</p><p>在采用FIFO算法时，有时会出现分配的物理页面数增加，缺页率反而提高的异常现象</p></li><li><p>原因</p><p>FIFO算法的置换特征与进程访问内存的动态特征是矛盾的，与置换算法的目标是不一致的（即替换较少使用的页面），因此，被它置换出去的页面并不一定是进程不会访问的</p></li><li><p>LRU页面置换算法没有Belady现象</p></li></ul></li><li><p>LRU、FIFO、Clock的比较</p><ul><li>LRU、FIFO本质上都是先进先出的思路</li><li>LRU时针对<strong>页面的最近访问时间</strong>来排序、开销大</li><li>FIFO是针对<strong>页面进入内存的时间</strong>来排序、开销小</li><li>如果一个页面进入内存后没有被访问，那么它的最近访问时间就是它进入内存的时间。即LRU退化为FIFO</li></ul></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>兔酱碎碎念/九月开学</title>
    <link href="/2020/09/10/%E5%85%94%E9%85%B1%E7%A2%8E%E7%A2%8E%E5%BF%B5/%E4%B9%9D%E6%9C%88%E5%BC%80%E5%AD%A6/"/>
    <url>/2020/09/10/%E5%85%94%E9%85%B1%E7%A2%8E%E7%A2%8E%E5%BF%B5/%E4%B9%9D%E6%9C%88%E5%BC%80%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="搬寝室"><a href="#搬寝室" class="headerlink" title="搬寝室"></a>搬寝室</h1><p>经过了整整九个月的假期，终于开学了。自从上了幼儿园十七年来，这是唯一一次在家连续待那么长时间</p><p>今年因为疫情，返校后要隔离，所以要从2楼搬到4楼。隔离一周后再搬去3楼。隔离的时候是四人寝——宽敞的四人寝啊 ~ 不过只有一周时间  /(ㄒoㄒ)/~~ </p><p><span class="label label-success">ᓚᘏᗢ   六人寝</span> </p><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_09/004.jpg" srcset="/img/loading.gif" alt=""></p><p><span class="label label-success">ᓚᘏᗢ   四人寝</span> </p><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_09/005.jpg" srcset="/img/loading.gif" alt=""></p><p><span class="label label-success">ᓚᘏᗢ </span> </p><p>六号搬了一下午，搬完以后就已经不早了，没有来得及收拾。</p><p>搁置了九个月的床铺和睡衣都有一股浓浓的土味！</p><p>用于换洗的床单被套在衣柜里，但是找了半天没找见柜门钥匙。所以换了饼干的原始床单被套。最后向宿管阿姨借了一把大钳子剪开了锁 OWO 。回到寝室后，一拉开书包发现两串钥匙都在 ，(ˉ▽ˉ；)…无语辽….</p><p>晚上睡觉发现睡衣 emmm…只能第二天重新洗一下了</p><h1 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h1><p><span class="label label-success">ᓚᘏᗢ </span> </p><p>昨天高中同桌来问我 “要不要考研？”，然后我俩约好了考研考同一所大学，我们都想去大学校吃饭 ಥ_ಥ</p><p><span class="label label-success">ᓚᘏᗢ   </span></p><p> 新学期开始了，六号到校，十号第一天上课</p><ul><li>操作系统</li><li>算法</li><li>数据库</li></ul><p>是本学期的重点，也是作为一个程序员应该学会并且学好的知识</p><ul><li><p>操作系统：想通过买一本额外的书+看学习视频学习</p></li><li><p>算法：看书+刷Leetcode</p></li><li><p>数据库：看书+数据库实操</p></li></ul><p>(ง •_•)ง</p>]]></content>
    
    
    <categories>
      
      <category>鱼酱碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo/DNS污染&amp;修改域名</title>
    <link href="/2020/08/18/Hexo/DNS%E6%B1%A1%E6%9F%93&amp;%E4%BF%AE%E6%94%B9%E5%9F%9F%E5%90%8D/"/>
    <url>/2020/08/18/Hexo/DNS%E6%B1%A1%E6%9F%93&amp;%E4%BF%AE%E6%94%B9%E5%9F%9F%E5%90%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="一、github-io不能访问"><a href="#一、github-io不能访问" class="headerlink" title="一、github.io不能访问"></a>一、github.io不能访问</h1><ol><li><p>在浏览器中输入一个需要登录的网址时，系统会首先自动从Hosts文件中寻找对应的IP地址，一旦找到，系统会立即打开对应网页，如果没有找到，则系统再会将网址提交 DNS域名解析服务器进行该网址的IP地址解析</p><ul><li>DNS域名解析服务器进行该网址的IP地址解析过程</li></ul><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_08/27.png" srcset="/img/loading.gif" alt=""></p></li><li><p>不能访问的原因：电信运营商的DNS污染</p></li><li><p>解决办法</p><ol><li><p>修改host文件即修改域名-IP地址的关联</p></li><li><p>具体步骤</p><ol><li><p>在<a href="https://tool.chinaz.com/dns/" target="_blank" rel="noopener">Dns检测|Dns查询 - 站长工具</a>中输入rainbow0526.github.io，查询DNS所在地及网站IP地址</p><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_08/34.png" srcset="/img/loading.gif" alt=""></p></li><li><p>打开C:\Windows\System32\drivers\etc\hosts文件，保存网址与IP地址的关联</p><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_08/28.png" srcset="/img/loading.gif" alt=""></p></li></ol></li></ol></li></ol><h1 id="二、修改域名"><a href="#二、修改域名" class="headerlink" title="二、修改域名"></a>二、修改域名</h1><h2 id="1、添加CNAME记录"><a href="#1、添加CNAME记录" class="headerlink" title="1、添加CNAME记录"></a>1、添加CNAME记录</h2><ul><li><p>CNAME记录作用：把域名解析到另外一个域名</p></li><li><p>在生成网页的分支上新建文件CNAME，内容为rainbow0526.cn</p><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_08/29.png" srcset="/img/loading.gif" alt=""></p><p>文件内是这样子的：</p><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_08/30.png" srcset="/img/loading.gif" alt=""></p></li></ul><h2 id="2、GitHub-Pages设置Custom-domain"><a href="#2、GitHub-Pages设置Custom-domain" class="headerlink" title="2、GitHub Pages设置Custom domain"></a>2、GitHub Pages设置Custom domain</h2><ul><li>Github Pages 提供自定义域名：GitHub Pages supports using custom domains, or changing the root of your site’s URL from the default</li><li>具体设置：在Custom domian中填入rainbow0526.cn</li></ul><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_08/31.png" srcset="/img/loading.gif" alt=""></p><h2 id="3、自定义域名添加解析"><a href="#3、自定义域名添加解析" class="headerlink" title="3、自定义域名添加解析"></a>3、自定义域名添加解析</h2><ol><li><p>cmd命令行中<code>ping rainbow0526.github.io</code>，得到网站IP地址</p><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_08/32.png" srcset="/img/loading.gif" alt=""></p></li><li><p>到域名解析中添加解析</p><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_08/33.png" srcset="/img/loading.gif" alt=""></p></li></ol><hr><p><em>到此为止，自定义域名就修改成功啦~★,°:.☆(￣▽￣)/$:.°★ 。</em></p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Javaweb/旅游网</title>
    <link href="/2020/08/12/Javaweb/%E6%97%85%E6%B8%B8%E7%BD%91/"/>
    <url>/2020/08/12/Javaweb/%E6%97%85%E6%B8%B8%E7%BD%91/</url>
    
    <content type="html"><![CDATA[<h1 id="一、项目导入"><a href="#一、项目导入" class="headerlink" title="一、项目导入"></a>一、项目导入</h1><ol><li>maven项目通过识别pom.xml来加载</li><li>导入方法<ul><li>方法一：点击右侧maven项目+号，选择pom文件，点击ok开始导入</li><li>方法二：通过file中的Project Structure导入模块</li></ul></li></ol><h1 id="二、启动项目"><a href="#二、启动项目" class="headerlink" title="二、启动项目"></a>二、启动项目</h1><ol><li><p>启动方法</p><ul><li>方法一：点击右侧maven项目中的tomcat:run启动</li><li>方法二：添加配置，点击绿色三角启动项目</li></ul><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_08/24.png" srcset="/img/loading.gif" alt=""></p></li><li><p>报错</p><ul><li>错误1：‘build.plugins.plugin.version’ for org.apache.maven.plugins:maven- compiler-plugin is missing. @ line 122， column 21</li></ul><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_08/10.png" srcset="/img/loading.gif" alt=""></p><ul><li>解决：为插件添加版本信息</li></ul><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_08/12.png" srcset="/img/loading.gif" alt=""></p><ul><li>错误2：Using platform encoding (UTF-8 actually) to copy filtered resources, i.e. build is platform dependent!</li></ul><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_08/11.png" srcset="/img/loading.gif" alt=""></p><ul><li>解决：添加编码属性utf-8</li></ul></li></ol><h1 id="三、技术选型"><a href="#三、技术选型" class="headerlink" title="三、技术选型"></a>三、技术选型</h1><ol><li><p>Web层</p><ol><li>Servlet：前端控制器</li><li>html：视图</li><li>Filter：过滤器</li><li>BeanUtils：数据封装</li><li>Jackson：json序列化工具</li></ol></li><li><p>Service层</p><ol><li>Javamail：java发送邮件工具</li><li>Redis：nosql内存数据库</li><li>Jedis：java的redis客户端</li></ol></li><li><p>Dao层</p><ol><li>Mysql：数据库</li><li>Druid：数据库连接池</li><li>JdbcTemplate：jdbc的工具</li></ol><hr></li></ol><p>web层</p><ul><li>html：这里要求客户访问速度快，且前后端分离，所以用html而不用jsp；如果以后搞后台管理系统，如财务管理，给内部人员，看可以用jsp</li><li>BeanUtils：前台要将数据传到servlet，如表单提交，则需要beanutils进行数据封装成对象</li><li>Jackson：html作为表嵌层，只能用异步的方式来提交到服务器去和从服务器返回数据。一般用json进行异步交互，所以在servlet中需要将服务器响应给客户端的数据用序列化为json返回</li></ul><p>Dao层</p><ul><li>JdbcTemplate：用于连接数据库</li></ul><hr><h1 id="四、创建数据库"><a href="#四、创建数据库" class="headerlink" title="四、创建数据库"></a>四、创建数据库</h1><p>在SQLyog中执行代码：</p><div class="hljs"><pre><code class="hljs sql"><span class="hljs-comment">-- 创建数据库</span><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">DATABASE</span> travel;<span class="hljs-comment">-- 使用数据库</span><span class="hljs-keyword">USE</span> travel;<span class="hljs-comment">--创建表</span>这里粘贴提供好的sql文件中的代码</code></pre></div><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_08/25.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_08/26.png" srcset="/img/loading.gif" alt=""></p><h1 id="五、注册功能"><a href="#五、注册功能" class="headerlink" title="五、注册功能"></a>五、注册功能</h1><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_08/13.png" srcset="/img/loading.gif" alt=""></p><h2 id="1、-表单校验"><a href="#1、-表单校验" class="headerlink" title="1、 表单校验"></a>1、 表单校验</h2><ol><li><p>实现（register.html）</p><ul><li>form标签内加入action属性</li></ul><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--注册表单--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"registerForm"</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"user"</span>&gt;</span></code></pre></div><ul><li>导入jquery，js实现表单的校验</li></ul><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--导入jquery--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"js/jquery-3.3.1.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>/*表单校验：    1.用户名：单词字符，长度8到20位    2.密码：单词字符，长度8到20位    3.email：邮件格式    4.姓名：非空    5.手机号：数字，长度10位    6.出生日期：非空    7.验证码：非空 */   <span class="actionscript"><span class="hljs-comment">//1.校验用户名</span></span><span class="actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkUsername</span><span class="hljs-params">()</span> </span>&#123;</span><span class="actionscript"><span class="hljs-comment">//1.获取用户名值</span></span><span class="javascript"><span class="hljs-keyword">var</span> username = $(<span class="hljs-string">"#username"</span>).val();</span><span class="actionscript"><span class="hljs-comment">//2.定义正则</span></span><span class="javascript"><span class="hljs-keyword">var</span> reg_username = <span class="hljs-regexp">/^\w&#123;8,20&#125;$/</span>;</span><span class="actionscript"><span class="hljs-comment">//3.判断，给出提示信息</span></span><span class="actionscript"><span class="hljs-keyword">var</span> flag = reg_username.test(username);</span>if(flag)&#123;<span class="actionscript"><span class="hljs-comment">//用户名合法</span></span><span class="javascript">                  $(<span class="hljs-string">"#username"</span>).css(<span class="hljs-string">"border"</span>,<span class="hljs-string">""</span>);</span><span class="actionscript">&#125;<span class="hljs-keyword">else</span> &#123;</span><span class="actionscript"><span class="hljs-comment">//用户名非法，加一个红色边框</span></span><span class="javascript">                  $(<span class="hljs-string">"#username"</span>).css(<span class="hljs-string">"border"</span>,<span class="hljs-string">"1px solid red"</span>);</span>&#125;<span class="actionscript"><span class="hljs-keyword">return</span> flag;</span>&#125;<span class="actionscript"><span class="hljs-comment">//2.校验密码</span></span><span class="actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkPassword</span><span class="hljs-params">()</span> </span>&#123;</span><span class="actionscript">              <span class="hljs-comment">//1.获取用户名值</span></span><span class="javascript">              <span class="hljs-keyword">var</span> password = $(<span class="hljs-string">"#password"</span>).val();</span><span class="actionscript">              <span class="hljs-comment">//2.定义正则</span></span><span class="javascript">              <span class="hljs-keyword">var</span> reg_password = <span class="hljs-regexp">/^\w&#123;8,20&#125;$/</span>;</span><span class="actionscript">              <span class="hljs-comment">//3.判断，给出提示信息</span></span><span class="actionscript">              <span class="hljs-keyword">var</span> flag = reg_password.test(password);</span>              if(flag)&#123;<span class="actionscript">                  <span class="hljs-comment">//用户名合法</span></span><span class="javascript">                  $(<span class="hljs-string">"#password"</span>).css(<span class="hljs-string">"border"</span>,<span class="hljs-string">""</span>);</span><span class="actionscript">              &#125;<span class="hljs-keyword">else</span> &#123;</span><span class="actionscript">                  <span class="hljs-comment">//用户名非法，加一个红色边框</span></span><span class="javascript">                  $(<span class="hljs-string">"#password"</span>).css(<span class="hljs-string">"border"</span>,<span class="hljs-string">"1px solid red"</span>);</span>              &#125;<span class="actionscript">              <span class="hljs-keyword">return</span> flag;</span>&#125;<span class="actionscript"><span class="hljs-comment">//3.校验邮箱</span></span><span class="actionscript">          <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkemail</span><span class="hljs-params">()</span></span>&#123;</span><span class="actionscript">    <span class="hljs-comment">//1.获取邮箱</span></span><span class="javascript">              <span class="hljs-keyword">var</span> email = $(<span class="hljs-string">"#email"</span>).val();</span><span class="actionscript">              <span class="hljs-comment">//2.定义正则</span></span><span class="javascript">              <span class="hljs-keyword">var</span> reg_email = <span class="hljs-regexp">/^\w+@\w+\.\w+$/</span>;</span><span class="actionscript">              <span class="hljs-comment">//3.判断</span></span><span class="actionscript">              <span class="hljs-keyword">var</span> flag = reg_email.test(email);</span>              if (flag)&#123;<span class="javascript">                  $(<span class="hljs-string">"#email"</span>).css(<span class="hljs-string">"border"</span>,<span class="hljs-string">""</span>)</span><span class="actionscript">              &#125;<span class="hljs-keyword">else</span> &#123;</span><span class="javascript">                  $(<span class="hljs-string">"#email"</span>).css(<span class="hljs-string">"border"</span>,<span class="hljs-string">"1px solid red"</span>);</span>              &#125;<span class="actionscript">              <span class="hljs-keyword">return</span> flag;</span>             &#125;<span class="actionscript">          <span class="hljs-comment">//4.校验姓名：非空</span></span><span class="actionscript">          <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkName</span><span class="hljs-params">()</span></span>&#123;</span><span class="actionscript">    <span class="hljs-comment">//1.获取姓名</span></span><span class="javascript">              <span class="hljs-keyword">var</span> name = $(<span class="hljs-string">"#name"</span>).val();</span><span class="actionscript">              <span class="hljs-comment">//2.判断</span></span><span class="actionscript">              <span class="hljs-keyword">if</span>(name == <span class="hljs-string">""</span>)&#123;</span><span class="javascript">                  $(<span class="hljs-string">"#name"</span>).css(<span class="hljs-string">"border"</span>,<span class="hljs-string">"1px solid red"</span>);</span><span class="actionscript">                  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><span class="actionscript">              &#125;<span class="hljs-keyword">else</span> &#123;</span><span class="javascript">                  $(<span class="hljs-string">"#name"</span>).css(<span class="hljs-string">"border"</span>,<span class="hljs-string">""</span>);</span><span class="actionscript">                  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span>              &#125;          &#125;<span class="actionscript">          <span class="hljs-comment">//5.校验手机号：数字，长度10位</span></span><span class="actionscript">          <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkTelephone</span><span class="hljs-params">()</span></span>&#123;</span><span class="actionscript">    <span class="hljs-comment">//1.获取手机号</span></span><span class="javascript">              <span class="hljs-keyword">var</span> telephone = $(<span class="hljs-string">"#telephone"</span>).val();</span><span class="actionscript">              <span class="hljs-comment">//2.定义正则</span></span><span class="javascript">              <span class="hljs-keyword">var</span> reg_telephone = <span class="hljs-regexp">/^[0-9]&#123;10&#125;$/</span>;</span><span class="actionscript">              <span class="hljs-comment">//3.判断</span></span><span class="actionscript">              <span class="hljs-keyword">var</span> flag = reg_telephone.test(telephone);</span>              if (flag)&#123;<span class="javascript">                  $(<span class="hljs-string">"#telephone"</span>).css(<span class="hljs-string">"border"</span>,<span class="hljs-string">""</span>);</span><span class="actionscript">              &#125;<span class="hljs-keyword">else</span> &#123;</span><span class="javascript">                  $(<span class="hljs-string">"#telephone"</span>).css(<span class="hljs-string">"border"</span>,<span class="hljs-string">"1px solid red"</span>);</span>              &#125;<span class="actionscript">              <span class="hljs-keyword">return</span> flag;</span>          &#125;<span class="actionscript">          <span class="hljs-comment">//6.校验出生日期：非空</span></span><span class="actionscript">          <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkSex</span><span class="hljs-params">()</span></span>&#123;</span><span class="actionscript">              <span class="hljs-comment">//1.获取姓名</span></span><span class="javascript">              <span class="hljs-keyword">var</span> sex = $(<span class="hljs-string">"#sex"</span>).val();</span><span class="actionscript">              <span class="hljs-comment">//2.判断</span></span><span class="actionscript">              <span class="hljs-keyword">if</span>(sex == <span class="hljs-string">""</span>)&#123;</span><span class="javascript">                  $(<span class="hljs-string">"#sex"</span>).css(<span class="hljs-string">"border"</span>,<span class="hljs-string">"1px solid red"</span>);</span><span class="actionscript">                  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><span class="actionscript">              &#125;<span class="hljs-keyword">else</span> &#123;</span><span class="javascript">                  $(<span class="hljs-string">"#sex"</span>).css(<span class="hljs-string">"border"</span>,<span class="hljs-string">""</span>);</span><span class="actionscript">                  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span>              &#125;          &#125;<span class="actionscript">          <span class="hljs-comment">//7.校验验证码：非空</span></span><span class="actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkCheck</span><span class="hljs-params">()</span></span>&#123;</span><span class="actionscript"><span class="hljs-comment">//1.获取姓名</span></span><span class="javascript"><span class="hljs-keyword">var</span> check = $(<span class="hljs-string">"#check"</span>).val();</span><span class="actionscript"><span class="hljs-comment">//2.判断</span></span><span class="actionscript"><span class="hljs-keyword">if</span>(check == <span class="hljs-string">""</span>)&#123;</span><span class="javascript">$(<span class="hljs-string">"#check"</span>).css(<span class="hljs-string">"border"</span>,<span class="hljs-string">"1px solid red"</span>);</span><span class="actionscript"><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><span class="actionscript">&#125;<span class="hljs-keyword">else</span> &#123;</span><span class="javascript">$(<span class="hljs-string">"#check"</span>).css(<span class="hljs-string">"border"</span>,<span class="hljs-string">""</span>);</span><span class="actionscript"><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span>&#125;&#125;/*<span class="javascript">$(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><span class="actionscript"><span class="hljs-comment">//当表单提交时，调用所有的校验方法</span></span><span class="actionscript"><span class="hljs-comment">//校验通过要转到新的页面</span></span><span class="javascript">$(<span class="hljs-string">"#registerForm"</span>).submit(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><span class="actionscript"><span class="hljs-keyword">return</span> checkUsername() &amp;&amp; checkPassword() &amp;&amp; checkemail();</span><span class="actionscript"><span class="hljs-comment">//如果这个方法没有返回值，或者返回为true，则表单提交，如果返回为false，则表单不提交</span></span>&#125;)&#125;);*/<span class="javascript">$(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><span class="actionscript"><span class="hljs-comment">//当表单提交时，调用所有的校验方法</span></span><span class="actionscript"><span class="hljs-comment">//校验通过要转到新的页面</span></span><span class="javascript">$(<span class="hljs-string">"#registerForm"</span>).submit(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><span class="actionscript"><span class="hljs-comment">//1.发送数据到服务器</span></span>   if(checkUsername() &amp;&amp; checkPassword() &amp;&amp; checkemail())&#123;<span class="actionscript"><span class="hljs-comment">//校验通过发送ajax请求，提交表单的数据 username=张三&amp;password=123</span></span><span class="javascript">$.post(<span class="hljs-string">"registUserServlet"</span>,$(<span class="hljs-keyword">this</span>).serialize(),<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;</span>   <span class="actionscript"><span class="hljs-comment">//处理服务器响应的数据 data &#123;flag:true,errorMsg:"注册失败"&#125;</span></span>if (data.flag)&#123;<span class="actionscript"><span class="hljs-comment">//注册成功，跳转成功页面</span></span><span class="actionscript">location.href=<span class="hljs-string">"register_ok.html"</span>;</span><span class="actionscript">&#125;<span class="hljs-keyword">else</span> &#123;</span><span class="actionscript"><span class="hljs-comment">//注册失败，给errorMsg添加提示信息</span></span><span class="javascript">$(<span class="hljs-string">"#errorMsg"</span>).html(data.errorMsg);</span>&#125;   &#125;)&#125;<span class="actionscript"><span class="hljs-comment">//2.跳转页面</span></span><span class="actionscript"><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><span class="actionscript"><span class="hljs-comment">//如果这个方法没有返回值，或者返回为true，则表单提交，如果返回为false，则表单不提交</span></span>&#125;);<span class="actionscript"><span class="hljs-comment">//当某一个组件失去焦点时，调用对应的校验方法</span></span><span class="javascript">$(<span class="hljs-string">"#username"</span>).blur(checkUsername);  <span class="hljs-comment">//注意：只有方法名，不含括号</span></span><span class="javascript">              $(<span class="hljs-string">"#password"</span>).blur(checkPassword);</span><span class="javascript">              $(<span class="hljs-string">"#email"</span>).blur(checkemail);</span><span class="javascript">              $(<span class="hljs-string">"#name"</span>).blur(checkName);</span><span class="javascript">              $(<span class="hljs-string">"#telephone"</span>).blur(checkTelephone);</span><span class="javascript">              $(<span class="hljs-string">"#sex"</span>).blur(checkSex);</span><span class="javascript">              $(<span class="hljs-string">"#check"</span>).blur(checkCheck);</span>&#125;)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div></li></ol><ol start="2"><li><p>知识充能中……OWO</p><ol><li><p>JavaScript中的$函数</p><ul><li>通过ID获取Element，跟直接调用getElementById()效果是一样的</li><li>例如：$(“#username”)得到的是页面id为”username”的元素Javascript RegExp对象（JavaScript正则对象）</li></ul></li><li><p>Javascript RegExp对象（JavaScript正则对象）</p><ul><li><p><code>test()</code>方法用于检测一个字符串是否匹配某个模式，如果字符串中有匹配的值返回 true ，否则返回 false</p><ul><li>语法：RegExpObject.test(<em>string</em>)</li><li>例如</li></ul><div class="hljs"><pre><code class="hljs arcade"><span class="hljs-comment">//1.获取用户名值</span><span class="hljs-keyword">var</span> username = $(<span class="hljs-string">"username"</span>).val();<span class="hljs-comment">//2.定义正则</span><span class="hljs-keyword">var</span> reg_username = <span class="hljs-regexp">/^\w&#123;8,20&#125;$/</span>;<span class="hljs-comment">//3.判断，给出提示信息</span><span class="hljs-keyword">var</span> flag = reg_username.test(username);</code></pre></div></li></ul></li></ol></li></ol><h2 id="2、异步ajax提交表单"><a href="#2、异步ajax提交表单" class="headerlink" title="2、异步ajax提交表单"></a>2、异步ajax提交表单</h2><ol><li><p>异步ajax提交表单的原因</p><p>为了获取服务器响应的数据。因为我们前台使用的是html作为视图层，不能够直接从servlet相关的域对象获取值，只能通过ajax获取响应数据</p></li><li><p>实现（register.html）</p><div class="hljs"><pre><code class="hljs javascript">$(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-comment">//当表单提交时，调用所有的校验方法</span><span class="hljs-comment">//校验通过要转到新的页面</span>$(<span class="hljs-string">"#registerForm"</span>).submit(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-comment">//1.发送数据到服务器</span><span class="hljs-keyword">if</span>(checkUsername() &amp;&amp; checkPassword() &amp;&amp; checkemail())&#123;<span class="hljs-comment">//校验通过发送ajax请求，提交表单的数据 username=张三&amp;password=123</span>$.post(<span class="hljs-string">"registUserServlet"</span>,$(<span class="hljs-keyword">this</span>).serialize(),<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;<span class="hljs-comment">//处理服务器响应的数据 data &#123;flag:true,errorMsg:"注册失败"&#125;</span><span class="hljs-keyword">if</span> (data.flag)&#123;<span class="hljs-comment">//注册成功，跳转成功页面</span>location.href=<span class="hljs-string">"register_ok.html"</span>;&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//注册失败，给errorMsg添加提示信息</span>$(<span class="hljs-string">"#errorMsg"</span>).html(data.errorMsg);&#125;&#125;);&#125;<span class="hljs-comment">//2.跳转页面</span><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//如果这个方法没有返回值，或者返回为true，则表单提交，如果返回为false，</span>则表单不提交&#125;);</code></pre></div></li></ol><h2 id="3、servlet、service、dao"><a href="#3、servlet、service、dao" class="headerlink" title="3、servlet、service、dao"></a>3、servlet、service、dao</h2><ol><li><p>其中实现的功能括有：验证码判断、前台数据处理、发送邮件、点击邮件内容激活功能</p><ul><li>用户点击邮箱激活其实就是修改用户表中的status为“Y”，分别编写servlet、service、Dao的代码</li></ul><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_08/19.png" srcset="/img/loading.gif" alt=""></p></li><li><p>实现</p><ul><li>RegistUserServlet</li></ul><div class="hljs"><pre><code class="hljs reasonml">@<span class="hljs-constructor">WebServlet(<span class="hljs-string">"/registUserServlet"</span>)</span>public <span class="hljs-keyword">class</span> RegistUserServlet extends HttpServlet &#123;    protected void <span class="hljs-keyword">do</span><span class="hljs-constructor">Post(HttpServletRequest <span class="hljs-params">request</span>, HttpServletResponse <span class="hljs-params">response</span>)</span>     throws ServletException, IOException &#123;        <span class="hljs-comment">//验证校验</span>        String check = request.get<span class="hljs-constructor">Parameter(<span class="hljs-string">"check"</span>)</span>;        <span class="hljs-comment">//从sesion中获取验证码</span>        HttpSession session = request.get<span class="hljs-constructor">Session()</span>;        String checkcode_server = (String) session.get<span class="hljs-constructor">Attribute(<span class="hljs-string">"CHECKCODE_SERVER"</span>)</span>;        session.remove<span class="hljs-constructor">Attribute(<span class="hljs-string">"CHECKCODE_SERVER"</span>)</span>;<span class="hljs-comment">//为了保证验证码只能使用一次</span>        <span class="hljs-comment">//比较</span>        <span class="hljs-keyword">if</span>(checkcode_server<span class="hljs-operator"> == </span>null<span class="hljs-operator"> || </span>!checkcode_server.equals<span class="hljs-constructor">IgnoreCase(<span class="hljs-params">check</span>)</span>)&#123;            <span class="hljs-comment">//验证码错误</span>            ResultInfo info = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ResultInfo()</span>;            <span class="hljs-comment">//注册失败</span>            info.set<span class="hljs-constructor">Flag(<span class="hljs-params">false</span>)</span>;            info.set<span class="hljs-constructor">ErrorMsg(<span class="hljs-string">"验证码错误"</span>)</span>;            <span class="hljs-comment">//将info对象序列化为json</span>            ObjectMapper mapper = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ObjectMapper()</span>;            String json = mapper.write<span class="hljs-constructor">ValueAsString(<span class="hljs-params">info</span>)</span>;            response.set<span class="hljs-constructor">ContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>)</span>;            response.get<span class="hljs-constructor">Writer()</span>.write(json);            return;        &#125;        <span class="hljs-comment">//1.获取数据</span>        Map&lt;String, String<span class="hljs-literal">[]</span>&gt; map = request.get<span class="hljs-constructor">ParameterMap()</span>;        <span class="hljs-comment">//2.封装对象</span>        User user = <span class="hljs-keyword">new</span> <span class="hljs-constructor">User()</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">BeanUtils</span>.</span></span>populate(user,map);        &#125; catch (IllegalAccessException e) &#123;            e.print<span class="hljs-constructor">StackTrace()</span>;        &#125; catch (InvocationTargetException e) &#123;            e.print<span class="hljs-constructor">StackTrace()</span>;        &#125;        <span class="hljs-comment">//3.调用service完成注册</span>        UserService service = <span class="hljs-keyword">new</span> <span class="hljs-constructor">UserServiceImpl()</span>;        boolean flag = service.regist(user);        ResultInfo info = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ResultInfo()</span>;        <span class="hljs-comment">//4.响应结果</span>        <span class="hljs-keyword">if</span>(flag)&#123;            <span class="hljs-comment">//注册成功</span>            info.set<span class="hljs-constructor">Flag(<span class="hljs-params">true</span>)</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-comment">//注册失败</span>            info.set<span class="hljs-constructor">Flag(<span class="hljs-params">false</span>)</span>;            info.set<span class="hljs-constructor">ErrorMsg(<span class="hljs-string">"注册失败!"</span>)</span>;        &#125;        <span class="hljs-comment">//将info对象序列化为json</span>        ObjectMapper mapper = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ObjectMapper()</span>;        String json = mapper.write<span class="hljs-constructor">ValueAsString(<span class="hljs-params">info</span>)</span>;        <span class="hljs-comment">//将json数据写回客户端</span>        <span class="hljs-comment">//设置content-type</span>        response.set<span class="hljs-constructor">ContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>)</span>;        response.get<span class="hljs-constructor">Writer()</span>.write(json);    &#125;    protected void <span class="hljs-keyword">do</span><span class="hljs-constructor">Get(HttpServletRequest <span class="hljs-params">request</span>, HttpServletResponse <span class="hljs-params">response</span>)</span>     throws ServletException, IOException &#123;        this.<span class="hljs-keyword">do</span><span class="hljs-constructor">Post(<span class="hljs-params">request</span>, <span class="hljs-params">response</span>)</span>;    &#125;&#125;</code></pre></div><ul><li>UserService</li></ul><div class="hljs"><pre><code class="hljs routeros">public<span class="hljs-built_in"> interface </span>UserService &#123;    boolean regist(User user);    boolean active(String code);   <span class="hljs-built_in"> User </span>login(User user);&#125;</code></pre></div><ul><li>UserServiceImpl</li></ul><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;    <span class="hljs-keyword">private</span> UserDao userDao = <span class="hljs-keyword">new</span> UserDaoImpl();    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 注册用户</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> user</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">regist</span><span class="hljs-params">(User user)</span> </span>&#123;        <span class="hljs-comment">//1.根据用户名查询用户对象</span>        User u = userDao.findByUsername(user.getUsername());        <span class="hljs-comment">//判断u是否为null</span>        <span class="hljs-keyword">if</span> (u != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-comment">//用户名存在，注册失败</span>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-comment">//2.保存用户信息</span>        <span class="hljs-comment">//2.1设置激活码，唯一字符串</span>        user.setCode(UuidUtil.getUuid());        <span class="hljs-comment">//2.2设置激活状态</span>        user.setStatus(<span class="hljs-string">"N"</span>);        userDao.save(user);        <span class="hljs-comment">//3.激活邮件发送，邮件正文？</span>        <span class="hljs-comment">//String content = "&lt;a href='http://localhost/travel/activeUserServlet?code='"</span>        <span class="hljs-comment">//+user.getCode()+"&gt;点击激活【旅游网】&lt;/a&gt;";</span>        String content=<span class="hljs-string">"&lt;a href='http://localhost/travel/activeUserServlet?code="</span>        +user.getCode()+<span class="hljs-string">"'&gt;点击激活【旅游网】&lt;/a&gt;"</span>;        MailUtils.sendMail(user.getEmail(),content,<span class="hljs-string">"激活邮件"</span>);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 激活用户</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> code</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">active</span><span class="hljs-params">(String code)</span> </span>&#123;        <span class="hljs-comment">//1.根据激活码查询用户对象</span>        User user = userDao.findByCode(code);        <span class="hljs-keyword">if</span> (user != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-comment">//2.调用dao的修改激活状态的方法</span>            userDao.updateStatus(user);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;<span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 登陆方法</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> user</span><span class="hljs-comment">     * <span class="hljs-doctag">@returnnull</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">login</span><span class="hljs-params">(User user)</span> </span>&#123;        <span class="hljs-keyword">return</span> userDao.findByUsernameAndPassword(user.getUsername(),user.getPassword());    &#125;&#125;</code></pre></div><ul><li>UserDao</li></ul><div class="hljs"><pre><code class="hljs crmsh">public interface UserDao &#123;    /**     * 根据用户名查询用户信息     * @param username     * @return     */    public <span class="hljs-keyword">User</span> <span class="hljs-title">findByUsername</span>(<span class="hljs-keyword">String</span> username);    /**     * 用户保存     * @param user     */    public void save (<span class="hljs-keyword">User</span> <span class="hljs-title">user</span>);    <span class="hljs-keyword">User</span> <span class="hljs-title">findByCode</span>(<span class="hljs-keyword">String</span> code);    void updateStatus(<span class="hljs-keyword">User</span> <span class="hljs-title">user</span>);    <span class="hljs-keyword">User</span> <span class="hljs-title">findByUsernameAndPassword</span>(<span class="hljs-keyword">String</span> username, <span class="hljs-keyword">String</span> password);&#125;</code></pre></div><ul><li>UserDaoImpl</li></ul><div class="hljs"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> UserDaoImpl implements UserDao &#123;    private JdbcTemplate template = <span class="hljs-built_in">new</span> JdbcTemplate(JDBCUtils.getDataSource());    @Override    <span class="hljs-built_in">public</span> <span class="hljs-keyword">User</span> findByUsername(String username) &#123;        //<span class="hljs-number">1.</span>定义<span class="hljs-keyword">sql</span>语句        <span class="hljs-keyword">User</span> <span class="hljs-keyword">user</span> = <span class="hljs-keyword">null</span>;        try &#123;  //防止第一次注册时，会直接报错误            String <span class="hljs-keyword">sql</span> = "select * from tab_user where username = ?";            //<span class="hljs-number">2.</span>执行<span class="hljs-keyword">sql</span>            <span class="hljs-keyword">user</span> = <span class="hljs-keyword">template</span>.queryForObject(<span class="hljs-keyword">sql</span>,             <span class="hljs-built_in">new</span> BeanPropertyRowMapper&lt;<span class="hljs-keyword">User</span>&gt;(<span class="hljs-keyword">User</span>.<span class="hljs-keyword">class</span>), username);        &#125; catch (<span class="hljs-keyword">Exception</span> e) &#123;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">user</span>;    &#125;    @Override    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> save(<span class="hljs-keyword">User</span> <span class="hljs-keyword">user</span>) &#123;        //<span class="hljs-number">1.</span>定义<span class="hljs-keyword">sql</span>        //注意：这里添加了status和code才会在数据库保存了激活状态和激活码        String <span class="hljs-keyword">sql</span> = "insert into tab_user(username,password,name,birthday,sex,        telephone,email,status,code) values(?,?,?,?,?,?,?,?,?)";        //<span class="hljs-number">2.</span>执行<span class="hljs-keyword">sql</span>        //注意：这里添加了status和code才会在数据库保存了激活状态和激活码        <span class="hljs-keyword">template</span>.<span class="hljs-keyword">update</span>(<span class="hljs-keyword">sql</span>, <span class="hljs-keyword">user</span>.getUsername(),                <span class="hljs-keyword">user</span>.getPassword(),                <span class="hljs-keyword">user</span>.getName(),                <span class="hljs-keyword">user</span>.getBirthday(),                <span class="hljs-keyword">user</span>.getSex(),                <span class="hljs-keyword">user</span>.getTelephone(),                <span class="hljs-keyword">user</span>.getEmail(),                <span class="hljs-keyword">user</span>.getStatus(),                <span class="hljs-keyword">user</span>.getCode()        );    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 根据激活码查询用户对象</span><span class="hljs-comment">     * @param code</span><span class="hljs-comment">     * @return</span><span class="hljs-comment">     */</span>    @Override    <span class="hljs-built_in">public</span> <span class="hljs-keyword">User</span> findByCode(String code) &#123;        <span class="hljs-keyword">User</span> <span class="hljs-keyword">user</span> = <span class="hljs-keyword">null</span>;        try &#123;            String <span class="hljs-keyword">sql</span> = "select * from tab_user where code = ?";            <span class="hljs-keyword">user</span> = <span class="hljs-keyword">template</span>.queryForObject(<span class="hljs-keyword">sql</span>,             <span class="hljs-built_in">new</span> BeanPropertyRowMapper&lt;<span class="hljs-keyword">User</span>&gt;(<span class="hljs-keyword">User</span>.<span class="hljs-keyword">class</span>), code);        &#125; catch (DataAccessException e) &#123;            e.printStackTrace();        &#125;        //注意：未修改导致结果出现 “激活失败，请联系管理员”        //<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">user</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 修改指定用户激活状态</span><span class="hljs-comment">     * @param user</span><span class="hljs-comment">     */</span>    @Override    <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> updateStatus(<span class="hljs-keyword">User</span> <span class="hljs-keyword">user</span>) &#123;        //注意：这里是tab_user和uid而不是<span class="hljs-keyword">user</span>和id        String <span class="hljs-keyword">sql</span> = "update tab_user set status = 'Y' where uid = ?";        <span class="hljs-keyword">template</span>.<span class="hljs-keyword">update</span>(<span class="hljs-keyword">sql</span>,<span class="hljs-keyword">user</span>.getUid());    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 根据用户名和密码查询的方法</span><span class="hljs-comment">     * @param username</span><span class="hljs-comment">     * @param password</span><span class="hljs-comment">     * @return</span><span class="hljs-comment">     */</span>    @Override    <span class="hljs-built_in">public</span> <span class="hljs-keyword">User</span> findByUsernameAndPassword(String username, String <span class="hljs-keyword">password</span>) &#123;        //<span class="hljs-number">1.</span>定义<span class="hljs-keyword">sql</span>语句        <span class="hljs-keyword">User</span> <span class="hljs-keyword">user</span> = <span class="hljs-keyword">null</span>;        try &#123;  //防止第一次注册时，会直接报错误            String <span class="hljs-keyword">sql</span> = "select * from tab_user where username = ? and password = ?";            //<span class="hljs-number">2.</span>执行<span class="hljs-keyword">sql</span>            <span class="hljs-keyword">user</span> = <span class="hljs-keyword">template</span>.queryForObject(<span class="hljs-keyword">sql</span>,             <span class="hljs-built_in">new</span> BeanPropertyRowMapper&lt;<span class="hljs-keyword">User</span>&gt;(<span class="hljs-keyword">User</span>.<span class="hljs-keyword">class</span>), username, <span class="hljs-keyword">password</span>);        &#125; catch (<span class="hljs-keyword">Exception</span> e) &#123;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">user</span>;    &#125;&#125;</code></pre></div></li><li><p>报错</p><ul><li>错误1：java.lang.IllegalArgumentException: Property ‘dataSource’ is required</li><li>解决</li></ul><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_08/15.png" srcset="/img/loading.gif" alt=""></p><ul><li><p>错误2：java:程序包XXX不存在</p><p>Idea版本为2020.1，maven版本为3.6.3，jar包的确已经下载到自定义本地库</p></li></ul><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_08/16.png" srcset="/img/loading.gif" alt=""></p><ul><li><p>解决</p><p>此处改bug历时整整一天还要多些！QWQ…具体事况发展如下…</p><ul><li>无数次点击右上角Maven工程里的的Reimport All Maven Projects。失败！</li><li>close、import工程 。失败！</li><li>删除掉本地库（自定义的本地库）的所有包，重新import工程。失败！</li><li>将conf/setting.xml文件里的自定义本地库删除，使用默认；修改IDEA中的设置，设置的是自定义的本地库，重新import工程。失败！</li><li>在IDEA的Terminal-local界面中执行<code>mvn clean</code>、<code>mvn install</code>，然后点击右上角Maven工程里的的Reimport All Maven Projects。成功！</li></ul><p>在这里执行<code>mvn install</code> 时，download了很多依赖；执行结束后是下图的样子 — 打包后的文件被放在了默认的本地库里，于是赶忙去默认的本地库位置查看了一下，果然刚刚download的依赖也在这里。但是，明明已经在IDEA中修改了设置 — 本地库使用自定义，结果却下载、打包都放在了默认仓库中。</p><p>很是疑惑(・∀・(・∀・(・∀・*)还有待搞清楚具体原因QWQ</p><ul><li>难道Terminal窗口的命令和cmd窗口是一样的？（也就是说配置根据conf/setting.xml，而不是IDEA中的设置）</li><li>为什么明明已经设置了自定义本地库，但是只有依赖在默认仓库里时，IDEA的项目启动后才会被识别？</li></ul><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_08/17.png" srcset="/img/loading.gif" alt=""></p><p>附参考链接：<a href="https://www.pianshen.com/article/63891191152/" target="_blank" rel="noopener">点击跳转</a></p></li><li><p>错误3：javax.mail.AuthenticationFailedException: 535 Login Fail. Please enter your authorization code to login</p><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_08/18.png" srcset="/img/loading.gif" alt=""></p></li><li><p>解决：修改prop.put中的参数为163.com</p><p>附参考链接：<a href="https://blog.csdn.net/weixin_38465623/article/details/80789793" target="_blank" rel="noopener">点击跳转</a></p></li><li><p>错误4：点击激活邮件中的激活链接后，跳转的网址中code无值</p></li></ul><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_08/20.png" srcset="/img/loading.gif" alt=""></p><ul><li>解决：跳转链接的href属性值写错了</li></ul><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_08/21.png" srcset="/img/loading.gif" alt=""></p><ul><li>错误5：错误1已经解决的情况下，code有了值，但是页面显示“激活失败，请联系管理员”</li></ul><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_08/22.png" srcset="/img/loading.gif" alt=""></p><ul><li>解决：code值成功传到地址栏，成功跳转到对应的servlet，但是findByCode方法return null，所以返回user为空，出现了错误。这里应该将user返回</li></ul><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_08/23.png" srcset="/img/loading.gif" alt=""></p></li></ol><h1 id="六、登录功能"><a href="#六、登录功能" class="headerlink" title="六、登录功能"></a>六、登录功能</h1><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_08/14.png" srcset="/img/loading.gif" alt=""></p><h2 id="1、登录页"><a href="#1、登录页" class="headerlink" title="1、登录页"></a>1、登录页</h2><ol><li><p>实现</p><ul><li>按钮设置id</li></ul><div class="hljs"><pre><code class="hljs routeros">&lt;button <span class="hljs-attribute">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attribute">id</span>=<span class="hljs-string">"btn_sub"</span>&gt;登录&lt;/button&gt;</code></pre></div><ul><li>提交事件</li></ul><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">$(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><span class="actionscript"><span class="hljs-comment">//1.给登录按钮绑定单击事件</span></span><span class="javascript">$(<span class="hljs-string">"#btn_sub"</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><span class="actionscript"><span class="hljs-comment">//2.发送ajax请求，提交表单数据</span></span><span class="javascript">$.post(<span class="hljs-string">"loginServlet"</span>,$(<span class="hljs-string">"#loginForm"</span>).serialize(),<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;</span><span class="actionscript"><span class="hljs-comment">//data : &#123;flag:false,errorMsg:''&#125;</span></span>if (data.flag)&#123;<span class="actionscript"><span class="hljs-comment">//登陆成功</span></span><span class="actionscript">location.href=<span class="hljs-string">"index.html"</span>;</span><span class="actionscript">&#125;<span class="hljs-keyword">else</span> &#123;</span><span class="actionscript"><span class="hljs-comment">//登陆失败</span></span><span class="javascript">$(<span class="hljs-string">"#errorMsg"</span>).html(data.errorMsg);</span>&#125;&#125;);&#125;);&#125;)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div></li></ol><h2 id="2、登陆成功姓名提示"><a href="#2、登陆成功姓名提示" class="headerlink" title="2、登陆成功姓名提示"></a>2、登陆成功姓名提示</h2><ol><li><p>异步交互：html页面不能通过el表达式，通过session获得用户信息，需要通过异步交互获取，ajax请求</p></li><li><p>实现</p><ul><li>页面显示部分（header.html）</li></ul><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">    $(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><span class="javascript">        $.<span class="hljs-keyword">get</span>("findUserServlet",&#123;&#125;,<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;</span><span class="actionscript">            <span class="hljs-comment">//&#123;uid:1,name:'李四'&#125;</span></span><span class="actionscript">            <span class="hljs-keyword">var</span> msg = <span class="hljs-string">"欢迎回来，"</span>+data.name;</span><span class="javascript">            $(<span class="hljs-string">"#span_username"</span>).html(msg);</span>        &#125;);    &#125;);<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><ul><li>取出数据（FindUserServlet）</li></ul><div class="hljs"><pre><code class="hljs reasonml">@<span class="hljs-constructor">WebServlet(<span class="hljs-string">"/findUserServlet"</span>)</span>public <span class="hljs-keyword">class</span> FindUserServlet extends HttpServlet &#123;    protected void <span class="hljs-keyword">do</span><span class="hljs-constructor">Post(HttpServletRequest <span class="hljs-params">request</span>, HttpServletResponse <span class="hljs-params">response</span>)</span>     throws ServletException, IOException &#123;        <span class="hljs-comment">//从session中获取登录用户</span>        Object user = request.get<span class="hljs-constructor">Session()</span>.get<span class="hljs-constructor">Attribute(<span class="hljs-string">"user"</span>)</span>;        <span class="hljs-comment">//将user写回客户端</span>        ObjectMapper mapper = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ObjectMapper()</span>;        response.set<span class="hljs-constructor">ContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>)</span>;        mapper.write<span class="hljs-constructor">Value(<span class="hljs-params">response</span>.<span class="hljs-params">getOutputStream</span>()</span>,user);    &#125;    protected void <span class="hljs-keyword">do</span><span class="hljs-constructor">Get(HttpServletRequest <span class="hljs-params">request</span>, HttpServletResponse <span class="hljs-params">response</span>)</span>     throws ServletException, IOException &#123;        this.<span class="hljs-keyword">do</span><span class="hljs-constructor">Post(<span class="hljs-params">request</span>,<span class="hljs-params">response</span>)</span>;    &#125;&#125;</code></pre></div></li></ol><h2 id="3、servlet、service、dao-1"><a href="#3、servlet、service、dao-1" class="headerlink" title="3、servlet、service、dao"></a>3、servlet、service、dao</h2><ol><li><p>完成登录功能</p></li><li><p>实现</p><ul><li>LoginServlet</li></ul><div class="hljs"><pre><code class="hljs reasonml">@<span class="hljs-constructor">WebServlet(<span class="hljs-string">"/loginServlet"</span>)</span>public <span class="hljs-keyword">class</span> LoginServlet extends HttpServlet &#123;    protected void <span class="hljs-keyword">do</span><span class="hljs-constructor">Post(HttpServletRequest <span class="hljs-params">request</span>, HttpServletResponse <span class="hljs-params">response</span>)</span>     throws ServletException, IOException &#123;        <span class="hljs-comment">//1.获取用户名和密码数据</span>        Map&lt;String, String<span class="hljs-literal">[]</span>&gt; map = request.get<span class="hljs-constructor">ParameterMap()</span>;        <span class="hljs-comment">//2.封装User对象</span>        User user = <span class="hljs-keyword">new</span> <span class="hljs-constructor">User()</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">BeanUtils</span>.</span></span>populate(user,map);        &#125; catch (IllegalAccessException e) &#123;            e.print<span class="hljs-constructor">StackTrace()</span>;        &#125; catch (InvocationTargetException e) &#123;            e.print<span class="hljs-constructor">StackTrace()</span>;        &#125;        <span class="hljs-comment">//3.调用service查询</span>        UserService service = <span class="hljs-keyword">new</span> <span class="hljs-constructor">UserServiceImpl()</span>;        User u = service.login(user);        ResultInfo info = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ResultInfo()</span>;        <span class="hljs-comment">//4.判断用户对象是否为null</span>        <span class="hljs-keyword">if</span> (u<span class="hljs-operator"> == </span>null)&#123;            <span class="hljs-comment">//用户名或密码错误</span>            info.set<span class="hljs-constructor">Flag(<span class="hljs-params">false</span>)</span>;            info.set<span class="hljs-constructor">ErrorMsg(<span class="hljs-string">"用户名或密码错误"</span>)</span>;        &#125;        <span class="hljs-comment">//5.判断用户是否激活</span>        <span class="hljs-keyword">if</span> (u != null<span class="hljs-operator"> &amp;&amp; </span>!<span class="hljs-string">"Y"</span>.equals(u.get<span class="hljs-constructor">Status()</span>))&#123;            <span class="hljs-comment">//用户尚未激活</span>            info.set<span class="hljs-constructor">Flag(<span class="hljs-params">false</span>)</span>;            info.set<span class="hljs-constructor">ErrorMsg(<span class="hljs-string">"您尚未激活，待激活"</span>)</span>;        &#125;        <span class="hljs-comment">//6.判断登陆成功</span>        <span class="hljs-keyword">if</span> (u != null<span class="hljs-operator"> &amp;&amp; </span><span class="hljs-string">"Y"</span>.equals(u.get<span class="hljs-constructor">Status()</span>))&#123;            <span class="hljs-comment">//登陆成功</span>            info.set<span class="hljs-constructor">Flag(<span class="hljs-params">true</span>)</span>;        &#125;        <span class="hljs-comment">//存入session</span>        request.get<span class="hljs-constructor">Session()</span>.set<span class="hljs-constructor">Attribute(<span class="hljs-string">"user"</span>,<span class="hljs-params">u</span>)</span>;        <span class="hljs-comment">//响应数据</span>        ObjectMapper mapper = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ObjectMapper()</span>;        response.set<span class="hljs-constructor">ContentType(<span class="hljs-string">"application/json;charset=utf-8"</span>)</span>;        mapper.write<span class="hljs-constructor">Value(<span class="hljs-params">response</span>.<span class="hljs-params">getOutputStream</span>()</span>,info);    &#125;    protected void <span class="hljs-keyword">do</span><span class="hljs-constructor">Get(HttpServletRequest <span class="hljs-params">request</span>, HttpServletResponse <span class="hljs-params">response</span>)</span>     throws ServletException, IOException &#123;        this.<span class="hljs-keyword">do</span><span class="hljs-constructor">Post(<span class="hljs-params">request</span>,<span class="hljs-params">response</span>)</span>;    &#125;&#125;</code></pre></div><ul><li>UserService</li></ul><p>注册功能代码段中的下面这行代码</p><div class="hljs"><pre><code class="hljs crmsh"><span class="hljs-keyword">User</span> <span class="hljs-title">login</span>(<span class="hljs-keyword">User</span> <span class="hljs-title">user</span>);</code></pre></div><ul><li>UserServiceImpl</li></ul><p>注册功能代码段中的下面这行代码</p><div class="hljs"><pre><code class="hljs crmsh">/** * 登陆方法 * @param user * @returnnull */@Overridepublic <span class="hljs-keyword">User</span> <span class="hljs-title">login</span>(<span class="hljs-keyword">User</span> <span class="hljs-title">user</span>) &#123;       return userDao.findByUsernameAndPassword(user.getUsername(),user.getPassword());&#125;</code></pre></div><ul><li>UserDao</li></ul><p>注册功能代码段中的下面这行代码</p><div class="hljs"><pre><code class="hljs crmsh"><span class="hljs-keyword">User</span> <span class="hljs-title">findByUsernameAndPassword</span>(<span class="hljs-keyword">String</span> username, <span class="hljs-keyword">String</span> password);</code></pre></div><ul><li>UserDaoImpl</li></ul><p>注册功能代码段中的下面这行代码</p><div class="hljs"><pre><code class="hljs pgsql"><span class="hljs-comment">/**</span><span class="hljs-comment">     * 根据用户名和密码查询的方法</span><span class="hljs-comment">     * @param username</span><span class="hljs-comment">     * @param password</span><span class="hljs-comment">     * @return</span><span class="hljs-comment">     */</span>    @Override    <span class="hljs-built_in">public</span> <span class="hljs-keyword">User</span> findByUsernameAndPassword(String username, String <span class="hljs-keyword">password</span>) &#123;        //<span class="hljs-number">1.</span>定义<span class="hljs-keyword">sql</span>语句        <span class="hljs-keyword">User</span> <span class="hljs-keyword">user</span> = <span class="hljs-keyword">null</span>;        try &#123;  //防止第一次注册时，会直接报错误            String <span class="hljs-keyword">sql</span> = "select * from tab_user where username = ? and password = ?";            //<span class="hljs-number">2.</span>执行<span class="hljs-keyword">sql</span>            <span class="hljs-keyword">user</span> = <span class="hljs-keyword">template</span>.queryForObject(<span class="hljs-keyword">sql</span>,             <span class="hljs-built_in">new</span> BeanPropertyRowMapper&lt;<span class="hljs-keyword">User</span>&gt;(<span class="hljs-keyword">User</span>.<span class="hljs-keyword">class</span>), username, <span class="hljs-keyword">password</span>);        &#125; catch (<span class="hljs-keyword">Exception</span> e) &#123;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">user</span>;    &#125;</code></pre></div></li></ol><h1 id="七、退出登录"><a href="#七、退出登录" class="headerlink" title="七、退出登录"></a>七、退出登录</h1><ol><li><p>session中有user对象即为登录</p><ul><li>实现步骤<ol><li>访问servlet，将session销毁</li><li>跳转到登录页面</li></ol></li></ul></li><li><p>实现</p><ul><li>点击退出访问exitServlet（header.html）</li></ul><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"javascript:location.href='exitServlet';"</span>&gt;</span>退出<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre></div><ul><li>创建ExitServlet</li></ul><div class="hljs"><pre><code class="hljs reasonml">@<span class="hljs-constructor">WebServlet(<span class="hljs-string">"/exitServlet"</span>)</span>public <span class="hljs-keyword">class</span> ExitServlet extends HttpServlet &#123;    protected void <span class="hljs-keyword">do</span><span class="hljs-constructor">Post(HttpServletRequest <span class="hljs-params">request</span>, HttpServletResponse <span class="hljs-params">response</span>)</span>    throws ServletException, IOException &#123;        <span class="hljs-comment">//1.销毁session</span>        request.get<span class="hljs-constructor">Session()</span>.invalidate<span class="hljs-literal">()</span>;        <span class="hljs-comment">//2.跳转登陆页面（重定向</span>        response.send<span class="hljs-constructor">Redirect(<span class="hljs-params">request</span>.<span class="hljs-params">getContextPath</span>()</span>+<span class="hljs-string">"/login.html"</span>);    &#125;    protected void <span class="hljs-keyword">do</span><span class="hljs-constructor">Get(HttpServletRequest <span class="hljs-params">request</span>, HttpServletResponse <span class="hljs-params">response</span>)</span>     throws ServletException, IOException &#123;        <span class="hljs-keyword">do</span><span class="hljs-constructor">Post(<span class="hljs-params">request</span>,<span class="hljs-params">response</span>)</span>;    &#125;&#125;</code></pre></div></li></ol><h1 id="八、优化Servlet"><a href="#八、优化Servlet" class="headerlink" title="八、优化Servlet"></a>八、优化Servlet</h1><p>减少servlet的数量，现在是一个功能一个servlet，将其优化成为一个模块一个servlet，相当于在数据库中一张表对应一个servlet，在servlet中提供不同的方法，完成用户的请求</p><p>BaseServlet的抽取：</p><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_08/35.png" srcset="/img/loading.gif" alt=""></p><h1 id="九、分类菜单"><a href="#九、分类菜单" class="headerlink" title="九、分类菜单"></a>九、分类菜单</h1><p>分类菜单的分类从数据库取出：</p><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_08/36.png" srcset="/img/loading.gif" alt=""></p><p>要启动redis服务器才能成功显示分类菜单</p><h1 id="十、分页展示"><a href="#十、分页展示" class="headerlink" title="十、分页展示"></a>十、分页展示</h1><p>点击分类菜单，对应显示的页面从数据库取出：</p><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_08/37.png" srcset="/img/loading.gif" alt=""></p><p>视频内容是31p-39p</p><p>其中，31p缺少route_list.html的编写，缺少的是如下代码（获取cid）：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">$(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><span class="actionscript"><span class="hljs-keyword">var</span> search = location.search;</span><span class="actionscript"><span class="hljs-comment">//alert(search);  //?id = 5</span></span><span class="actionscript"><span class="hljs-comment">//切割字符串，拿到第二个值</span></span><span class="actionscript"><span class="hljs-keyword">var</span> cid = search.split(<span class="hljs-string">"="</span>)[<span class="hljs-number">1</span>];</span>&#125;)<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></div><p>32p缺少domain目录下PageBean的编写</p><p>33p还没有结束RouteServlet的编写，缺少的是如下代码：</p><div class="hljs"><pre><code class="hljs reasonml"><span class="hljs-comment">//3. 调用service查询PageBean对象</span>PageBean&lt;Route&gt; pb = routeService.page<span class="hljs-constructor">Query(<span class="hljs-params">cid</span>, <span class="hljs-params">currentPage</span>, <span class="hljs-params">pageSize</span>)</span>;<span class="hljs-comment">//4. 将pageBean对象序列化为json，返回</span>write<span class="hljs-constructor">Value(<span class="hljs-params">pb</span>,<span class="hljs-params">response</span>)</span>;</code></pre></div><p>还缺少了service、serviceImpl的创建</p><p>json数据：</p><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_09/001.png" srcset="/img/loading.gif" alt=""></p><h1 id="十一、搜索栏"><a href="#十一、搜索栏" class="headerlink" title="十一、搜索栏"></a>十一、搜索栏</h1><p>报错：PreparedStatementCallback; SQL [select count(*) from tab_route where 1=1 ]; Parameter index out of range (1 &gt; number of parameters, which is 0).;</p><p>解决：</p><h1 id="十二、查看详情"><a href="#十二、查看详情" class="headerlink" title="十二、查看详情"></a>十二、查看详情</h1><p>后台分析：</p><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_09/002.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_09/003.png" srcset="/img/loading.gif" alt=""></p><p>前台分析：</p><p>Route_detail.html中加载后</p><ol><li>获取rid</li><li>发送ajax请求，获取route对象</li><li>解析对象的数据</li></ol><h1 id="十三、线路收藏"><a href="#十三、线路收藏" class="headerlink" title="十三、线路收藏"></a>十三、线路收藏</h1>]]></content>
    
    
    <categories>
      
      <category>Javaweb</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Maven/Maven</title>
    <link href="/2020/08/10/Maven/Maven/"/>
    <url>/2020/08/10/Maven/Maven/</url>
    
    <content type="html"><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><h2 id="1、Maven概述"><a href="#1、Maven概述" class="headerlink" title="1、Maven概述"></a>1、Maven概述</h2><ol><li>Maven是一个项目的构建工具</li><li>Maven作用<ul><li>管理依赖<ol><li>maven可以管理jar文件</li><li>自动下载jar和他的文档，源代码</li><li>管理jar直接的依赖，a. jar需要b.jar，maven会自动下载b. jar</li><li>管理你需要的jar版本</li><li>编译程序，把java编译为class</li><li>测试你的代码是否正确</li><li>打包文件，形成jar文件， 或者war文件</li><li>部署项目</li></ol></li><li>构建项目<ul><li>构建是面向过程的，就是一些步骤，完成项目代码的编译，测试，运行，打包，部署等等</li><li>maven支持的构建包括有<ol><li>清理。把之前项目编译的东西删除掉，为新的编译代码做准备</li><li>编译。把程序源代码编译为执行代码，java-class文件<br>批量的，maven可 以同时把成千上百的文件编译为class.<br>javac不-一样，javac一次编译一个文件</li><li>测试。maven可 以执行测试程序代码，验证你的功能是否正确。<br>测试是批量的，maven同时执行多个测试代码，同时测试很多功能.</li><li>报告。生成测试结果的文件，测试通过没有</li><li>打包。把你的项目中所有的class文件，配置文件等所有资源放到一个压缩文件中，这个压缩文件就是项目的结果文件。通常 java程序，压缩文件是jar扩展名的。对于web应用，压缩文件扩展名是.war</li><li>安装。 把5中生成的文件jar, war安装到本机仓库</li><li>部署。把程序安装好可以执行</li></ol></li></ul></li></ul></li><li>使用方式<ol><li>独立使用maven：使用maven的各种命令，完成代码的编译，测试，打包等</li><li>结合开发工具使用：一般在idea中使用maven，简单、快捷、不需要记命令</li></ol></li></ol><h2 id="2、安装"><a href="#2、安装" class="headerlink" title="2、安装"></a>2、安装</h2><ol><li><p>从maven的官网下载maven的安装包apache- maven-3.3. 9-bin. zip</p></li><li><p>解压安装包，解压到一个目录，非中文目录</p><ul><li>bin：执行程序，主要是mvn. cmd</li><li>conf ：maven 工具本身的配置文件settings . xml</li></ul></li><li><p>配置环境变量</p><ol><li><p>在系统的环境变量中，指定一个<code>M2_HOME</code>的名称，它的值是maven工具安装目录，即bin之前的目录，如：</p><div class="hljs"><pre><code class="hljs angelscript">M2_HOMED:\ComputerSoftware\apache-maven<span class="hljs-number">-3.6</span><span class="hljs-number">.3</span></code></pre></div></li><li><p>把M2_ HOME加入到path之中。在所有路径之前加入<code>%M2_HOME%\bin;</code></p></li></ol></li><li><p>验证：cmd命令行中，执行<code>mvn -v</code></p><ul><li><p>注意：需要配置<code>JAVA HOME</code>，指定jdk路径</p></li><li><p>验证成功显示</p><div class="hljs"><pre><code class="hljs groovy"><span class="hljs-string">C:</span>\Users\<span class="hljs-number">15784</span>&gt;mvn -vApache Maven <span class="hljs-number">3.6</span><span class="hljs-number">.3</span> (cecedd343002696d0abb50b32b541b8a6ba2883f)Maven <span class="hljs-string">home:</span> <span class="hljs-string">D:</span>\ComputerSoftware\apache-maven<span class="hljs-number">-3.6</span><span class="hljs-number">.3</span>\bin\..Java <span class="hljs-string">version:</span> <span class="hljs-number">1.8</span><span class="hljs-number">.0</span>_251, <span class="hljs-string">vendor:</span> Oracle Corporation, <span class="hljs-string">runtime:</span> <span class="hljs-string">D:</span>\ComputerSoftware\Java\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0</span>_251\jreDefault <span class="hljs-string">locale:</span> zh_CN, platform <span class="hljs-string">encoding:</span> GBKOS <span class="hljs-string">name:</span> <span class="hljs-string">"windows 10"</span>, <span class="hljs-string">version:</span> <span class="hljs-string">"10.0"</span>, <span class="hljs-string">arch:</span> <span class="hljs-string">"amd64"</span>, <span class="hljs-string">family:</span> <span class="hljs-string">"windows"</span></code></pre></div></li></ul></li></ol><h1 id="二、核心概念"><a href="#二、核心概念" class="headerlink" title="二、核心概念"></a>二、核心概念</h1><ol><li>POM：一个文件，名称是pom.xml，pom翻译过来叫做项目对象模型。maven把一一个项目当做一个模型使用。控制maven构建项目的过程，管理jar依赖<ul><li>坐标：是一个唯一的字符串，用来表示资源的</li><li>依赖管理：管理你的项目可以使用jar文件</li></ul></li><li>约定的目录结构：maven项目的目录和文件的位置都是规定的</li><li>仓库管理(了解)：你的资源存放的位置</li><li>生命周期(了解)：maven工具构建项目的过程，就是生命周期</li><li>插件和目标(了解) ：执行maven构建的时候用的工具是插件</li><li>继承</li><li>聚合</li></ol><h2 id="1、约定的目录结构"><a href="#1、约定的目录结构" class="headerlink" title="1、约定的目录结构"></a>1、约定的目录结构</h2><p>每一个maven项目在磁盘中都是一个文件夹，如：项目Hello</p><div class="hljs"><pre><code class="hljs haml">Hello/    -<span class="ruby">---<span class="hljs-regexp">/src</span></span><span class="ruby">    --------<span class="hljs-regexp">/main   #放你主程序java代码和配置文件</span></span><span class="ruby">    -----------------<span class="hljs-regexp">/java   #你的程序包和包中的java文件</span></span><span class="ruby">    -----------------<span class="hljs-regexp">/resources   #你的java程序中要使用的配置文件</span></span><span class="ruby">    --------<span class="hljs-regexp">/test   #放测试程序代码和文件的(可以没有)</span></span><span class="ruby">    -----------------<span class="hljs-regexp">/java   #测试程序包和包中的java文件</span></span><span class="ruby">    -----------------<span class="hljs-regexp">/resources       #测试java程序中要使用的配置文件</span></span><span class="ruby">    ----<span class="hljs-regexp">/pom. xml   #maven的核心文件(maven项目必须有)</span></span></code></pre></div><h2 id="2、仓库"><a href="#2、仓库" class="headerlink" title="2、仓库"></a>2、仓库</h2><ol><li><p>手动创建一个maven工程</p><ul><li>创建好工程目录后，在cmd命令行中执行命令<code>mvn compile</code>会编译src/main目录下的所有java文件。编译前会下载一些jar文件（叫做插件，插件是完成某些功能），因为maven工具执行的操作需要很多插件( java类–jar文件)完成的。下载的东西存放到了默认仓库(本机仓库) ：C: \Users\ ( 登录操作系统的用户名) Adninistrator\ . m2\repository</li><li>执行<code>mvn compile</code> 结果是在项目的根目录下生成target目录(结果目录)，maven编译的java程序，最后的class文件都放在target目录中</li><li>自定义本机存放资源的目录位置<ol><li>修改maven的配置文件，maven安装目录/conf/settings . xml，先备份settings . xml</li><li>修改标签<code>&lt;localrepositoy&gt;</code>指定你的目录(不要使用中文目录)</li></ol></li></ul></li><li><p>概念</p><p>仓库是存放东西的，存放maven使用 的jar和我们项目使用的jar</p><ul><li>maven使用的插件( 各种jar)</li><li>我项目使用的jar(第三方的工具)</li></ul></li><li><p>分类</p><ul><li>本地仓库：就是你的个人计算机上的文件夹，存放各种jar</li><li>远程仓库：在互联网上的，使用网络才能使用的仓库<ol><li>中央仓库：最权威的，所有的开发人员都共享使用的一个集中的仓库,<br>中央仓库的地址： <a href="https://repo.maven.apache.org" target="_blank" rel="noopener">https://repo.maven.apache.org</a></li><li>中央仓库的镜像：就是中央仓库的备份，在各大洲， 重要的城市都是镜像</li><li>私服：在公司内部，在局域网中使用的，不是对外使用的</li></ol></li></ul></li><li><p>使用</p><ul><li>maven仓库的使用不需要人为参与，会自行进行下面的步骤</li><li>开发人员需要使用mysql驱动 —&gt; maven首先查本地仓库 —&gt; 私服 —&gt; 镜像 —&gt; 中央仓库</li></ul></li></ol><h2 id="3、POM文件"><a href="#3、POM文件" class="headerlink" title="3、POM文件"></a>3、POM文件</h2><ol><li><p>概念</p><p>Project Object Model项目对象模型。Maven 把一个项目的结构和内容抽象成一个模型 ，在xml文件中进行声明，以方便进行构建和描述，pom.xml是Maven的灵魂。所以，maven环境搭建好之后，所有的学习和操作都是关于pom.xml的</p></li><li><p>文件内容</p><ol><li><p>坐标（gav）</p><p>唯一值， 在互联网中唯一标识一个项目</p><ul><li>groupId：组织id，一般是公司域名的倒写。格式可以为:<ul><li>域名倒写。 例如com.baidu</li><li>域名倒写+项目名。例如com.baidu.appolo</li></ul></li><li>artifactId：项目名称，也是模块名称，对应groupId中项目中的子项目</li><li>version：项目的版本号。如果项目还在开发中，是不稳定版本，通常在版本后带-SNAPSHOT。version使用三位数字标识，例如1.1.0</li></ul><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>公司域名的倒写<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>自定义项目名称<span class="hljs-tag">&lt;/<span class="hljs-name">arti</span> <span class="hljs-attr">factId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>自定版本号<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span></code></pre></div></li><li><p>打包：packaging</p><p>项目打包的类型，可以使用jar、war、rar、ear、pom。默认是jar，web应用是war</p></li><li><p>依赖：dependencies和dependency</p><ul><li>相当于是java代码中import。例如，你的项目中要使用的各种资源说明，比我的项 目要使用mysql驱动</li></ul><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-comment">&lt;!--依赖java代码中 import --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysq1<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">arti</span> <span class="hljs-attr">factId</span>&gt;</span> mysq1 -connector- java<span class="hljs-tag">&lt;/<span class="hljs-name">arti</span> <span class="hljs-attr">factId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.9<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre></div><ul><li><p>依赖范围</p><p>scope的值有complie（默认）、test、provided，用以表示jar包等依赖的适用范围</p><ul><li>complie：编译，测试，打包，部署</li><li>test：测试</li><li>provided：编译，测试</li></ul></li></ul></li><li><p>属性：properties</p><ul><li><p>定义一些配置属性。例如：project.build.sourceEncoding (项目构建源码编码方式)，可以设置为UTF-8， 防止中文乱码，也可定义相关构建版本号，便于日后统一 升级</p></li><li><p>自定义属性</p><p>一般用于定义依赖的版本号</p><ol><li>在<code>&lt;properties&gt;</code>通过自定义标签声明变量（标签名就是变量名）</li><li>在pom.xml文件中的其他位置，使用<code>${标签名}</code>使用变量的值</li></ol></li></ul></li><li><p>构建：build</p><ul><li><p>maven在进行项目的构建时，配置信息，例如，指定编译java代码使用的jdk版本</p></li><li><p>资源插件</p><ol><li>默认没有使用resources的时候，maven执行编译代码时，会 把src/main/resources目录中的文件拷贝到target/classes目录中。对于src/main/java 目录下的非java文件不处理，不拷贝到target/classes目录中。</li><li>如果编译时，要将src/main/java 目录下的非java文件也拷贝到target/classes目录中，则可以在<code>&lt;build&gt;</code>中加入<code>&lt;resources&gt;</code></li></ol><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_08/09.png" srcset="/img/loading.gif" alt=""></p></li></ul></li></ol></li></ol><h2 id="4、生命周期"><a href="#4、生命周期" class="headerlink" title="4、生命周期"></a>4、生命周期</h2><p>maven生命周期：maven构建项目的过程，清理，编译，测试，报告，打包，安装，部署</p><h2 id="5、常用命令"><a href="#5、常用命令" class="headerlink" title="5、常用命令"></a>5、常用命令</h2><p>maven的命令：maven独立使用时，通过命令完成maven的生命周期的执行。maven可以使用命令，完成项目的清理，编译，测试等等</p><ol><li><p>单元测试</p><ul><li><p>用的是junit，junit是一个专门测试的框架(工具) 。junit测试的是类中的方法，每一个方法都是独立测试的。maven借助单元测试，批量的测试你类中的大量方法是否符合预期的</p></li><li><p>使用步骤</p><ol><li><p>加入依赖，在pom. xml加入单元测试依赖</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--单元测试--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactid</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.11<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div></li><li><p>在maven项目中的src/test/java目录下，创建测试程序。推荐的创建类和方法的提示：</p><ol><li>测试类的名称是Test +你要测试的类名</li><li>测试的方法名称是:Test+方法名称</li></ol></li></ol></li><li><p>举例</p><p>例如，你要测试的类是HelloMaven，则先创建测试类TestHelloMaven</p><div class="hljs"><pre><code class="hljs aspectj"><span class="hljs-meta">@Test</span><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testAdd</span><span class="hljs-params">()</span> </span>&#123;测试HelloMaven的add方法是否正确&#125;</code></pre></div><p>其中testAdd叫做测试方法，它的定义规则如下：</p><ol><li>方法是public的，必须的</li><li>方法没有返回值，必须的</li><li>方法名称是自定义的，推荐是Test +方法名称</li><li>在方法的上面加入<code>@Test</code></li></ol></li></ul></li><li><p>常用命令</p><p>以下命令要在pom.xml所在目录下执行</p><ul><li><code>mvn clean</code>清理<ul><li>作用：清理编译后的目录即target文件夹</li></ul></li><li><code>mvn complie</code>编译<ul><li>作用：只编译main目录，不编译test目录</li><li>结果：.class文件存放在target/classes目录中</li></ul></li><li><code>mvn test-complie</code>编译<ul><li>作用：只编译test目录，不编译main目录</li><li>结果：.class文件存放在target/test-classes目录中</li></ul></li><li><code>mvn test</code>测试<ul><li>作用：运行test目录进行测试</li><li>过程：编译测试、测试</li><li>结果：target/surefire-reports目录保存测试结果</li></ul></li><li><code>mvn package</code>打包<ul><li>作用：打包主程序</li><li>过程：编译、编译测试、测试、打包</li><li>结果：jar包（javase）或者war包（web）保存在target/<strong><em>artifactId+version</em></strong>  </li></ul></li><li><code>mvn install</code>安装<ul><li>作用：本地多个项目共用一个jar包</li><li>过程：编译、编译测试、测试、打包、安装</li><li>结果：包保存在本地仓库</li></ul></li></ul></li></ol><h2 id="6、插件"><a href="#6、插件" class="headerlink" title="6、插件"></a>6、插件</h2><p>maven的插件：maven命令执行时，真正完成功能的是插件，插件就是一些jar文件，一些类。在pom.xml文件中进行配置</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--build是控制配置maven构建项目的参数设置，设置jdk的版本--&gt;</span> .<span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 配置插件--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">p1ugins</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org . apache. maven. p1ugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-comment">&lt;!-- 插件的名称 --&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven- compiler-plugin<span class="hljs-tag">&lt; /<span class="hljs-attr">artifactId</span>&gt;</span>            <span class="hljs-comment">&lt;!-- 插件的版本 --&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.8.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>            <span class="hljs-comment">&lt;!-- 配置插件的信息 --&gt;</span>            <span class="hljs-tag">&lt; <span class="hljs-attr">configuration</span>&gt;</span>                <span class="hljs-comment">&lt;!-- 告诉maven我们的代码实在jdk1.8上编译的 --&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span>                <span class="hljs-comment">&lt;!-- 我们的程序应该运行在1.8的jdk上 --&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span>            <span class="hljs-tag">&lt;/ <span class="hljs-attr">configuration</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></code></pre></div><h1 id="三、在IDEA中的应用"><a href="#三、在IDEA中的应用" class="headerlink" title="三、在IDEA中的应用"></a>三、在IDEA中的应用</h1><h2 id="1、IDEA中设置Maven"><a href="#1、IDEA中设置Maven" class="headerlink" title="1、IDEA中设置Maven"></a>1、IDEA中设置Maven</h2><blockquote><p>idea中内置了maven，一 般不使用内置的，因为用内置修改maven的设置不方便<br>使用自己安装的maven，需要覆盖idea中的默认的设置，让idea指 定maven安装位置等信息</p></blockquote><ol><li><p>当前工程配置maven</p><p>点击菜单栏<code>File</code> — <code>Settings</code> — <code>Build, Excution , Deployment</code> — <code>Build Tools</code><br> — <code>Maven</code>，配置下面的内容：</p><ul><li>Maven Home directory: maven的安装目录</li><li>User settings File：maven安装目录下conf/setting.xml配置文件</li><li>Local Repository：本机仓库的目录位置</li></ul><p>然后点击Maven下的<code>Runner</code>，配置下面的内容：</p><ul><li>VM Options：-DarchetypeCatalog=internal</li><li>JRE：你项目的jdk</li></ul><blockquote><p>-DarchetypeCatalog=internal：</p><p>maven项目创建时，会联网下载模版文件，比较大，使用archetypeCatalog- internal，不用下载，创建maven项目速度快</p></blockquote></li><li><p>新建工程配置maven</p><p>点击菜单栏<code>File</code> — <code>New Projects Settings</code> — <code>Settings for New Projects</code> — <code>Build, Excution , Deployment</code> — <code>Build Tools</code>进行配置，配置内容和上述相同</p></li></ol><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_08/07.png" srcset="/img/loading.gif" alt=""></p><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_08/08.png" srcset="/img/loading.gif" alt=""></p><h2 id="2、IDEA使用模板创建项目"><a href="#2、IDEA使用模板创建项目" class="headerlink" title="2、IDEA使用模板创建项目"></a>2、IDEA使用模板创建项目</h2><ol><li><p>普通的java项目</p><ol><li><p>创建步骤</p><p>File —&gt; new module —&gt; maven项目 —&gt; <u>maven-archetype-quickstart</u> —&gt; 修改项目坐标（ 如果没有提前设置idea中新建项目的maven配置，则还需要设置maven的配置）</p></li><li><p>项目结构</p><div class="hljs"><pre><code class="hljs mipsasm">├─src│  ├─main│  │  ├─<span class="hljs-keyword">java</span><span class="hljs-keyword">│ </span> │  │  └─com│  │  │      └─<span class="hljs-keyword">bjpowernode</span><span class="hljs-keyword">│ </span> │  │              HelloMaven.<span class="hljs-keyword">java</span><span class="hljs-keyword">│ </span> │  │              │  │  └─resources│  └─test│      ├─<span class="hljs-keyword">java</span><span class="hljs-keyword">│ </span>     │  └─com│      │      └─<span class="hljs-keyword">bjpowernode</span><span class="hljs-keyword">│ </span>     │              TestHelloMaven.<span class="hljs-keyword">java</span><span class="hljs-keyword">│ </span>     │              │      └─resources└─target</code></pre></div></li></ol><ul><li>在cmd窗口中执行<code>tree /f &gt;目录.txt</code>可以将文件结构输出到本文件夹下的目录.txt中</li></ul></li><li><p>web工程</p><ol><li><p>创建步骤</p><p>File —&gt; new module —&gt; maven项目 —&gt; <u>maven-archetype-webapp</u> —&gt; 修改项目坐标（ 如果没有提前设置idea中新建项目的maven配置，则还需要设置maven的配置）</p></li><li><p>项目结构</p><div class="hljs"><pre><code class="hljs mipsasm">├─src│  ├─main│  │  ├─<span class="hljs-keyword">java</span><span class="hljs-keyword">│ </span> │  │  └─com│  │  │      └─<span class="hljs-keyword">bjpowernode</span><span class="hljs-keyword">│ </span> │  │          └─controller│  │  │                  HelloServlet.<span class="hljs-keyword">java</span><span class="hljs-keyword">│ </span> │  │                  │  │  ├─resources│  │  └─webapp│  │      │  index.<span class="hljs-keyword">jsp</span><span class="hljs-keyword">│ </span> │      │  main.<span class="hljs-keyword">jsp</span><span class="hljs-keyword">│ </span> │      │  │  │      └─WEB-INF│  │              web.xml│  │              │  └─test│      ├─<span class="hljs-keyword">java</span><span class="hljs-keyword">│ </span>     └─resources└─target</code></pre></div></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>Maven</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>redis/redis</title>
    <link href="/2020/08/09/redis/redis/"/>
    <url>/2020/08/09/redis/redis/</url>
    
    <content type="html"><![CDATA[<h1 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h1><ol><li>redis是一款高性能的NOSQL系列的非关系型数据库</li></ol><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_08/03.png" srcset="/img/loading.gif" alt=""></p><ol start="2"><li><p>什么是NOSQL</p><ul><li>NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库</li><li>随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题</li></ul></li><li><p>NOSQL和关系型数据库比较</p><ul><li><p>优点</p><ol><li>成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜</li><li>查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库</li><li>存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型</li><li>扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难</li></ol></li><li><p>缺点</p><ol><li>维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语</li><li>不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本</li><li>不提供关系型数据库对事务的处理</li></ol></li><li><p>非关系型数据库的优势</p><ol><li>性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高</li><li>可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展</li></ol></li><li><p>关系型数据库的优势</p><ol><li>复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询</li><li>事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然</li></ol></li><li><p>总结</p><p>关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候使用NoSQL数据库，让NoSQL数据库对关系型数据库的不足进行弥补。一般会将数据存储在关系型数据库中，在nosql数据库中备份存储关系型数据库的数据</p></li></ul></li><li><p>主流的NOSQL产品</p><ul><li>键值(Key-Value)存储数据库<ul><li>相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB</li><li>典型应用： 内容缓存，主要用于处理大量数据的高访问负载</li><li>数据模型： 一系列键值对</li><li>优势： 快速查询</li><li>劣势： 存储的数据缺少结构化</li></ul></li><li>列存储数据库<ul><li>相关产品：Cassandra, HBase, Riak</li><li>典型应用：分布式的文件系统</li><li>数据模型：以列簇式存储，将同一列数据存在一起</li><li>优势：查找速度快，可扩展性强，更容易进行分布式扩展</li><li>劣势：功能相对局限</li></ul></li><li>文档型数据库<ul><li>相关产品：CouchDB、MongoDB</li><li>典型应用：Web应用（与Key-Value类似，Value是结构化的）</li><li>数据模型： 一系列键值对</li><li>优势：数据结构要求不严格</li><li>劣势： 查询性能不高，而且缺乏统一的查询语法</li></ul></li><li>图形(Graph)数据库<ul><li>相关数据库：Neo4J、InfoGrid、Infinite Graph</li><li>典型应用：社交网络</li><li>数据模型：图结构</li><li>优势：利用图结构相关算法</li><li>劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案</li></ul></li></ul></li><li><p>什么是Redis</p><ul><li>Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下：<ul><li>字符串类型 string</li><li>哈希类型 hash</li><li>列表类型 list</li><li>集合类型 set</li><li>有序集合类型 sortedset</li></ul></li><li>redis的应用场景<ul><li>缓存（数据查询、短连接、新闻内容、商品内容等等）</li><li>聊天室的在线好友列表</li><li>任务队列。（秒杀、抢购、12306等等）</li><li>应用排行榜</li><li>网站访问统计</li><li>数据过期处理（可以精确到毫秒</li><li>分布式集群架构中的session分离</li></ul></li></ul></li></ol><h1 id="二、下载安装"><a href="#二、下载安装" class="headerlink" title="二、下载安装"></a>二、下载安装</h1><ol><li>官网：<a href="https://redis.io" target="_blank" rel="noopener">https://redis.io</a></li><li>中文网：<a href="http://www.redis.net.cn/" target="_blank" rel="noopener">http://www.redis.net.cn/</a></li><li>解压直接可以使用<ul><li>redis.windows.conf：配置文件</li><li>redis-cli.exe：redis的客户端</li><li>redis-server.exe：redis服务器端</li></ul></li></ol><h1 id="三、命令操作"><a href="#三、命令操作" class="headerlink" title="三、命令操作"></a>三、命令操作</h1><ol><li>redis的数据结构<ul><li>redis存储的是：key,value格式的数据，其中key都是字符串，value有5种不同的数据结构</li><li>value的数据结构<ol><li>字符串类型 string</li><li>哈希类型 hash ： map格式 </li><li>列表类型 list ： linkedlist格式。支持重复元素</li><li>集合类型 set  ： 不允许重复元素</li><li>有序集合类型 sortedset：不允许重复元素，且元素有顺序</li></ol></li></ul></li></ol><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_08/04.png" srcset="/img/loading.gif" alt=""></p><ol start="2"><li><p>字符串类型 string</p><ol><li><p>存储： <code>set key value</code></p><div class="hljs"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; set username zhangsanOK</code></pre></div></li><li><p>获取： <code>get key</code></p><div class="hljs"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; get username<span class="hljs-string">"zhangsan"</span></code></pre></div></li><li><p>删除： <code>del key</code></p><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; del age(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">1</span></code></pre></div></li></ol></li><li><p>哈希类型 hash</p><ol><li><p>存储： <code>hset key field value</code></p><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; hset myhash username lisi(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">1</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; hset myhash password <span class="hljs-number">123</span>(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">1</span></code></pre></div></li><li><p>获取</p><ul><li><p><code>hget key field</code></p><div class="hljs"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; hget myhash username<span class="hljs-string">"lisi"</span></code></pre></div></li><li><p><code>hgetall key</code></p><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; hgetall myhash<span class="hljs-number">1</span>) <span class="hljs-string">"username"</span><span class="hljs-number">2</span>) <span class="hljs-string">"lisi"</span><span class="hljs-number">3</span>) <span class="hljs-string">"password"</span><span class="hljs-number">4</span>) <span class="hljs-string">"123"</span></code></pre></div></li></ul></li><li><p>删除：<code>hdel key field</code></p><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; hdel myhash username(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">1</span></code></pre></div></li></ol></li><li><p>列表类型 list:可以添加一个元素到列表的头部（左边）或者尾部（右边）</p><ol><li><p>添加</p><ol><li><p><code>lpush key value</code>: 将元素加入列表左表</p></li><li><p><code>rpush key value</code>：将元素加入列表右边</p>  <div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lpush myList a(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">1</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; lpush myList b(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">2</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; rpush myList c(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">3</span></code></pre></div></li></ol></li><li><p>获取：<code>lrange key start end</code> ：范围获取</p><div class="hljs"><pre><code class="hljs tcl"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; <span class="hljs-keyword">lrange</span> myList <span class="hljs-number">0</span> <span class="hljs-number">-1</span><span class="hljs-number">1</span>) <span class="hljs-string">"b"</span><span class="hljs-number">2</span>) <span class="hljs-string">"a"</span><span class="hljs-number">3</span>) <span class="hljs-string">"c"</span></code></pre></div></li><li><p>删除</p><ul><li><code>lpop key</code>： 删除列表最左边的元素，并将元素返回</li><li><code>rpop key</code>： 删除列表最右边的元素，并将元素返回</li></ul></li></ol></li></ol><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_08/05.png" srcset="/img/loading.gif" alt=""></p><ol start="5"><li><p>集合类型 set ： 不允许重复元素</p><ol><li><p>存储：<code>sadd key value</code></p><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; sadd myset a(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">1</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; sadd myset a(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">0</span></code></pre></div></li><li><p>获取：<code>smembers key</code>获取set集合中所有元素</p><div class="hljs"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; smembers myset<span class="hljs-number">1</span>) <span class="hljs-string">"a"</span></code></pre></div></li><li><p>删除：<code>srem key value</code>删除set集合中的某个元素    </p><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; srem myset a(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">1</span></code></pre></div></li></ol></li><li><p>有序集合类型 sortedset：不允许重复元素，且元素有顺序.每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序</p><ol><li><p>存储：<code>zadd key score value</code></p><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zadd mysort <span class="hljs-number">60</span> zhangsan(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">1</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zadd mysort <span class="hljs-number">50</span> lisi(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">1</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zadd mysort <span class="hljs-number">80</span> wangwu(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">1</span></code></pre></div></li><li><p>获取：<code>zrange key start end [withscores]</code></p><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zrange mysort <span class="hljs-number">0</span> <span class="hljs-number">-1</span><span class="hljs-number">1</span>) <span class="hljs-string">"lisi"</span><span class="hljs-number">2</span>) <span class="hljs-string">"zhangsan"</span><span class="hljs-number">3</span>) <span class="hljs-string">"wangwu"</span><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zrange mysort <span class="hljs-number">0</span> <span class="hljs-number">-1</span> withscores<span class="hljs-number">1</span>) <span class="hljs-string">"zhangsan"</span><span class="hljs-number">2</span>) <span class="hljs-string">"60"</span><span class="hljs-number">3</span>) <span class="hljs-string">"wangwu"</span><span class="hljs-number">4</span>) <span class="hljs-string">"80"</span><span class="hljs-number">5</span>) <span class="hljs-string">"lisi"</span><span class="hljs-number">6</span>) <span class="hljs-string">"500"</span></code></pre></div></li><li><p>删除：<code>zrem key value</code></p><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; zrem mysort lisi(<span class="hljs-built_in">int</span>eger) <span class="hljs-number">1</span></code></pre></div></li></ol></li><li><p>通用命令</p><ol><li><code>keys *</code> : 查询所有的键</li><li><code>type key</code>： 获取键对应的value的类型</li><li><code>del key</code>：删除指定的key value</li></ol></li></ol><h1 id="四、持久化"><a href="#四、持久化" class="headerlink" title="四、持久化"></a>四、持久化</h1><ol><li><p>redis是一个内存数据库，当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中</p></li><li><p>redis持久化机制</p><ol><li><p>RDB：默认方式，不需要进行配置，默认就使用这种机制。在一定的间隔时间中，检测key的变化情况，然后持久化数据</p><ol><li><p>编辑redis.windwos.conf文件</p><div class="hljs"><pre><code class="hljs lsl">#   after <span class="hljs-number">900</span> sec (<span class="hljs-number">15</span> min) if at least <span class="hljs-number">1</span> <span class="hljs-type">key</span> <span class="hljs-section">changed</span>save <span class="hljs-number">900</span> <span class="hljs-number">1</span>#   after <span class="hljs-number">300</span> sec (<span class="hljs-number">5</span> min) if at least <span class="hljs-number">10</span> keys <span class="hljs-section">changed</span>save <span class="hljs-number">300</span> <span class="hljs-number">10</span>#   after <span class="hljs-number">60</span> sec if at least <span class="hljs-number">10000</span> keys <span class="hljs-section">changed</span>save <span class="hljs-number">60</span> <span class="hljs-number">10000</span></code></pre></div></li><li><p>重新启动redis服务器，并且在cmd指定配置文件名称D:\JavaWeb2018\day23_redis\资料\redis\windows-64\redis-2.8.9&gt;redis-server.exe redis.windows.conf    </p></li></ol></li><li><p>AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据</p><ol><li><p>编辑redis.windwos.conf文件</p><p>首先，appendonly no（关闭AOF） –&gt; appendonly yes （开启AOF）</p><div class="hljs"><pre><code class="hljs vala"><span class="hljs-meta"># appendfsync always ： 每一次操作都进行持久化</span>appendfsync everysec ： 每隔一秒进行一次持久化<span class="hljs-meta"># appendfsync no ： 不进行持久化</span></code></pre></div></li><li><p>重新启动redis服务器，并且在cmd指定配置文件名称</p></li></ol></li></ol></li></ol><h1 id="五、Jedis"><a href="#五、Jedis" class="headerlink" title="五、Jedis"></a>五、Jedis</h1><ol><li><p>Jedis: 一款java操作redis数据库的工具</p></li><li><p>使用步骤</p><ol><li><p>下载jedis的jar包</p></li><li><p>使用</p><ul><li>快速入门</li></ul><div class="hljs"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">//1.获取连接</span>    Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">"localhost"</span>,<span class="hljs-number">6379</span>);    <span class="hljs-comment">//2.操作0</span>    jedis.<span class="hljs-built_in">set</span>(<span class="hljs-string">"username"</span>,<span class="hljs-string">"zhangsan"</span>);    <span class="hljs-comment">//3.关闭连接</span>    jedis.<span class="hljs-built_in">close</span>();&#125;</code></pre></div></li></ol></li><li><p>Jedis操作各种redis中的数据结构</p><ol><li><p>字符串类型 string</p><ul><li>set</li><li>get</li></ul><div class="hljs"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">//1.获取连接</span>    Jedis jedis = <span class="hljs-keyword">new</span> Jedis(); <span class="hljs-comment">//如果使用空参构造，默认值 "localhost",6379端口</span>    <span class="hljs-comment">//2.操作</span>    <span class="hljs-comment">//存储</span>    jedis.<span class="hljs-built_in">set</span>(<span class="hljs-string">"username"</span>,<span class="hljs-string">"zhangsan"</span>);    <span class="hljs-comment">//获取</span>    <span class="hljs-keyword">String</span> username = jedis.<span class="hljs-built_in">get</span>(<span class="hljs-string">"username"</span>);    System.out.<span class="hljs-built_in">println</span>(username);          <span class="hljs-comment">//可以使用setex()方法存储可以指定过期时间的 key value</span>    jedis.setex(<span class="hljs-string">"activecode"</span>,<span class="hljs-number">20</span>,<span class="hljs-string">"hehe"</span>);    <span class="hljs-comment">//3.关闭连接</span>    jedis.<span class="hljs-built_in">close</span>();&#125;</code></pre></div></li><li><p>哈希类型 hash ： map格式 </p><ul><li>hset</li><li>hget</li><li>hgetAll</li></ul><div class="hljs"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> test03()&#123;    <span class="hljs-comment">//1.获取连接</span>    Jedis jedis = <span class="hljs-keyword">new</span> Jedis(); <span class="hljs-comment">//如果使用空参构造，默认值 "localhost",6379端口</span>    <span class="hljs-comment">//2.操作</span>    <span class="hljs-comment">//存储hash</span>    jedis.hset(<span class="hljs-string">"user"</span>,<span class="hljs-string">"name"</span>,<span class="hljs-string">"lisi"</span>);    jedis.hset(<span class="hljs-string">"user"</span>,<span class="hljs-string">"age"</span>,<span class="hljs-string">"24"</span>);    jedis.hset(<span class="hljs-string">"user"</span>,<span class="hljs-string">"gender"</span>,<span class="hljs-string">"male"</span>);    <span class="hljs-comment">//获取hash</span>    <span class="hljs-keyword">String</span> name = jedis.hget(<span class="hljs-string">"user"</span>,<span class="hljs-string">"name"</span>);    System.out.<span class="hljs-built_in">println</span>(name);    <span class="hljs-comment">//获取hash的所有map中的数据</span>    Map&lt;<span class="hljs-keyword">String</span> ,<span class="hljs-keyword">String</span>&gt; user = jedis.hgetAll(<span class="hljs-string">"user"</span>);    <span class="hljs-comment">//keyset</span>    Set&lt;<span class="hljs-keyword">String</span>&gt; keyset = user.keySet();    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">String</span> <span class="hljs-built_in">key</span> : keyset)&#123;        <span class="hljs-comment">//获取value</span>        <span class="hljs-keyword">String</span> value = user.<span class="hljs-built_in">get</span>(<span class="hljs-built_in">key</span>);        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">key</span> + <span class="hljs-string">":"</span> + value);    &#125;          <span class="hljs-comment">//3.关闭连接</span>    jedis.close();&#125;</code></pre></div></li><li><p>列表类型 list ： linkedlist格式。支持重复元素</p><ul><li>lpush / rpush</li><li>lpop / rpop</li><li>lrange start end : 范围获取</li></ul><div class="hljs"><pre><code class="hljs tcl">public void test04()&#123;    //<span class="hljs-number">1.</span>获取连接    Jedis jedis = new Jedis(); //如果使用空参构造，默认值 <span class="hljs-string">"localhost"</span>,<span class="hljs-number">6379</span>端口    //<span class="hljs-number">2.</span>操作    //存储<span class="hljs-keyword">list</span>    jedis.lpush(<span class="hljs-string">"mylist"</span>,<span class="hljs-string">"a"</span>,<span class="hljs-string">"b"</span>,<span class="hljs-string">"c"</span>); //从左边存    jedis.rpush(<span class="hljs-string">"mylist"</span>,<span class="hljs-string">"a"</span>,<span class="hljs-string">"b"</span>,<span class="hljs-string">"c"</span>); //从右边存    //List范围获取    List&lt;String&gt; mylist = jedis.<span class="hljs-keyword">lrange</span>(<span class="hljs-string">"mylist"</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>);    System.out.println(mylist);    //<span class="hljs-keyword">list</span>弹出    String element1 = jedis.lpop(<span class="hljs-string">"mylist"</span>);    System.out.println(element1);    String element2 = jedis.rpop(<span class="hljs-string">"mylist"</span>);    System.out.println(element2);          List&lt;String&gt; mylist2 = jedis.<span class="hljs-keyword">lrange</span>(<span class="hljs-string">"mylist"</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>);    System.out.println(mylist2);          //<span class="hljs-number">3.</span>关闭连接    jedis.<span class="hljs-keyword">close</span>();&#125;</code></pre></div></li><li><p>集合类型 set  ： 不允许重复元素</p><ul><li>sadd</li><li>smembers:获取所有元素</li></ul><div class="hljs"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test05</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">//1.获取连接</span>    Jedis jedis = <span class="hljs-keyword">new</span> Jedis(); <span class="hljs-comment">//如果使用空参构造，默认值 "localhost",6379端口</span>    <span class="hljs-comment">//2.操作</span>    <span class="hljs-comment">//存储set</span>    jedis.sadd(<span class="hljs-string">"myset"</span>,<span class="hljs-string">"java"</span>,<span class="hljs-string">"php"</span>,<span class="hljs-string">"c++"</span>);    Set&lt;<span class="hljs-keyword">String</span>&gt; myset = jedis.smembers(<span class="hljs-string">"myset"</span>);    System.out.<span class="hljs-built_in">println</span>(myset);                <span class="hljs-comment">//3.关闭连接</span>    jedis.<span class="hljs-built_in">close</span>();&#125;</code></pre></div></li><li><p>有序集合类型 sortedset：不允许重复元素，且元素有顺序</p><ul><li>zadd</li><li>zrange</li></ul><div class="hljs"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test06</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">//1.获取连接</span>    Jedis jedis = <span class="hljs-keyword">new</span> Jedis(); <span class="hljs-comment">//如果使用空参构造，默认值 "localhost",6379端口</span>    <span class="hljs-comment">//2.操作</span>    jedis.zadd(<span class="hljs-string">"mysortedset"</span>,<span class="hljs-number">20</span>,<span class="hljs-string">"孙悟空"</span>);    jedis.zadd(<span class="hljs-string">"mysortedset"</span>,<span class="hljs-number">15</span>,<span class="hljs-string">"猪八戒"</span>);    jedis.zadd(<span class="hljs-string">"mysortedset"</span>,<span class="hljs-number">18</span>,<span class="hljs-string">"沙悟净"</span>);          Set&lt;<span class="hljs-keyword">String</span>&gt; mysortedset = jedis.zrange(<span class="hljs-string">"mysortedset"</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>);    System.out.<span class="hljs-built_in">println</span>(mysortedset);                <span class="hljs-comment">//3.关闭连接</span>    jedis.<span class="hljs-built_in">close</span>();&#125;</code></pre></div></li></ol></li><li><p>Jedis连接池：JedisPool</p><ul><li>使用<ol><li>创建JedisPool连接池对象</li><li>调用方法 getResource()方法获取Jedis连接</li></ol></li><li>实现</li></ul><div class="hljs"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test07</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">//0.创建一个配置对象</span>    JedisPoolConfig <span class="hljs-built_in">config</span> = <span class="hljs-keyword">new</span> JedisPoolConfig();    <span class="hljs-built_in">config</span>.setMaxTotal(<span class="hljs-number">50</span>);    <span class="hljs-built_in">config</span>.setMaxIdle(<span class="hljs-number">10</span>);       <span class="hljs-comment">//1.创建Jedis连接池对象</span>    JedisPool jedisPool = <span class="hljs-keyword">new</span> JedisPool();    <span class="hljs-comment">//2.获取连接</span>    Jedis jedis = jedisPool.getResource();    <span class="hljs-comment">//3.使用</span>    jedis.<span class="hljs-built_in">set</span>(<span class="hljs-string">"hehe"</span>,<span class="hljs-string">"hihi"</span>);    <span class="hljs-comment">//4.关闭 归还到连接池中</span>    jedis.<span class="hljs-built_in">close</span>();&#125;</code></pre></div><ul><li>连接池工具类</li></ul><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * JedisPool工具类</span><span class="hljs-comment"> * 加载配置文件，配置连接池的参数</span><span class="hljs-comment"> * 提供获取连接的方法</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JedisPoolUtils</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> JedisPool jedisPool;    <span class="hljs-keyword">static</span> &#123;                <span class="hljs-comment">//读取配置文件</span>        InputStream is = JedisPoolUtils<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getClassLoader</span>()</span>                .getResourceAsStream("jedis.properties");                <span class="hljs-comment">//创建Properties对象</span>        Properties pro = <span class="hljs-keyword">new</span> Properties();                <span class="hljs-comment">//关联文件</span>        <span class="hljs-keyword">try</span> &#123;            pro.load(is);        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;                <span class="hljs-comment">//获取数据，设置到JedisPoolConfig中</span>        JedisPoolConfig config = <span class="hljs-keyword">new</span> JedisPoolConfig();        config.setMaxTotal(Integer.parseInt(pro.getProperty(<span class="hljs-string">"maxTotal"</span>)));        config.setMaxIdle(Integer.parseInt(pro.getProperty(<span class="hljs-string">"maxIdle"</span>)));                <span class="hljs-comment">//初始化JedisPool</span>        jedisPool = <span class="hljs-keyword">new</span> JedisPool           (config,pro.getProperty(<span class="hljs-string">"host"</span>), Integer.parseInt(pro.getProperty(<span class="hljs-string">"port"</span>)));    &#125;        <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取连接方法</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Jedis <span class="hljs-title">getJedis</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> jedisPool.getResource();    &#125;&#125;</code></pre></div></li></ol><h1 id="六、案例"><a href="#六、案例" class="headerlink" title="六、案例"></a>六、案例</h1><p>案例需求</p><ol><li>提供index.html页面，页面中有一个省份 下拉列表</li><li>当 页面加载完成后 发送ajax请求，加载所有省份</li></ol><ul><li>注意：使用redis缓存一些不经常发生变化的数据。<ul><li>数据库的数据一旦发生改变，则需要更新缓存<ul><li>数据库的表执行 增删改的相关操作，需要将redis缓存数据情况，再次存入</li><li>在service对应的增删改方法中，将redis数据删除。</li></ul></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_08/06.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>redis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>AJAX/AJAX</title>
    <link href="/2020/08/04/AJAX/AJAX/"/>
    <url>/2020/08/04/AJAX/AJAX/</url>
    
    <content type="html"><![CDATA[<h1 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h1><ol><li><p>ASynchronous JavaScript And XML   异步的JavaScript 和 XML</p><ul><li>异步和同步：客户端和服务器端相互通信的基础上<ul><li>同步：客户端必须等待服务器端的响应。在等待的期间客户端不能做其他操作</li><li>异步：客户端不需要等待服务器端的响应。在服务器处理请求的过程中，客户端可以进行其他的操作</li></ul></li></ul></li></ol><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_08/01.png" srcset="/img/loading.gif" alt=""></p><ol start="2"><li>特点<ul><li>Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术</li><li>通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新</li><li>传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面</li></ul></li><li>目的：提升用户体验</li></ol><h1 id="二、实现方式"><a href="#二、实现方式" class="headerlink" title="二、实现方式"></a>二、实现方式</h1><ol><li>原生的JS实现方式（了解）</li></ol><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//1.创建核心对象</span>            <span class="hljs-keyword">var</span> xmlhttp;            <span class="hljs-keyword">if</span> (window.XMLHttpRequest)            &#123;<span class="hljs-comment">// code for IE7+, Firefox, Chrome, Opera, Safari</span>                xmlhttp=<span class="hljs-keyword">new</span> XMLHttpRequest();            &#125;            <span class="hljs-keyword">else</span>            &#123;<span class="hljs-comment">// code for IE6, IE5</span>                xmlhttp=<span class="hljs-keyword">new</span> ActiveXObject(<span class="hljs-string">"Microsoft.XMLHTTP"</span>);            &#125;<span class="hljs-comment">//2. 建立连接</span><span class="hljs-comment">/*</span><span class="hljs-comment">参数：</span><span class="hljs-comment">1. 请求方式：GET、POST</span><span class="hljs-comment">* get方式，请求参数在URL后边拼接。send方法为空参</span><span class="hljs-comment">* post方式，请求参数在send方法中定义</span><span class="hljs-comment">2. 请求的URL：</span><span class="hljs-comment">3. 同步或异步请求：true（异步）或 false（同步）</span><span class="hljs-comment"> */</span>             xmlhttp.open(<span class="hljs-string">"GET"</span>,<span class="hljs-string">"ajaxServlet?username=tom"</span>,<span class="hljs-keyword">true</span>);<span class="hljs-comment">//3.发送请求</span>            xmlhttp.send();<span class="hljs-comment">//4.接受并处理来自服务器的响应结果</span>            <span class="hljs-comment">//获取方式 ：xmlhttp.responseText</span>            <span class="hljs-comment">//什么时候获取？当服务器响应成功后再获取</span>            <span class="hljs-comment">//当xmlhttp对象的就绪状态改变时，触发事件onreadystatechange。</span>            xmlhttp.onreadystatechange=function()            &#123;                <span class="hljs-comment">//判断readyState就绪状态是否为4，判断status响应状态码是否为200</span>                <span class="hljs-keyword">if</span> (xmlhttp.readyState==<span class="hljs-number">4</span> &amp;&amp; xmlhttp.status==<span class="hljs-number">200</span>)                &#123;                   <span class="hljs-comment">//获取服务器的响应结果</span>                    <span class="hljs-keyword">var</span> responseText = xmlhttp.responseText;                    alert(responseText);                &#125;            &#125;</code></pre></div><ol start="2"><li><p>JQeury实现方式</p><ol><li><p>$.ajax()</p><ul><li>语法：<code>$.ajax({键值对});</code></li><li>代码</li></ul><div class="hljs"><pre><code class="hljs ajax">&#x2F;&#x2F;使用$.ajax()发送异步请求         $.ajax(&#123;             url:&quot;ajaxServlet1111&quot; , &#x2F;&#x2F; 请求路径             type:&quot;POST&quot; , &#x2F;&#x2F;请求方式             &#x2F;&#x2F;data: &quot;username&#x3D;jack&amp;age&#x3D;23&quot;,&#x2F;&#x2F;请求参数             data:&#123;&quot;username&quot;:&quot;jack&quot;,&quot;age&quot;:23&#125;,             success:function (data) &#123;                 alert(data);             &#125;,&#x2F;&#x2F;响应成功后的回调函数             error:function () &#123;                 alert(&quot;出错啦...&quot;)             &#125;,&#x2F;&#x2F;表示如果请求响应出现错误，会执行的回调函数                   dataType:&quot;text&quot;&#x2F;&#x2F;设置接受到的响应数据的格式         &#125;);</code></pre></div></li><li><p>$.get()：发送get请求</p><ul><li>语法：<code>$.get(url, [data], [callback], [type])</code></li><li>参数<ul><li>url：请求路径</li><li>data：请求参数</li><li>callback：回调函数</li><li>type：响应结果的类型</li></ul></li></ul></li><li><p>$.post()：发送post请求</p><ul><li><p>语法：$.post(url, [data], [callback], [type])</p></li><li><p>参数</p><ul><li>url：请求路径</li><li>data：请求参数</li><li>callback：回调函数</li><li>type：响应结果的类型</li></ul></li></ul></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>AJAX</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JSON/JSON</title>
    <link href="/2020/08/04/JSON/JSON/"/>
    <url>/2020/08/04/JSON/JSON/</url>
    
    <content type="html"><![CDATA[<h1 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h1><ol><li>JavaScript Object Notation        JavaScript对象表示法</li></ol><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//java</span>Person p = <span class="hljs-keyword">new</span> Person();p.setName(<span class="hljs-string">"张三"</span>);p.setAge(<span class="hljs-number">23</span>);p.setGender(<span class="hljs-string">"男"</span>);<span class="hljs-comment">//JSON</span><span class="hljs-keyword">var</span> p = &#123;<span class="hljs-string">"name"</span>:<span class="hljs-string">"张三"</span>,<span class="hljs-string">"age"</span>:<span class="hljs-number">23</span>,<span class="hljs-string">"gender"</span>:<span class="hljs-string">"男"</span>&#125;;</code></pre></div><ul><li>json现在多用于存储和交换文本信息的语法</li><li>进行数据的传输</li><li>JSON 比 XML 更小、更快，更易解析</li></ul><h1 id="二、语法"><a href="#二、语法" class="headerlink" title="二、语法"></a>二、语法</h1><ol><li>基本规则<ul><li>数据在名称/值对中：json数据是由键值对构成的<ul><li>键用引号(单双都行)引起来，也可以不使用引号</li><li>值的取值类型<ol><li>数字（整数或浮点数）</li><li>字符串（在双引号中）</li><li>逻辑值（true 或 false）</li><li>数组（在方括号中）如：{“persons”:[{},{}]}</li><li>对象（在花括号中），如：{“address”:{“province”：”陕西”….}}</li><li>null</li></ol></li></ul></li></ul></li><li>获取数据<ol><li>json对象.键名</li><li>json对象[“键名”]</li><li>数组对象[索引]</li><li>遍历</li></ol></li></ol><div class="hljs"><pre><code class="hljs q"><span class="hljs-built_in">var</span> person = &#123;<span class="hljs-string">"name"</span>: <span class="hljs-string">"张三"</span>, age: <span class="hljs-number">23</span>, 'gender': true&#125;;<span class="hljs-built_in">var</span> ps = [&#123;<span class="hljs-string">"name"</span>: <span class="hljs-string">"张三"</span>, <span class="hljs-string">"age"</span>: <span class="hljs-number">23</span>, <span class="hljs-string">"gender"</span>: true&#125;,          &#123;<span class="hljs-string">"name"</span>: <span class="hljs-string">"李四"</span>, <span class="hljs-string">"age"</span>: <span class="hljs-number">24</span>, <span class="hljs-string">"gender"</span>: true&#125;,          &#123;<span class="hljs-string">"name"</span>: <span class="hljs-string">"王五"</span>, <span class="hljs-string">"age"</span>: <span class="hljs-number">25</span>, <span class="hljs-string">"gender"</span>: false&#125;];<span class="hljs-comment">//获取person对象中所有的键和值</span><span class="hljs-comment">//for in 循环</span>/* for(<span class="hljs-built_in">var</span> <span class="hljs-built_in">key</span> in person)&#123;    <span class="hljs-comment">//这样的方式获取不行。因为相当于  person."name"</span>    <span class="hljs-comment">//alert(key + ":" + person.key);</span>    alert(<span class="hljs-built_in">key</span>+<span class="hljs-string">":"</span>+person[<span class="hljs-built_in">key</span>]);&#125;*/<span class="hljs-comment">//获取ps中的所有值</span>for (<span class="hljs-built_in">var</span> i = <span class="hljs-number">0</span>; i &lt; ps.length; i++) &#123;<span class="hljs-built_in">var</span> p = ps[i];    for(<span class="hljs-built_in">var</span> <span class="hljs-built_in">key</span> in p)&#123;        alert(<span class="hljs-built_in">key</span>+<span class="hljs-string">":"</span>+p[<span class="hljs-built_in">key</span>]);    &#125;&#125;</code></pre></div><h1 id="三、JSON数据和Java对象的相互转换"><a href="#三、JSON数据和Java对象的相互转换" class="headerlink" title="三、JSON数据和Java对象的相互转换"></a>三、JSON数据和Java对象的相互转换</h1><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_08/02.png" srcset="/img/loading.gif" alt=""></p><ul><li>JSON解析器<ul><li>常见的解析器：Jsonlib，Gson，fastjson，jackson</li></ul></li></ul><ol><li><p>Java对象转换JSON</p><ol><li><p>使用步骤</p><ol><li>导入jackson的相关jar包</li><li>创建Jackson核心对象 ObjectMapper</li><li>调用ObjectMapper的相关方法进行转换</li></ol></li><li><p>转换方法</p><ol><li><p><code>writeValue(参数1，obj)</code></p><p>参数1： </p><ul><li>File：将obj对象转换为JSON字符串，并保存到指定的文件中</li><li>Writer：将obj对象转换为JSON字符串，并将json数据填充到字符输出流中</li><li>OutputStream：将obj对象转换为JSON字符串，并将json数据填充到字节输出流中</li></ul></li><li><p><code>writeValueAsString(obj)</code>:将对象转为json字符串</p></li></ol></li><li><p>注解</p><ol><li><code>@JsonIgnore</code>：排除属性</li><li><code>@JsonFormat</code>：属性值的格式化<ul><li>@JsonFormat(pattern = “yyyy-MM-dd”)</li></ul></li></ol></li><li><p>复杂java对象转换</p><ol><li>List：数组</li><li>Map：对象格式一致</li></ol></li></ol></li><li><p>JSON转为Java对象</p><ol><li>导入jackson的相关jar包</li><li>创建Jackson核心对象 ObjectMapper</li><li>调用ObjectMapper的相关方法进行转换<ul><li><code>readValue(json字符串数据,Class)</code></li></ul></li></ol></li></ol><h1 id="四、案例：校验用户名是否存在"><a href="#四、案例：校验用户名是否存在" class="headerlink" title="四、案例：校验用户名是否存在"></a>四、案例：校验用户名是否存在</h1>]]></content>
    
    
    <categories>
      
      <category>JSON</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>兔酱碎碎念/想考研了</title>
    <link href="/2020/08/02/%E5%85%94%E9%85%B1%E7%A2%8E%E7%A2%8E%E5%BF%B5/%E6%83%B3%E8%80%83%E7%A0%94%E4%BA%86/"/>
    <url>/2020/08/02/%E5%85%94%E9%85%B1%E7%A2%8E%E7%A2%8E%E5%BF%B5/%E6%83%B3%E8%80%83%E7%A0%94%E4%BA%86/</url>
    
    <content type="html"><![CDATA[<h1 id="想考研了"><a href="#想考研了" class="headerlink" title="想考研了"></a>想考研了</h1><p>最近突然间很羡慕考上名校的人</p><p>想一想，自己从小到大，一直都是有什么知识，学就好了，没有过自己的目标。比如，大学想要考去哪里从来没有想过，那种感觉就像是，能考去哪里就去哪里</p><p>最近看到了很多考研上岸的人</p><p>羡慕某涛本科在郑州大学，考研考去了太理</p><p>18年高考，分数差了一本线五分，只能报一个二本A类院校</p><p>而现在有第二次实现梦想的机会，那就是考研，去一个更好的、更满意的大学</p><h1 id="练车"><a href="#练车" class="headerlink" title="练车"></a>练车</h1><p>自从24号科一结束，这一周几乎一直是一整天都待在驾校练习五个考试项目</p><p>每天都很累，回家以后挨着枕头就可以秒睡。所以下午四点左右回家以后，有时候都会睡着。但是，我本来是一个午睡压根睡不着的人呐~</p><p>熬夜也是不存在的。每天十点多就开始犯困睡觉了。但是每天的健身房打卡还在坚持。</p><p>8号要考科二了，结果只允许考过 []~ (￣▽￣) ~*</p><p>已经连续四天没有学习Javaweb了</p><p>其实好像练车有点过火了捏QWQ…从明天开始，补考的也要去和我们一起轮着练习项目了，车更难轮到了</p><p>其次，再练习练习项目细节就好，所以打算给自己也轻松一点，早晨起早去练车。所以，明天早上六点半左右去驾校。</p><p>先这样吧，(ง •_•)ง加油❤</p>]]></content>
    
    
    <categories>
      
      <category>鱼酱碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DataStructureAndAlgorithm/LeetCode-链表</title>
    <link href="/2020/07/29/DataStructureAndAlgorithm/LeetCode-%E9%93%BE%E8%A1%A8/"/>
    <url>/2020/07/29/DataStructureAndAlgorithm/LeetCode-%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160.相交链表"></a>160.相交链表</h1><ol><li>题目<ul><li>找到两个单链表相交的起始节点</li><li><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">160.相交链表</a></li></ul></li></ol><ol start="2"><li><p>思路</p><ul><li>lenA+lenB’ = lenB + lenA’</li></ul><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_07/39.png" srcset="/img/loading.gif" alt=""></p><ul><li>每一次循环、整个过程如下</li></ul><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_07/40.png" srcset="/img/loading.gif" alt=""></p></li><li><p>代码</p></li></ol><div class="hljs"><pre><code class="hljs c"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * struct ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     struct ListNode *next;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-function">struct ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(struct ListNode *headA, struct ListNode *headB)</span> </span>&#123;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">L1</span> = <span class="hljs-title">headA</span>, *<span class="hljs-title">L2</span>= <span class="hljs-title">headB</span>;</span>    <span class="hljs-keyword">while</span>(L1 != L2)    &#123;        L1 = ((L1 == <span class="hljs-literal">NULL</span>) ? headB : L1-&gt;next);        L2 = ((L2 == <span class="hljs-literal">NULL</span>) ? headA : L2-&gt;next);    &#125;    <span class="hljs-keyword">return</span> L1;&#125;</code></pre></div><h1 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h1><ol><li><p>题目</p><ul><li>反转一个单链表</li><li><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">206.反转链表</a></li></ul></li><li><p>代码</p></li></ol><div class="hljs"><pre><code class="hljs c"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * struct ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     struct ListNode *next;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-function">struct ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(struct ListNode* head)</span></span>&#123;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">p</span>, *<span class="hljs-title">pre</span> = <span class="hljs-title">NULL</span>;</span>    <span class="hljs-keyword">while</span>(head)    &#123;        p = head-&gt;next;        head-&gt;next = pre;        pre = head;        head = p;    &#125;    <span class="hljs-keyword">return</span> pre;&#125;</code></pre></div><ol start="3"><li><p>思路</p><ul><li>前两次循环结果如下</li></ul><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_07/42.png" srcset="/img/loading.gif" alt=""></p><ul><li>前两次循环总图如下</li></ul><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_07/41.png" srcset="/img/loading.gif" alt=""></p></li></ol><h1 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21.合并两个有序链表"></a>21.合并两个有序链表</h1><ol><li>题目<ul><li>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</li><li><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">21.合并两个有序链表</a></li></ul></li><li>代码</li></ol><div class="hljs"><pre><code class="hljs rust"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * struct ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     struct ListNode *next;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span></span>* mergeTwoLists(<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span></span>* l1, <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span></span>* l2)&#123;    <span class="hljs-keyword">if</span> (!l1)<span class="hljs-keyword">return</span> l2;<span class="hljs-keyword">if</span> (!l2)<span class="hljs-keyword">return</span> l1;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span></span>* head = (<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span></span>*)malloc(sizeof(<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span></span>)), *t = head;<span class="hljs-keyword">while</span> (l1 &amp;&amp; l2)&#123;<span class="hljs-keyword">if</span> (l1-&gt;val &lt; l2-&gt;val)&#123;t-&gt;next = l1;l1 = l1-&gt;next;&#125;<span class="hljs-keyword">else</span>&#123;t-&gt;next = l2;l2 = l2-&gt;next;&#125;t = t-&gt;next;&#125;<span class="hljs-keyword">if</span> (l1)      t-&gt;next = l1;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l2) t-&gt;next = l2;<span class="hljs-keyword">return</span> head-&gt;next;&#125;</code></pre></div><ol start="3"><li>思路</li></ol><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_09/006.jpg" srcset="/img/loading.gif" alt=""></p><h1 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83.删除排序链表中的重复元素"></a>83.删除排序链表中的重复元素</h1><ol><li>题目<ul><li>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次</li><li><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">83.删除排序链表中的重复元素</a></li></ul></li><li>代码</li></ol><div class="hljs"><pre><code class="hljs rust"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * struct ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     struct ListNode *next;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span></span>* deleteDuplicates(<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span></span>* head)&#123;<span class="hljs-keyword">if</span>(head == NULL)<span class="hljs-comment">//单链表为空，返回链表</span><span class="hljs-keyword">return</span> head;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span></span> *lp;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span></span> *p = head;<span class="hljs-comment">//指针指向单链表</span>lp = p;<span class="hljs-comment">//最后链表返回的位置</span><span class="hljs-keyword">while</span>(p -&gt;next != NULL)&#123;<span class="hljs-keyword">if</span>(p -&gt; val == p -&gt;next -&gt; val)&#123;p -&gt; next = p -&gt; next -&gt; next;<span class="hljs-comment">//删除后者节点，继续遍历</span>&#125;<span class="hljs-keyword">else</span>&#123;p = p -&gt; next;&#125;&#125;<span class="hljs-keyword">return</span> lp;&#125;</code></pre></div><h1 id="19-删除链表的倒数第N个节点"><a href="#19-删除链表的倒数第N个节点" class="headerlink" title="19. 删除链表的倒数第N个节点"></a>19. 删除链表的倒数第N个节点</h1><ol><li>题目<ul><li>给定一个链表，删除链表的倒数第 <em>n</em> 个节点，并且返回链表的头结点</li><li><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">19. 删除链表的倒数第N个节点</a></li></ul></li><li>代码</li></ol><div class="hljs"><pre><code class="hljs gradle"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Definition for singly-linked list.</span><span class="hljs-comment"> * struct ListNode &#123;</span><span class="hljs-comment"> *     int val;</span><span class="hljs-comment"> *     struct ListNode *next;</span><span class="hljs-comment"> * &#125;;</span><span class="hljs-comment"> */</span>struct ListNode* removeNthFromEnd(struct ListNode* head, <span class="hljs-keyword">int</span> n)&#123;    <span class="hljs-keyword">if</span>(!head || !head-&gt;<span class="hljs-keyword">next</span>)             <span class="hljs-keyword">return</span> <span class="hljs-keyword">NULL</span>;        <span class="hljs-keyword">int</span> len = <span class="hljs-number">1</span>;        struct ListNode *p = head;        <span class="hljs-keyword">while</span>(p-&gt;<span class="hljs-keyword">next</span>)        &#123;            len++;            p = p-&gt;<span class="hljs-keyword">next</span>;        &#125;        p = head;        <span class="hljs-keyword">int</span> index = len - n - <span class="hljs-number">1</span>;        <span class="hljs-comment">// while((index --)&amp;&amp;p)</span>        <span class="hljs-comment">//     p = p-&gt;next;</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len - n; i++)            p = p-&gt;<span class="hljs-keyword">next</span>;        <span class="hljs-keyword">if</span>(n == len)            <span class="hljs-keyword">return</span> head-&gt;<span class="hljs-keyword">next</span>;        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)            p-&gt;<span class="hljs-keyword">next</span> = <span class="hljs-keyword">NULL</span>;        <span class="hljs-keyword">else</span>            p-&gt;<span class="hljs-keyword">next</span> = p-&gt;<span class="hljs-keyword">next</span>-&gt;<span class="hljs-keyword">next</span>;        <span class="hljs-keyword">return</span> head;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>DataStructureAndAlgorithm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Filter &amp; Listener/Filter &amp; Listener</title>
    <link href="/2020/07/27/Filter%20&amp;%20Listener/Filter%20&amp;%20Listener/"/>
    <url>/2020/07/27/Filter%20&amp;%20Listener/Filter%20&amp;%20Listener/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Filter：过滤器"><a href="#一、Filter：过滤器" class="headerlink" title="一、Filter：过滤器"></a>一、Filter：过滤器</h1><ol><li><p>概念</p><ul><li>生活中的过滤器：净水器,空气净化器，土匪…</li><li>web中的过滤器：当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能。</li><li>过滤器的作用<ul><li>一般用于完成通用的操作。如：登录验证、统一编码处理、敏感字符过滤…</li></ul></li></ul></li><li><p>快速入门</p><ol><li>步骤<ol><li>定义一个类，实现接口Filter</li><li>复写方法</li><li>配置拦截路径<ol><li>web.xml</li><li>注解</li></ol></li></ol></li><li>代码</li></ol></li><li><p>过滤器细节</p><ol><li><p>web.xml配置</p><div class="hljs"><pre><code class="hljs java">&lt;filter&gt;    &lt;filter-name&gt;demo1&lt;/filter-name&gt;    &lt;filter-<span class="hljs-class"><span class="hljs-keyword">class</span>&gt;<span class="hljs-title">cn</span>.<span class="hljs-title">itcast</span>.<span class="hljs-title">web</span>.<span class="hljs-title">filter</span>.<span class="hljs-title">FilterDemo1</span>&lt;/<span class="hljs-title">filter</span>-<span class="hljs-title">class</span>&gt;</span><span class="hljs-class">&lt;/<span class="hljs-title">filter</span>&gt;</span><span class="hljs-class"></span><span class="hljs-class">&lt;<span class="hljs-title">filter</span>-<span class="hljs-title">mapping</span>&gt;</span><span class="hljs-class">    &lt;<span class="hljs-title">filter</span>-<span class="hljs-title">name</span>&gt;<span class="hljs-title">demo1</span>&lt;/<span class="hljs-title">filter</span>-<span class="hljs-title">name</span>&gt;</span><span class="hljs-class">    &lt;!-- 拦截路径 --&gt;</span><span class="hljs-class">    &lt;<span class="hljs-title">url</span>-<span class="hljs-title">pattern</span>&gt;/*&lt;/<span class="hljs-title">url</span>-<span class="hljs-title">pattern</span>&gt;</span><span class="hljs-class">&lt;/<span class="hljs-title">filter</span>-<span class="hljs-title">mapping</span>&gt;</span></code></pre></div><p>web.xml配置比注解复杂一些</p></li><li><p>过滤器执行流程</p><ol><li>执行过滤器</li><li>执行放行后的资源</li><li>回来执行过滤器放行代码下边的代码</li></ol></li><li><p>过滤器生命周期方法</p><ol><li><code>init</code>：在服务器启动后，会创建Filter对象，然后调用init方法。只执行一次。用于加载资源</li><li><code>doFilter</code>：每一次请求被拦截资源时，会执行。执行多次</li><li><code>destroy</code>：在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。只执行一次。用于释放资源</li></ol></li><li><p>过滤器配置详解</p><ul><li><p>拦截路径配置</p><ol><li>具体资源路径： <code>/index.jsp</code>  只有访问index.jsp资源时，过滤器才会被执行</li><li>拦截目录：<code>/user/*</code>    访问/user下的所有资源时，过滤器都会被执行</li><li>后缀名拦截：<code>*.jsp</code>        访问所有后缀名为jsp资源时，过滤器都会被执行*</li><li>拦截所有资源：<code>/*</code>    访问所有资源时，过滤器都会被执行</li></ol></li><li><p>拦截方式配置：根据资源被访问的方式判断是否拦截</p><ol><li><p>注解配置</p><ul><li>设置<code>dispatcherTypes</code>属性<ol><li><u>REQUEST</u>：默认值。浏览器直接请求资源时执行拦截</li><li><u>FORWARD</u>：转发访问资源时执行拦截</li><li>INCLUDE：包含访问资源时执行拦截</li><li>ERROR：错误跳转资源时执行拦截</li><li>ASYNC：异步访问资源时执行拦截</li></ol></li></ul></li><li><p>web.xml配置</p><ul><li>设置<code>&lt;dispatcher&gt;&lt;/dispatcher&gt;</code>标签即可</li></ul></li></ol></li></ul></li><li><p>过滤器链(配置多个过滤器)</p><ul><li><p>执行顺序：如果有两个过滤器：过滤器1和过滤器2</p><ol><li>过滤器1</li><li>过滤器2</li><li>资源执行</li><li>过滤器2</li><li>过滤器1</li></ol></li><li><p>过滤器先后顺序问题</p><ol><li>注解配置：按照类名的字符串比较规则比较，值小的先执行。如： 过滤器类名为AFilter 和 BFilter，那么AFilter就先执行了。</li><li>web.xml配置：<code>&lt;filter-mapping&gt;</code>定义在上边的先执行</li></ol></li></ul></li></ol></li><li><p>案例</p><ol><li><p>案例1_登录验证</p><ul><li>需求<ol><li>访问day17_case案例的资源。验证其是否登录</li><li>如果登录了，则直接放行</li><li>如果没有登录，则跳转到登录页面，提示”您尚未登录，请先登录”</li></ol></li></ul><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_07/36.png" srcset="/img/loading.gif" alt=""></p></li><li><p>案例2_敏感词汇过滤</p><ul><li><p>需求</p><ol><li>对day17_case案例录入的数据进行敏感词汇过滤</li><li>敏感词汇参考《敏感词汇.txt》</li><li>如果是敏感词汇，替换为 *** </li></ol><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_07/37.png" srcset="/img/loading.gif" alt=""></p></li><li><p>分析</p><ol><li>对request对象进行增强。增强获取参数相关方法</li><li>放行。传递代理对象</li></ol></li><li><p>增强对象的功能</p><p> 设计模式：一些通用的解决固定问题的方式</p><ol><li><p>装饰模式</p></li><li><p>代理模式</p><ul><li><p>概念</p><ol><li>真实对象：被代理的对象（联想公司）</li><li>代理对象：（西安联想代理商）</li><li>代理模式：代理对象 代理 真实对象，达到增强真实对象功能的目的</li></ol></li><li><p>实现方式</p><ol><li><p>静态代理：有一个类文件描述代理模式</p></li><li><p>动态代理：在内存中形成代理类</p><ul><li><p>实现步骤</p><ol><li>代理对象和真实对象实现相同的接口</li><li>代理对象 = Proxy.newProxyInstance();</li><li>使用代理对象调用方法</li><li>增强方法</li></ol></li><li><p>增强方式</p><ol><li>增强参数列表</li><li>增强返回值类型</li><li>增强方法体执行逻辑</li></ol></li></ul></li></ol></li></ul></li></ol></li></ul></li></ol></li></ol><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_07/38.png" srcset="/img/loading.gif" alt=""></p><h1 id="二、Listener：监听器"><a href="#二、Listener：监听器" class="headerlink" title="二、Listener：监听器"></a>二、Listener：监听器</h1><ol><li><p>概念：web的三大组件之一</p><ol><li><p>事件监听机制</p><ul><li>事件：一件事情</li><li>事件源 ：事件发生的地方</li><li>监听器 ：一个对象</li><li>注册监听：将事件、事件源、监听器绑定在一起。 当事件源上发生某个事件后，执行监听器代码</li></ul></li><li><p>常用监听器<code>ServletContextListener</code>：监听ServletContext对象的创建和销毁</p><ul><li><p>方法</p><ul><li><code>void contextDestroyed(ServletContextEvent sce)</code>：ServletContext对象被销毁之前会调用该方法</li><li><code>void contextInitialized(ServletContextEvent sce)</code> ：ServletContext对象创建后会调用该方法</li></ul></li><li><p>步骤</p><ol><li><p>定义一个类，实现<code>ServletContextListener</code>接口</p></li><li><p>复写方法</p></li><li><p>配置</p><ol><li><p>web.xml</p><div class="hljs"><pre><code class="hljs java">&lt;listener&gt;&lt;listener-<span class="hljs-class"><span class="hljs-keyword">class</span>&gt;</span><span class="hljs-class"><span class="hljs-title">cn</span>.<span class="hljs-title">itcast</span>.<span class="hljs-title">web</span>.<span class="hljs-title">listener</span>.<span class="hljs-title">ContextLoaderListener</span></span><span class="hljs-class">&lt;/<span class="hljs-title">listener</span>-<span class="hljs-title">class</span>&gt;</span><span class="hljs-class">&lt;/<span class="hljs-title">listener</span>&gt;</span></code></pre></div><p>指定初始化参数<code>&lt;context-param&gt;</code></p></li><li><p>注解<code>@WebListener</code></p></li></ol></li></ol></li></ul></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>Filter、Listener</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MVC开发模式 &amp; el表达式 &amp; jstl标签/MVC开发模式 &amp; el表达式 &amp; jstl标签</title>
    <link href="/2020/07/26/MVC%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%20&amp;%20el%E8%A1%A8%E8%BE%BE%E5%BC%8F%20&amp;%20jstl%E6%A0%87%E7%AD%BE/MVC%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%20&amp;%20el%E8%A1%A8%E8%BE%BE%E5%BC%8F%20&amp;%20jstl%E6%A0%87%E7%AD%BE/"/>
    <url>/2020/07/26/MVC%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%20&amp;%20el%E8%A1%A8%E8%BE%BE%E5%BC%8F%20&amp;%20jstl%E6%A0%87%E7%AD%BE/MVC%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%20&amp;%20el%E8%A1%A8%E8%BE%BE%E5%BC%8F%20&amp;%20jstl%E6%A0%87%E7%AD%BE/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/panda001/p/11029073.html" target="_blank" rel="noopener">框架参考链接</a></p><h1 id="一、MVC开发模式"><a href="#一、MVC开发模式" class="headerlink" title="一、MVC开发模式"></a>一、MVC开发模式</h1><ol><li><p>jsp演变历史</p><ol><li>早期只有servlet，只能使用response输出标签数据，非常麻烦</li><li>后来又jsp，简化了Servlet的开发，如果过度使用jsp，在jsp中即写大量的java代码，有写html表，造成难于维护，难于分工协作</li><li>再后来，java的web开发，借鉴mvc开发模式，使得程序的设计更加合理性</li></ol></li><li><p>MVC</p><ol><li>M：Model，模型➡JavaBean<ul><li>完成具体的业务操作，如：查询数据库，封装对象</li></ul></li><li>V：View，视图➡JSP<ul><li>展示数据</li></ul></li><li>C：Controller，控制器➡Servlet<ul><li>获取用户的输入</li><li>调用模型</li><li>将数据交给视图进行展示</li></ul></li></ol></li><li><p>优缺点</p><ol><li><p>优点</p><ol><li><p>耦合性低，方便维护，可以利于分工协作</p></li><li><p>重用性高</p></li></ol></li><li><p>缺点：</p><p>  使得项目架构变得复杂，对开发人员要求高</p></li></ol></li></ol><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_07/33.png" srcset="/img/loading.gif" alt=""></p><h1 id="二、EL表达式"><a href="#二、EL表达式" class="headerlink" title="二、EL表达式"></a>二、EL表达式</h1><ol><li><p>概念：Expression Language 表达式语言</p></li><li><p>作用：替换和简化jsp页面中java代码的编写</p></li><li><p>语法：<code>${表达式}</code></p></li><li><p>注意：</p><ul><li>jsp默认支持el表达式的。如果要忽略el表达式<ol><li>设置jsp中page指令中：<code>isELIgnored=&quot;true&quot;</code> 忽略当前jsp页面中所有的el表达式</li><li><code>\${表达式}</code> ：忽略当前这个el表达式</li></ol></li></ul></li><li><p>使用</p><ol><li><p>运算——运算符</p><ol><li>算数运算符： +、- 、* 、/(div) 、%(mod)</li><li>比较运算符： &gt; 、&lt; 、&gt;=、 &lt;=、 ==、 !=</li><li>逻辑运算符： &amp;&amp; (and)、 ||(or)、 !(not)</li><li>空运算符： empty<ul><li>功能：用于判断字符串、集合、数组对象是否为null或者长度是否为0</li><li><code>${empty list}</code>：判断字符串、集合、数组对象是否 为 null或者长度为0</li><li><code>${not empty str}</code>：表示判断字符串、集合、数组对象是否 不为 null 并且 长度&gt;0</li></ul></li></ol></li><li><p>获取值</p><ol><li><p>el表达式只能从域对象中获取值</p></li><li><p>语法</p><ol><li><p><code>${域名称.键名}</code>：从指定域中获取指定键的值</p><ul><li><p>域名称</p><table><thead><tr><th>域名称</th><th>指定域</th></tr></thead><tbody><tr><td>pageScope</td><td>pageContext</td></tr><tr><td>requestScope</td><td>request</td></tr><tr><td>sessionScope</td><td>session</td></tr><tr><td>applicationScope</td><td>application（ServletContext）</td></tr></tbody></table></li><li><p>举例：在request域中存储了name=张三，通过${requestScope.name}来获取指定域request中指定键name的值</p></li><li><p>如果指定的键不存在，显示的是空字符串</p></li></ul></li><li><p><code>${键名}</code>：表示依次从最小的域中查找是否有该键对应的值，直到找到为止。</p></li><li><p>获取对象、List集合、Map集合的值</p><ol><li><p>对象</p><ul><li><p><code>${域名称.键名.属性名}</code></p></li><li><p>本质上会去调用对象的getter方法</p></li></ul></li><li><p>List集合</p><ul><li><code>${域名称.键名[索引]}</code></li><li>索引不存在会报错</li></ul></li><li><p>Map集合</p><ul><li><code>${域名称.键名.key名称}</code></li><li><code>${域名称.键名[&quot;key名称&quot;]}</code></li></ul></li></ol></li></ol></li><li><p>隐式对象</p><ul><li>el表达式中有11个隐式对象</li><li>pageContext：获取jsp其他八个内置对象<ul><li><code>${pageContext.request.contextPath}</code>：动态获取虚拟目录</li></ul></li></ul></li></ol></li></ol></li></ol><h1 id="三、JSTL标签"><a href="#三、JSTL标签" class="headerlink" title="三、JSTL标签"></a>三、JSTL标签</h1><ol><li><p>概念：JavaServer Pages Tag Library  JSP，标准标签库。是由Apache组织提供的开源的免费的jsp标签。</p></li><li><p>作用：用于简化和替换jsp页面上的java代码</p></li><li><p>使用步骤</p><ol><li>导入jstl相关jar包</li><li>引入标签库：taglib指令<code>&lt;%@ taglib %&gt;</code></li><li>使用标签</li></ol></li><li><p>常用的JSTL标签</p><ol><li><p>if：相当于java代码的if语句</p><ol><li><p>属性</p><p>test为必须属性，接收boolean表达式</p><ul><li>如果表达式为true，则显示if标签体内容，如果为false，则不显示标签体内容</li><li>一般情况下，test属性值会结合el表达式一起使用</li></ul></li><li><p>注意</p><p><code>&lt;c:if&gt;&lt;/c:if&gt;</code>标签没有else情况，想要else情况，则可以在定义一个<code>&lt;c:if&gt;&lt;/c:if&gt;</code>标签</p></li></ol></li><li><p>choose:相当于java代码的switch语句</p><ol><li>使用choose标签声明，相当于switch声明</li><li>使用when标签做判断，相当于case</li><li>使用otherwise标签做其他情况的声明，相当于default</li></ol></li><li><p>foreach:相当于java代码的for语句</p><ol><li>完成重复操作<ul><li>属性<ol><li>begin：开始值</li><li>end：结束值</li><li>var：临时变量</li><li>step：步长</li><li>varStaus：循环状态对象（多数在遍历容器时使用）<ul><li>index：容器中元素的索引，从0开始</li><li>count：循环次数，从1开始</li></ul></li></ol></li></ul></li><li>遍历容器<ul><li>属性<ol><li>items：容器对象</li><li>var：容器中元素的临时变量</li><li>varStaus：循环状态对象（多数在遍历容器时使用）<ul><li>index：容器中元素的索引，从0开始</li><li>count：循环次数，从1开始</li></ul></li></ol></li></ul></li></ol></li></ol></li><li><p>练习</p><ul><li>需求：在request域中有一个存有User对象的List集合。需要使用jstl+el将list集合数据展示到jsp页面的表格table中</li></ul></li></ol><h1 id="四、三层架构"><a href="#四、三层架构" class="headerlink" title="四、三层架构"></a>四、三层架构</h1><p>web开发领域设计架构</p><ol><li>界面层（表示层/web层）：用户看的界面；它主要完成三件事情：<ul><li>从界面中取得数据跟后台服务器交互</li><li>跟后台交互后进行数据绑定</li><li>将绑定的数据呈现在页面中</li></ul></li><li>业务逻辑层（service层）：处理业务逻辑：登录、注册等；组合DAO层的简单方法，形成复杂的功能；采用Spring框架</li><li>数据访问层（dao层）：操作数据存储文件，定义了对于数据库最基本的crud操作；采用MyBatis框架</li></ol><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_07/35.png" srcset="/img/loading.gif" alt=""></p><h1 id="五、框架"><a href="#五、框架" class="headerlink" title="五、框架"></a>五、框架</h1><p>针对上面架构的每一个层面，目前Web开发领域内都有一些优秀的框架</p><p>例如：</p><ul><li>表示层有Structs2、SpringMVC等</li><li>持久层有Hibernate、Mybatis等</li><li>业务层有Spring框架</li></ul><p>但是严格来说，Spring是一个整合框架，业务层面在每一个公司每一个项目都会根据自己的需求做不同的处理</p><p>在项目的开发中，几种使用非常广泛的框架组合：</p><ul><li>SSH：Struts 、Spring、Hibernate</li><li>SSM：SpringMVC框架、MyBatis框架、Spring框架（javaee灵魂框架）</li></ul><h1 id="六、案例-用户信息列表展示"><a href="#六、案例-用户信息列表展示" class="headerlink" title="六、案例:用户信息列表展示"></a>六、案例:用户信息列表展示</h1>]]></content>
    
    
    <categories>
      
      <category>MVC开发模式、el表达式、jstl标签</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>兔酱碎碎念/初中四人</title>
    <link href="/2020/07/25/%E5%85%94%E9%85%B1%E7%A2%8E%E7%A2%8E%E5%BF%B5/%E5%88%9D%E4%B8%AD%E5%9B%9B%E4%BA%BA/"/>
    <url>/2020/07/25/%E5%85%94%E9%85%B1%E7%A2%8E%E7%A2%8E%E5%BF%B5/%E5%88%9D%E4%B8%AD%E5%9B%9B%E4%BA%BA/</url>
    
    <content type="html"><![CDATA[<p><span class="label label-success">ᓚᘏᗢ</span></p><p>上午陪饺子去收拾了头发：剪短、染了一个亚麻色</p><p>走上北岳小学的路上很热… 剪完头发已经一点钟了。居然用了三个小时。我愿称这位大叔是染发界最细心的</p><p>  <del>磨蹭…其实效果不咋滴，不值那个时间…</del>  </p><p>整完头发就开始下雨，打车去吃午饭</p><p><span class="label label-default">ᓚᘏᗢ</span></p><p>五年过去了，某月还是原来的某月，性格开朗</p><p><span class="label label-warning">ᓚᘏᗢ</span></p><p>最近B站会员、健身卡导致破产ing…ಥ_ಥ</p><p>去参与一些新的事情前的确应该问一问有经验的咩？</p><p>本以为还算便宜，结果现在发现其实是贵了，有点心疼钱钱了 OWO</p><p><span class="label label-danger">ᓚᘏᗢ</span></p><p>今天午饭去了牛家小庄</p><p>最爱的还是家常菜过油肉，最不好吃的就是坩埚土豆片。虾和烤鱼都还算一般般~</p><p>这些菜都是坩埚，整得整个房间都热的要命(o-ωｑ)).oO 不过后来好多了~</p><p>逛街…</p><p>健身…</p><p>今天是健身第二天，健身女孩终于复活啦！果然躺尸比不上青春活力的健身！</p><p>立下flag：坚持健身、拥抱美好身材</p><p><span class="label label-success">ᓚᘏᗢ</span></p><p>直到现在想到大学志愿还是会遗憾</p><p>总感觉自己考的分数可以去更好学校的计算机专业</p><p>可那时候自己也认认真真选了好久///铁选计算机///保守派报志愿</p><p>或许自己上大学这么久没有学到一些比较硬的知识，就开始怪自己当初选的学校有问题了吧</p><p>或许也有一些不服气在里面</p><p>说到这个就不由得想到明年的考研和就业了</p><p>不想学习课本，但是却抱着一口气想读好的大学</p><p>没有技术，但是却想着进一线公司</p><p>？？？</p><p>希望以后的自己不要留有任何遗憾</p><p>要不负勇往</p>]]></content>
    
    
    <categories>
      
      <category>鱼酱碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>兔酱碎碎念/科一考试</title>
    <link href="/2020/07/24/%E5%85%94%E9%85%B1%E7%A2%8E%E7%A2%8E%E5%BF%B5/%E7%A7%91%E4%B8%80%E8%80%83%E8%AF%95/"/>
    <url>/2020/07/24/%E5%85%94%E9%85%B1%E7%A2%8E%E7%A2%8E%E5%BF%B5/%E7%A7%91%E4%B8%80%E8%80%83%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<p>今天大早上不到七点就起床了，收拾收拾就去驾校准备科一考试了。本来以为上午很快就可以考完走人了，结果一点钟才回了家。</p><p>人多，没听见喊了自己的名字，就排在了后面~ (ಥ _ ಥ)</p><p>检查了指纹后发现眼镜不在了 ~ (ಥ _ ಥ)</p><p>不过，考过了，当然眼镜也找见啦</p><p><span class="label label-default">ᓚᘏᗢ</span></p><p>下午休息///和鸡蛋饼唠嗑</p><p>四点钟的时候去办了健身房的月卡</p><p><span class="label label-default">ᓚᘏᗢ</span></p><p>昨天晚上本来想着十二点睡觉，然后第二天早上就可以七点钟起床，睡七个小时蛮好</p><p>结果失眠了…不过，失眠的时候总会胡思乱想 OWO</p><p>想着~今天算是一个小小分界点 ~   </p><ul><li>B站LV4~</li><li>QQ SVIP LV6~</li><li>暑假已过1/3</li><li>科一考过</li></ul><p>距离开学很近了，又想到昨天写下的怠惰躺尸的自己，就觉得应该动起来了。于是</p><ul><li>开始健身</li></ul><p>接下来每天有健身、学习、驾照…随之而来还有六级…(￣︶￣*))</p><p>其实面对这么多（姑且算多吧）的事情还是很爽的，不会慌</p><p>毕竟，自己是个喜欢有安排和计划的人，长时间的躺尸并不会觉得舒服</p><p>鱼酱(ง •_•)ง冲冲冲</p>]]></content>
    
    
    <categories>
      
      <category>鱼酱碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JSP/JSP</title>
    <link href="/2020/07/23/JSP/JSP/"/>
    <url>/2020/07/23/JSP/JSP/</url>
    
    <content type="html"><![CDATA[<h1 id="一、JSP：入门学习"><a href="#一、JSP：入门学习" class="headerlink" title="一、JSP：入门学习"></a>一、JSP：入门学习</h1><ol><li><p>概念：</p><ul><li>Java Server Pages： java服务器端页面<ul><li>可以理解为：一个特殊的页面，其中既可以指定定义html标签，又可以定义java代码</li><li>用于简化书写！！！</li></ul></li></ul></li><li><p>原理</p><ul><li>JSP本质上就是一个Servlet</li></ul></li></ol><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_07/30.png" srcset="/img/loading.gif" alt=""></p><ol start="3"><li>JSP的脚本：JSP定义Java代码的方式<ol><li>&lt;%  代码 %&gt;：定义的java代码，在service方法中。service方法中可以定义什么，该脚本中就可以定义什么。</li><li>&lt;%! 代码 %&gt;：定义的java代码，在jsp转换后的java类的成员位置。</li><li>&lt;%= 代码 %&gt;：定义的java代码，会输出到页面上。输出语句中可以定义什么，该脚本中就可以定义什么。</li></ol></li><li>JSP的内置对象：<ul><li>在jsp页面中不需要获取和创建，可以直接使用的对象</li><li>jsp一共有9个内置对象，今天学习3个：<ol><li>request</li><li>response</li><li>out：字符输出流对象。可以将数据输出到页面上。和response.getWriter()类似<ul><li><code>response.getWriter()</code>和<code>out.write()</code>的区别：<ol><li>在tomcat服务器真正给客户端做出响应之前，会先找response缓冲区数据，再找out缓冲区数据。</li><li>response.getWriter()数据输出永远在out.write()之前</li></ol></li></ul></li></ol></li></ul></li></ol><h1 id="二、指令"><a href="#二、指令" class="headerlink" title="二、指令"></a>二、指令</h1><ol><li><p>作用：用于配置JSP页面，导入资源文件</p></li><li><p>格式：<code>&lt;%@ 指令名称 属性名1=属性值1 属性名2=属性值2 ... %&gt;</code></p></li><li><p>分类</p><ol><li><p>page：配置JSP页面的</p><ul><li>contentType：等同于<code>response.setContentType()</code><ol><li>设置响应体的mime类型以及字符集</li><li>设置当前jsp页面的编码（只能是高级的IDE才能生效，如果使用低级工具，则需要设置pageEncoding属性设置当前页面的字符集）</li></ol></li><li>import：导包</li><li>errorPage：当前页面发生异常后，会自动跳转到指定的错误页面</li><li>isErrorPage：标识当前也是是否是错误页面<ol><li>true：是，可以使用内置对象exception</li><li>false：否。默认值。不可以使用内置对象exception</li></ol></li></ul></li><li><p>include：页面包含的。导入页面的资源文件</p><p><code>&lt;%@include file=&quot;top.jsp&quot;%&gt;</code></p></li><li><p>taglib：导入资源</p><p><code>&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;</code> </p><ul><li>prefix：前缀，自定义的</li></ul></li></ol></li></ol><h1 id="三、注释"><a href="#三、注释" class="headerlink" title="三、注释"></a>三、注释</h1><ol><li>html注释<br> <code>&lt;!-- --&gt;</code>：只能注释html代码片段</li><li>jsp注释：推荐使用<br> <code>&lt;%-- --%&gt;</code>：可以注释所有</li></ol><h1 id="四、内置对象"><a href="#四、内置对象" class="headerlink" title="四、内置对象"></a>四、内置对象</h1><ol><li><p>在jsp页面中不需要创建，直接使用的对象</p></li><li><p>九大内置对象</p><p>前4个为四大域对象</p></li></ol><table><thead><tr><th align="center">变量名</th><th>真实类型</th><th>作用</th></tr></thead><tbody><tr><td align="center">pageContext</td><td>PageContext</td><td>当前页面共享数据，还可以获取其他八个内置对象</td></tr><tr><td align="center">request</td><td>HttpServletRequest</td><td>当前页面共享数据，还可以获取其他八个内置对象</td></tr><tr><td align="center">session</td><td>HttpSession</td><td>一次会话的多个请求间</td></tr><tr><td align="center">application</td><td>ServletContext</td><td>所有用户间共享数据</td></tr><tr><td align="center">response</td><td>HttpServletResponse</td><td>响应对象</td></tr><tr><td align="center">page</td><td>Object</td><td>当前页面(Servlet)的对象  this</td></tr><tr><td align="center">out</td><td>JspWriter</td><td>输出对象，数据输出到页面上</td></tr><tr><td align="center">config</td><td>ServletConfig</td><td>Servlet的配置对象</td></tr><tr><td align="center">exception</td><td>Throwable</td><td>异常对象</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>JSP</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>会话技术/会话技术</title>
    <link href="/2020/07/23/%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF/%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF/"/>
    <url>/2020/07/23/%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF/%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="一、会话技术"><a href="#一、会话技术" class="headerlink" title="一、会话技术"></a>一、会话技术</h1><ol><li>会话：一次会话中包含多次请求和响应。<ul><li>一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止</li></ul></li><li>功能：在一次会话的范围内的多次请求间，共享数据</li><li>方式：<ol><li>客户端会话技术：Cookie</li><li>服务器端会话技术：Session</li></ol></li></ol><h1 id="二、Cookie"><a href="#二、Cookie" class="headerlink" title="二、Cookie"></a>二、Cookie</h1><ol><li>概念：客户端会话技术，将数据保存到客户端</li><li>快速入门<ul><li>使用步骤<ol><li>创建Cookie对象，绑定数据<ul><li><code>new Cookie(String name, String value)</code></li></ul></li><li>发送Cookie对象<ul><li><code>response.addCookie(Cookie cookie)</code></li></ul></li><li>获取Cookie，拿到数据<ul><li><code>Cookie[]  request.getCookies()</code></li></ul></li></ol></li></ul></li><li>实现原理<ul><li>基于响应头set-cookie和请求头cookie实现</li></ul></li></ol><p>Cookie原理：</p><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_07/28.png" srcset="/img/loading.gif" alt=""></p><ol start="4"><li><p>cookie的细节</p><ol><li><p>一次可不可以发送多个cookie?</p><ul><li>可以</li><li>可以创建多个Cookie对象，使用response调用多次addCookie方法发送cookie即可。</li></ul></li><li><p>cookie在浏览器中保存多长时间？</p><ol><li><p>默认情况下，当浏览器关闭后，Cookie数据被销毁</p></li><li><p>持久化存储：</p><ul><li><p><code>setMaxAge(int seconds)</code></p><ol><li><p>正数：将Cookie数据写到硬盘的文件中。持久化存储。并指定cookie存活时间，时间到后，cookie文件自动失效</p></li><li><p>负数：默认情况</p></li><li><p>零：删除cookie信息</p></li></ol></li></ul></li></ol></li><li><p>cookie能不能存中文？</p><ul><li>在tomcat 8 之前 cookie中不能直接存储中文数据。<ul><li>需要将中文数据转码：一般采用URL编码(%E3)</li></ul></li><li>在tomcat 8 之后，cookie支持中文数据。<ul><li>特殊字符（如：空格）还是不支持，建议使用URL编码存储，URL解码解析</li></ul></li></ul></li><li><p>cookie共享问题？</p><ol><li>假设在一个tomcat服务器中，部署了多个web项目，那么在这些web项目中cookie能不能共享？<ul><li>默认情况下cookie不能共享</li><li><code>setPath(String path)</code>：设置cookie的获取范围。默认情况下，设置当前的虚拟目录<ul><li>如果要共享，则可以将path设置为”/“</li></ul></li></ul></li><li>不同的tomcat服务器间cookie共享问题？<ul><li><code>setDomain(String path)</code>：如果设置一级域名相同，那么多个服务器之间cookie可以共享<ul><li>setDomain(“.baidu.com”)：那么tieba.baidu.com和news.baidu.com中cookie可以共享</li></ul></li></ul></li></ol></li></ol></li><li><p>Cookie的特点和作用</p><ol><li>特点<ol><li>cookie存储数据在客户端浏览器</li><li>浏览器对于单个cookie 的大小有限制(4kb) 以及 对同一个域名下的总cookie数量也有限制(20个)</li></ol></li><li>作用<ol><li>cookie一般用于存出少量的不太敏感的数据</li><li>在不登录的情况下，完成服务器对客户端的身份识别</li></ol></li></ol></li><li><p>案例：记住上一次访问时间</p><ol><li>需求<ol><li>访问一个Servlet，如果是第一次访问，则提示：您好，欢迎您首次访问</li><li>如果不是第一次访问，则提示：欢迎回来，您上次访问时间为:显示时间字符串</li></ol></li><li>分析<ol><li>可以采用Cookie来完成</li><li>在服务器中的Servlet判断是否有一个名为lastTime的cookie<ul><li>有：不是第一次访问<ol><li>响应数据：欢迎回来，您上次访问时间为:2018年6月10日11:50:20</li><li>写回Cookie：lastTime=2018年6月10日11:50:01</li></ol></li><li>没有：是第一次访问<ol><li>响应数据：您好，欢迎您首次访问</li><li>写回Cookie：lastTime=2018年6月10日11:50:01</li></ol></li></ul></li></ol></li></ol></li></ol><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_07/29.png" srcset="/img/loading.gif" alt=""></p><h1 id="三、Session"><a href="#三、Session" class="headerlink" title="三、Session"></a>三、Session</h1><ol><li>概念：服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。HttpSession</li><li>快速入门<ol><li>获取HttpSession对象<ul><li><code>HttpSession session = request.getSession();</code></li></ul></li><li>使用HttpSession对象：<ul><li><code>Object getAttribute(String name)</code></li><li><code>void setAttribute(String name, Object value)</code></li><li><code>void removeAttribute(String name)</code></li></ul></li></ol></li><li>原理<ul><li>Session的实现是依赖于Cookie的。</li></ul></li></ol><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_07/31.png" srcset="/img/loading.gif" alt=""></p><ol start="4"><li><p>细节</p><ol><li><p>当客户端关闭后，服务器不关闭，两次获取session是否为同一个？</p><ul><li><p>默认情况下。不是。</p></li><li><p>如果需要相同，则可以创建Cookie，键为 <code>JSESSIONID</code>，设置最大存活时间，让cookie持久化保存。</p><div class="hljs"><pre><code class="hljs java">Cookie c = <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">"JSESSIONID"</span>,session.getId());c.setMaxAge(<span class="hljs-number">60</span>*<span class="hljs-number">60</span>);response.addCookie(c);</code></pre></div></li></ul></li><li><p>客户端不关闭，服务器关闭后，两次获取的session是同一个吗？</p><ul><li>不是同一个，但是要确保数据不丢失。tomcat自动完成以下工作<ul><li>session的钝化：在服务器正常关闭之前，将session对象系列化到硬盘上</li><li>session的活化：在服务器启动后，将session文件转化为内存中的session对象即可。</li></ul></li></ul></li><li><p>session什么时候被销毁？</p><ol><li><p>服务器关闭</p></li><li><p>session对象调用<code>invalidate()</code></p></li><li><p>session默认失效时间 30分钟<br> 选择性配置修改    </p> <div class="hljs"><pre><code class="hljs java">&lt;session-config&gt;     &lt;session-timeout&gt;30&lt;/session-timeout&gt; &lt;/session-config&gt;</code></pre></div></li></ol></li></ol></li><li><p>session的特点</p><ol><li>session用于存储一次会话的多次请求的数据，存在服务器端</li><li>session可以存储任意类型，任意大小的数据</li></ol><blockquote><p>session与Cookie的区别：</p><ol><li>session存储数据在服务器端，Cookie在客户端</li><li>session没有数据大小限制，Cookie有</li><li>session数据安全，Cookie相对于不安全</li></ol></blockquote></li><li><p>案例：验证码</p><ol><li>需求<ol><li>访问带有验证码的登录页面login.jsp</li><li>用户输入用户名，密码以及验证码<ul><li>如果用户名和密码输入有误，跳转登录页面，提示:用户名或密码错误</li><li>如果验证码输入有误，跳转登录页面，提示：验证码错误</li><li>如果全部输入正确，则跳转到主页success.jsp，显示：用户名,欢迎您</li></ul></li></ol></li><li>分析</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_07/32.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>会话技术</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>兔酱碎碎念/怠惰察觉</title>
    <link href="/2020/07/23/%E5%85%94%E9%85%B1%E7%A2%8E%E7%A2%8E%E5%BF%B5/%E6%80%A0%E6%83%B0%E5%AF%9F%E8%A7%89/"/>
    <url>/2020/07/23/%E5%85%94%E9%85%B1%E7%A2%8E%E7%A2%8E%E5%BF%B5/%E6%80%A0%E6%83%B0%E5%AF%9F%E8%A7%89/</url>
    
    <content type="html"><![CDATA[<h1 id="躺尸…"><a href="#躺尸…" class="headerlink" title="躺尸…"></a>躺尸…</h1><p>自从五月份以来，就开始变得很是懒惰。虽然开始学习是很好的一件事情，但是却停止了健身，现在觉得躺尸简直是最舒服的事情。</p><p>怎么说呢，自从不运动，由于大吃大喝，尤其是各种甜品，体重在短时间内飙升，现在丝毫没有想动弹的欲望。变得太懒了。难得今年在家这么久，但是外面却在修路，真不巧…连跑步的一点星光都灭掉了。现在的我已经不想动弹…是真的不想去街上跑步…尘土飞扬…想想就害怕</p><p>自从停止健身就开始从网上学习Javaweb。算不上经常敲代码，但是肯定也是有用的，只要学习就不是白学的，最后还需要深入学习&amp;敲代码。</p><p>好像自己的性格其实就是不让自己闲下来，自从上了大学，已经以间歇性踌躇满志，持续性混吃等死的状态度过了两年。其实问一下自己也是问心无愧的。上大学好好玩耍也是我最起初的一件渴望的事情。对于没有好好学习将来工作上的知识，我觉得还是蛮随心的。一直以来其实都有在四处搜索计算机专业工作的相关技能。以前的一切行为选择形成了现在的结果，并不后悔。</p><p>2020年的寒假本想着学习计算机基础：数据结构和计算机网络。结果不了了之了，也已经过去了，没什么好说的。不过，其实那时候就应该开始认真自学了。</p><p>半年过去了，今年暑假开学后就大三，距离离校实习和考研不远了。希望真的能学到点什么。改变吧。</p><p>其次还有驾照，明天要去考科一，说是没什么底，也不对，说着必过，也不行。总之，安安心心去考就好了。</p><p>六级下半年也要考了，至今还没有开始准备…</p><p><span class="label label-success">ᓚᘏᗢ</span></p><p>好像就像一条失去梦想的咸鱼？？？这是个谜…</p><p>突然爱上了躺尸…</p><p>除了学习Javaweb，对其他的任何都已经完全没有渴望了…</p><p>哦对，对动漫还有兴趣 ~ [] ~ (￣▽￣) ~ *</p><p>所以，这一阶段除了学习Javaweb就是躺尸看动漫///住在了B站//// &lt;(￣︶￣)</p><h1 id="三日"><a href="#三日" class="headerlink" title="三日///"></a>三日///</h1><p>20号陪宝贝拍了身份证、剪了个短发</p><p>中午去火焱山吃的自助火锅烧烤，第二天就涨了一斤，已经107  ~~ (ˉ▽ˉ)……</p><p>最近三天没有学习，今天接触了会话技术</p><p>今天晚上要去帮忙，每每都会难过。我知道自己也是一脸不情愿，可是我也改变不了这样的自己。因为看见别人的生活很羡慕，尤其是这时就会想如果我家只有我一个孩子该多好，可能这样爸妈他们也就不用那么忙碌了</p><p>看见一句弹幕很感同身受：“ 别人的生活是你的梦想 ”</p><p>很真实，甚至可以说是现实，一个自出生就不公平的现实，没有办法更改。既然这样了，还是要做一个看透现实的乐观主义者，在自己的圈子里让自己变得更好。</p><p>网络世界既是花花世界，让你迷乱。了解的愈多，随之而来的也有内心上的变化…</p>]]></content>
    
    
    <categories>
      
      <category>鱼酱碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Servlet/Servlet</title>
    <link href="/2020/07/16/Servlet/Servlet/"/>
    <url>/2020/07/16/Servlet/Servlet/</url>
    
    <content type="html"><![CDATA[<h1 id="一-认识Servlet"><a href="#一-认识Servlet" class="headerlink" title="一.认识Servlet"></a>一.认识Servlet</h1><h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><ul><li>运行在服务器端的小程序</li><li>Servlet就是一个接口，定义了Java类被浏览器访问到(tomcat识别)的规则。</li><li>将来我们自定义一个类，实现Servlet接口，复写方法。</li></ul><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_07/18.png" srcset="/img/loading.gif" alt=""></p><h2 id="2、快速入门"><a href="#2、快速入门" class="headerlink" title="2、快速入门"></a>2、快速入门</h2><ol><li><p>创建JavaEE项目</p></li><li><p>定义一个类，实现Servlet接口</p><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">ServletDemo1</span> <span class="hljs-symbol">implements</span> <span class="hljs-symbol">Servlet</span></code></pre></div></li><li><p>实现接口中的抽象方法</p></li><li><p>配置Servlet</p></li></ol><div class="hljs"><pre><code class="hljs java">&lt;!--配置Servlet --&gt;&lt;servlet&gt;&lt;servlet-name&gt;demo1&lt;/servlet-name&gt;&lt;servlet-<span class="hljs-class"><span class="hljs-keyword">class</span>&gt;</span><span class="hljs-class">    <span class="hljs-title">cn</span>.<span class="hljs-title">itcast</span>.<span class="hljs-title">web</span>.<span class="hljs-title">servlet</span>.<span class="hljs-title">ServletDemo1</span></span><span class="hljs-class">&lt;/<span class="hljs-title">servlet</span>-<span class="hljs-title">class</span>&gt;</span><span class="hljs-class">&lt;/<span class="hljs-title">servlet</span>&gt;</span><span class="hljs-class"></span><span class="hljs-class">&lt;<span class="hljs-title">servlet</span>-<span class="hljs-title">mapping</span>&gt;</span><span class="hljs-class">&lt;<span class="hljs-title">servlet</span>-<span class="hljs-title">name</span>&gt;<span class="hljs-title">demo1</span>&lt;/<span class="hljs-title">servlet</span>-<span class="hljs-title">name</span>&gt;</span><span class="hljs-class">&lt;<span class="hljs-title">url</span>-<span class="hljs-title">pattern</span>&gt;/<span class="hljs-title">demo1</span>&lt;/<span class="hljs-title">url</span>-<span class="hljs-title">pattern</span>&gt;</span><span class="hljs-class">&lt;/<span class="hljs-title">servlet</span>-<span class="hljs-title">mapping</span>&gt;</span></code></pre></div><h2 id="3、执行原理"><a href="#3、执行原理" class="headerlink" title="3、执行原理"></a>3、执行原理</h2><ol><li>当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径</li><li>查找web.xml文件，是否有对应的<code>&lt;url-pattern&gt;</code>标签体内容。</li><li>如果有，则在找到对应的<code>&lt;servlet-class&gt;</code>全类名</li><li>tomcat会将字节码文件加载进内存，并且创建其对象</li><li>调用其方法</li></ol><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_07/19.png" srcset="/img/loading.gif" alt=""></p><h2 id="4、Servlet中的生命周期方法"><a href="#4、Servlet中的生命周期方法" class="headerlink" title="4、Servlet中的生命周期方法"></a>4、Servlet中的生命周期方法</h2><ol><li><p>被创建：执行init方法，只执行一次</p><ul><li><p>Servlet什么时候被创建？</p><ol><li><p>默认情况下，第一次被访问时，Servlet被创建</p></li><li><p>可以配置执行Servlet的创建时机</p><ul><li>在<code>&lt;servlet&gt;</code>标签下配置<ol><li>第一次被访问时，创建<code>&lt;load-on-startup&gt;</code>的值为负数</li><li>在服务器启动时，创建<code>&lt;load-on-startup&gt;</code>的值为0或正整数</li></ol></li></ul></li></ol></li><li><p>Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的</p><ul><li>多个用户同时访问时，可能存在线程安全问题</li><li>解决：尽量不要在Servlet中定义成员变量。即使定义了成员变量，也不要对修改值</li></ul></li></ul></li><li><p>提供服务：执行service方法，执行多次</p><ul><li>每次访问Servlet时，Service方法都会被调用一次</li></ul></li><li><p>被销毁：执行destroy方法，只执行一次</p><ul><li>Servlet被销毁时执行。服务器关闭时，Servlet被销毁</li><li>只有服务器正常关闭时，才会执行destroy方法</li><li>destroy方法在Servlet被销毁之前执行，一般用于释放资源</li></ul></li></ol><h2 id="5、Servlet3-0"><a href="#5、Servlet3-0" class="headerlink" title="5、Servlet3.0"></a>5、Servlet3.0</h2><ul><li>好处<ul><li>支持注解配置。可以不需要web.xml了</li></ul></li><li>步骤<ol><li>创建JavaEE项目，选择Servlet的版本3.0以上，可以不创建web.xml</li><li>定义一个类，实现Servlet接口</li><li>复写方法</li><li>在类上使用@WebServlet注解，进行配置<code>@WebServlet(&quot;资源路径&quot;)</code></li></ol></li></ul><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Target</span>(&#123;ElementType.TYPE&#125;)<span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)<span class="hljs-meta">@Documented</span><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> WebServlet &#123;<span class="hljs-comment">//相当于&lt;Servlet-name&gt;</span><span class="hljs-function">String <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> ""</span>;<span class="hljs-comment">//代表urlPatterns()属性配置</span>String[] value() <span class="hljs-keyword">default</span> &#123;&#125;;        <span class="hljs-comment">//相当于&lt;url-pattern&gt;</span>String[] urlPatterns() <span class="hljs-keyword">default</span> &#123;&#125;;<span class="hljs-comment">//相当于&lt;load-on-startup&gt;</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">loadOnStartup</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> -1</span>;WebInitParam[] initParams() <span class="hljs-keyword">default</span> &#123;&#125;;<span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">asyncSupported</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">false</span></span>;<span class="hljs-function">String <span class="hljs-title">smallIcon</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> ""</span>;<span class="hljs-function">String <span class="hljs-title">largeIcon</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> ""</span>;<span class="hljs-function">String <span class="hljs-title">description</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> ""</span>;<span class="hljs-function">String <span class="hljs-title">displayName</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> ""</span>;&#125;</code></pre></div><blockquote><p>虚拟目录：访问项目的方法</p><p>资源路径：访问项目里的具体资源</p></blockquote><h2 id="6、IDEA与tomcat的相关配置"><a href="#6、IDEA与tomcat的相关配置" class="headerlink" title="6、IDEA与tomcat的相关配置"></a>6、IDEA与tomcat的相关配置</h2><ol><li>IDEA会为每一个tomcat部署的项目单独建立一份配置文件<ul><li>查看控制台的log：Using CATALINA_BASE:   “C:\Users\fqy.IntelliJIdea2018.1\system\tomcat_itcast”</li></ul></li><li>工作空间项目    和     tomcat部署的web项目<ul><li>tomcat真正访问的是<code>tomcat部署的web项目</code>。<code>tomcat部署的web项目</code>对应着<code>工作空间项目</code> 的web目录下的所有资源</li><li>WEB-INF目录下的资源不能被浏览器直接访问。</li></ul></li><li>断点调试：使用”小虫子”启动 dubug 启动</li></ol><h2 id="7、体系结构"><a href="#7、体系结构" class="headerlink" title="7、体系结构"></a>7、体系结构</h2><p><code>Servlet</code>– 接口<br>⬇<br><code>GenericServlet</code>– 抽象类<br>⬇<br><code>HttpServlet</code> – 抽象类</p><ul><li><p>GenericServlet：将Servlet接口中其他的方法做了默认空实现，只将service()方法作为抽象</p><ul><li>将来定义Servlet类时，可以继承GenericServlet，实现service()方法即可</li></ul></li><li><p>HttpServlet：对http协议的一种封装，简化操作</p><ol><li>定义类继承HttpServlet</li><li>复写doGet/doPost方法</li></ol></li></ul><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_07/20.png" srcset="/img/loading.gif" alt=""></p><h2 id="8、urlpartten相关配置"><a href="#8、urlpartten相关配置" class="headerlink" title="8、urlpartten相关配置"></a>8、urlpartten相关配置</h2><p>urlpartten：Servlet访问路径</p><ol><li>一个Servlet可以定义多个访问路径 ：<code>@WebServlet({&quot;/d4&quot;,&quot;/dd4&quot;,&quot;/ddd4&quot;})</code></li><li>路径定义规则：<ol><li><code>/xxx</code>路径匹配</li><li><code>/xxx/xxx</code>多层路径，目录结构</li><li><code>*.do</code>扩展名匹配</li></ol></li></ol><h1 id="二-HTTP-请求消息"><a href="#二-HTTP-请求消息" class="headerlink" title="二.HTTP-请求消息"></a>二.HTTP-请求消息</h1><h2 id="1、概念-1"><a href="#1、概念-1" class="headerlink" title="1、概念"></a>1、概念</h2><p>Hyper Text Transfer Protocol 超文本传输协议</p><ul><li>传输协议：定义了，客户端和服务器端通信时，发送数据的格式</li><li>特点：<ol><li>基于TCP/IP的高级协议，所以也是安全传输的</li><li>默认端口号：80</li><li>基于请求/响应模型的：一次请求对应一次响应</li><li>无状态的：每次请求之间相互独立，不能交互数据</li></ol></li><li>历史版本：<ul><li>1.0：每一次请求响应都会建立新的连接</li><li>1.1：复用连接</li></ul></li><li>请求消息：客户端发送给服务器端的数据</li><li>响应消息：服务器端发送给客户端的数据</li></ul><h2 id="2、数据格式"><a href="#2、数据格式" class="headerlink" title="2、数据格式"></a>2、数据格式</h2><h3 id="2-1请求行"><a href="#2-1请求行" class="headerlink" title="2.1请求行"></a>2.1请求行</h3><ul><li><p>格式：<code>请求方式 请求url 请求协议/版本</code><br>GET /login.html    HTTP/1.1</p></li><li><p>请求方式</p><ul><li>HTTP协议有7中请求方式，常用的有2种<ul><li>GET：<ol><li>请求参数在请求行中，在url后。</li><li>请求的url长度有限制的</li><li>不太安全</li></ol></li><li>POST：<ol><li>请求参数在请求体中</li><li>请求的url长度没有限制的</li><li>相对安全</li></ol></li></ul></li></ul></li></ul><h3 id="2-2请求头"><a href="#2-2请求头" class="headerlink" title="2.2请求头"></a>2.2请求头</h3><p>客户端浏览器告诉服务器一些信息</p><ul><li><p>格式：<code>请求头名称: 请求头值</code></p></li><li><p>常见的请求头：</p><ol><li>User-Agent：浏览器告诉服务器，我访问你使用的浏览器版本信息</li></ol><ul><li>可以在服务器端获取该头的信息，解决浏览器的兼容性问题</li></ul><ol start="2"><li><p>Referer：<a href="http://localhost/login.html" target="_blank" rel="noopener">http://localhost/login.html</a></p><ul><li><p>告诉服务器，我(当前请求)从哪里来？</p><ul><li><p>作用：</p><ol><li><p>防盗链</p></li><li><p>统计工作</p></li></ol></li></ul></li></ul></li></ol></li></ul><p>防盗链示意图：</p><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_07/21.png" srcset="/img/loading.gif" alt=""></p><h3 id="2-3请求空行"><a href="#2-3请求空行" class="headerlink" title="2.3请求空行"></a>2.3请求空行</h3><p>空行，就是用于分割POST请求的请求头，和请求体的。</p><h3 id="2-4请求体"><a href="#2-4请求体" class="headerlink" title="2.4请求体"></a>2.4请求体</h3><p>正文</p><ul><li>封装POST请求消息的请求参数的</li></ul><h2 id="3、字符串格式"><a href="#3、字符串格式" class="headerlink" title="3、字符串格式"></a>3、字符串格式</h2><div class="hljs"><pre><code class="hljs text">POST &#x2F;login.htmlHTTP&#x2F;1.1Host: localhostUser-Agent: Mozilla&#x2F;5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko&#x2F;20100101 Firefox&#x2F;60.0Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2Accept-Encoding: gzip, deflateReferer: http:&#x2F;&#x2F;localhost&#x2F;login.htmlConnection: keep-aliveUpgrade-Insecure-Requests: 1username&#x3D;zhangsan</code></pre></div><h1 id="三-Request对象"><a href="#三-Request对象" class="headerlink" title="三.Request对象"></a>三.Request对象</h1><h2 id="1、request-amp-response对象的原理"><a href="#1、request-amp-response对象的原理" class="headerlink" title="1、request &amp; response对象的原理"></a>1、request &amp; response对象的原理</h2><ol><li>request和response对象是由服务器创建的。我们来使用它们</li><li>request对象是来获取请求消息，response对象是来设置响应消息</li></ol><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_07/22.png" srcset="/img/loading.gif" alt=""></p><h2 id="2、request对象继承体系结构"><a href="#2、request对象继承体系结构" class="headerlink" title="2、request对象继承体系结构"></a>2、request对象继承体系结构</h2><p>ServletRequest        –    接口<br>    ⬇    继承<br>HttpServletRequest    – 接口<br>    ⬇    实现<br>org.apache.catalina.connector.RequestFacade 类(tomcat)</p><h2 id="3、request功能"><a href="#3、request功能" class="headerlink" title="3、request功能"></a>3、request功能</h2><h3 id="3-1获取请求消息数据"><a href="#3-1获取请求消息数据" class="headerlink" title="3.1获取请求消息数据"></a>3.1获取请求消息数据</h3><ol><li><p>获取请求行数据</p><ul><li><p>GET /day14/demo1?name=zhangsan HTTP/1.1</p></li><li><p>方法：</p><ol><li><p>获取请求方式 ：GET</p><ul><li><code>String getMethod()</code></li></ul></li><li><p><u>获取虚拟目录</u>：/day14</p><ul><li><code>String getContextPath()</code></li></ul></li><li><p>获取Servlet路径: /demo1</p><ul><li><code>String getServletPath()</code></li></ul></li><li><p>获取get方式请求参数：name=zhangsan</p><ul><li><code>String getQueryString()</code></li></ul></li><li><p><u>获取请求URI：</u>/day14/demo1</p><ul><li><p><code>String getRequestURI()</code>：/day14/demo1</p></li><li><p><code>StringBuffer getRequestURL()</code>：<a href="http://localhost/day14/demo1" target="_blank" rel="noopener">http://localhost/day14/demo1</a></p></li><li><p>URL:统一资源定位符 ： <a href="http://localhost/day14/demo1" target="_blank" rel="noopener">http://localhost/day14/demo1</a>    中华人民共和国</p></li><li><p>URI：统一资源标识符 : /day14/demo1                    共和国</p></li></ul></li><li><p>获取协议及版本：HTTP/1.1</p><ul><li><code>String getProtocol()</code></li></ul></li><li><p>获取客户机的IP地址：</p><ul><li><code>String getRemoteAddr()</code></li></ul></li></ol></li></ul></li><li><p>获取请求头数据</p><ul><li>方法<ul><li><code>String getHeader(String name)</code>：<u>通过请求头的名称获取请求头的值</u></li><li><code>Enumeration&lt;String&gt; getHeaderNames()</code>：获取所有的请求头名称</li></ul></li></ul></li><li><p>获取请求体数据</p><ul><li>请求体：只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数</li><li>步骤<ol><li>获取流对象<ul><li><code>BufferedReader getReader()</code>：获取字符输入流，只能操作字符数据</li><li><code>ServletInputStream getInputStream()</code>：获取字节输入流，可以操作所有类型数据（在文件上传知识点后讲解）</li></ul></li><li>再从流对象中拿数据</li></ol></li></ul></li></ol><h3 id="3-2其他功能"><a href="#3-2其他功能" class="headerlink" title="3.2其他功能"></a>3.2其他功能</h3><ol><li>获取请求参数通用方式：不论get还是post请求方式都可以使用下列方法来获取请求参数<ol><li><code>String getParameter(String name)</code>：<u>根据参数名称获取参数值</u>  <ul><li>username=zs&amp;password=123</li></ul></li><li><code>String[] getParameterValues(String name)</code>：根据参数名称获取参数值的数组  <ul><li>hobby=xx&amp;hobby=game</li></ul></li><li><code>Enumeration&lt;String&gt; getParameterNames()</code>：获取所有请求的参数名称</li><li><code>Map&lt;String,String[]&gt; getParameterMap()</code>：<u>获取所有参数的map集合</u></li></ol></li></ol><blockquote><p> 中文乱码问题</p><ul><li>get方式：tomcat 8 已经将get方式乱码问题解决了</li><li>post方式：会乱码<ul><li>解决：在获取参数前，设置request的编码<code>request.setCharacterEncoding(&quot;utf-8&quot;);</code></li></ul></li></ul></blockquote><ol start="2"><li><p>请求转发：一种在服务器内部的资源跳转方式</p><ol><li><p>步骤：</p><ol><li><p>通过request对象获取请求转发器对象：</p><p>  <code>RequestDispatcher getRequestDispatcher(String path)</code></p></li><li><p>使用RequestDispatcher对象来进行转发：</p><p>  <code>forward(ServletRequest request, ServletResponse response)</code></p></li></ol></li><li><p>特点：</p><ol><li>浏览器地址栏路径不发生变化</li><li>只能转发到当前服务器内部资源中。</li><li>转发是一次请求</li></ol></li></ol></li></ol><p>Request请求转发&amp;域对象：</p><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_07/23.png" srcset="/img/loading.gif" alt=""></p><ol start="3"><li><p>共享数据</p><ul><li>域对象：一个有作用范围的对象，可以在范围内共享数据</li><li>request域：代表一次请求的范围，一般用于一次请求转发的多个资源中共享数据</li><li>方法：<ol><li><code>void setAttribute(String name,Object obj)</code>：存储数据</li><li><code>Object getAttitude(String name)</code>：通过键获取值</li><li><code>void removeAttribute(String name)</code>：通过键移除键值对</li></ol></li></ul></li><li><p>获取ServletContext</p><p>  <code>ServletContext getServletContext()</code></p></li></ol><h1 id="四-案例：用户登录"><a href="#四-案例：用户登录" class="headerlink" title="四.案例：用户登录"></a>四.案例：用户登录</h1><ol><li>用户登录案例需求<ul><li>编写login.html登录页面  username &amp; password 两个输入框</li><li>使用Druid数据库连接池技术,操作mysql，day14数据库中user表</li><li>使用JdbcTemplate技术封装JDBC</li><li>登录成功跳转到SuccessServlet展示：登录成功！用户名,欢迎您</li><li>登录失败跳转到FailServlet展示：登录失败，用户名或密码错误</li></ul></li><li>分析</li></ol><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_07/24.png" srcset="/img/loading.gif" alt=""></p><ol start="3"><li><p>开发步骤</p><ol><li><p>创建项目，导入html页面，配置文件，jar包</p></li><li><p>创建数据库环境</p></li></ol><div class="hljs"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">DATABASE</span> day14;<span class="hljs-keyword">USE</span> day14;<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">USER</span>(<span class="hljs-keyword">id</span> <span class="hljs-built_in">INT</span> PRIMARY <span class="hljs-keyword">KEY</span> AUTO_INCREMENT,username <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">UNIQUE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,<span class="hljs-keyword">PASSWORD</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>);</code></pre></div><ol start="3"><li>创建包cn.itcast.domain,创建类User</li></ol><div class="hljs"><pre><code class="hljs arduino">package cn.itcast.domain;<span class="hljs-comment">/**</span><span class="hljs-comment">* 用户的实体类</span><span class="hljs-comment">*/</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> &#123;</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> username;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> password;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> <span class="hljs-title">getUsername</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> username;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUsername</span><span class="hljs-params">(<span class="hljs-keyword">String</span> username)</span> </span>&#123;        <span class="hljs-keyword">this</span>.username = username;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> <span class="hljs-title">getPassword</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> password;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPassword</span><span class="hljs-params">(<span class="hljs-keyword">String</span> password)</span> </span>&#123;        <span class="hljs-keyword">this</span>.password = password;    &#125;    @Override    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"User&#123;"</span> +            <span class="hljs-string">"id="</span> + id +            <span class="hljs-string">", username='"</span> + username + <span class="hljs-string">'\''</span> +            <span class="hljs-string">", password='"</span> + password + <span class="hljs-string">'\''</span> +            <span class="hljs-string">'&#125;'</span>;   &#125;&#125;</code></pre></div><ol start="4"><li>创建包cn.itcast.util,编写工具类JDBCUtils</li></ol><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.util;<span class="hljs-keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;<span class="hljs-keyword">import</span> javax.sql.DataSource;<span class="hljs-keyword">import</span> javax.xml.crypto.Data;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.io.InputStream;<span class="hljs-keyword">import</span> java.sql.Connection;<span class="hljs-keyword">import</span> java.sql.SQLException;<span class="hljs-keyword">import</span> java.util.Properties;<span class="hljs-comment">/**</span><span class="hljs-comment"> * JDBC工具类 使用Durid连接池</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JDBCUtils</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> DataSource ds ;    <span class="hljs-keyword">static</span> &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//1.加载配置文件</span>            Properties pro = <span class="hljs-keyword">new</span> Properties();            <span class="hljs-comment">//使用ClassLoader加载配置文件，获取字节输入流</span>            InputStream is = JDBCUtils<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getClassLoader</span>()</span>                .getResourceAsStream("druid.properties");            pro.load(is);            <span class="hljs-comment">//2.初始化连接池对象</span>            ds = DruidDataSourceFactory.createDataSource(pro);        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取连接池对象</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DataSource <span class="hljs-title">getDataSource</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> ds;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">  *获取连接Connection对象</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;        <span class="hljs-keyword">return</span>  ds.getConnection();    &#125;&#125;</code></pre></div><ol start="5"><li>创建包cn.itcast.dao,创建类UserDao,提供login方法</li></ol><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.dao;<span class="hljs-keyword">import</span> cn.itcast.domain.User;<span class="hljs-keyword">import</span> cn.itcast.util.JDBCUtils;<span class="hljs-keyword">import</span> org.springframework.dao.DataAccessException;<span class="hljs-keyword">import</span> org.springframework.jdbc.core.BeanPropertyRowMapper;<span class="hljs-keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 操作数据库中User表的类</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDao</span> </span>&#123;    <span class="hljs-comment">//声明JDBCTemplate对象共用</span>    <span class="hljs-keyword">private</span> JdbcTemplate template = <span class="hljs-keyword">new</span> JdbcTemplate(JDBCUtils.getDataSource());    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 登录方法</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> loginUser 只有用户名和密码</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> user包含用户全部数据,没有查询到，返回null</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">login</span><span class="hljs-params">(User loginUser)</span></span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//1.编写sql</span>            String sql = <span class="hljs-string">"select * from user where username = ? and password = ?"</span>;            <span class="hljs-comment">//2.调用query方法</span>            User user = template.queryForObject(sql,                    <span class="hljs-keyword">new</span> BeanPropertyRowMapper&lt;User&gt;(User<span class="hljs-class">.<span class="hljs-keyword">class</span>),</span><span class="hljs-class">                    <span class="hljs-title">loginUser</span>.<span class="hljs-title">getUsername</span>(), <span class="hljs-title">loginUser</span>.<span class="hljs-title">getPassword</span>())</span>;                <span class="hljs-keyword">return</span> user;        &#125; <span class="hljs-keyword">catch</span> (DataAccessException e) &#123;            e.printStackTrace();<span class="hljs-comment">//记录日志</span>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;    &#125;&#125;</code></pre></div><ol start="6"><li>编写cn.itcast.web.servlet.LoginServlet类</li></ol><div class="hljs"><pre><code class="hljs scala"><span class="hljs-keyword">package</span> cn.itcast.web.servlet;<span class="hljs-keyword">import</span> cn.itcast.dao.<span class="hljs-type">UserDao</span>;<span class="hljs-keyword">import</span> cn.itcast.domain.<span class="hljs-type">User</span>;<span class="hljs-keyword">import</span> javax.servlet.<span class="hljs-type">ServletException</span>;<span class="hljs-keyword">import</span> javax.servlet.annotation.<span class="hljs-type">WebServlet</span>;<span class="hljs-keyword">import</span> javax.servlet.http.<span class="hljs-type">HttpServlet</span>;<span class="hljs-keyword">import</span> javax.servlet.http.<span class="hljs-type">HttpServletRequest</span>;<span class="hljs-keyword">import</span> javax.servlet.http.<span class="hljs-type">HttpServletResponse</span>;<span class="hljs-keyword">import</span> java.io.<span class="hljs-type">IOException</span>;<span class="hljs-meta">@WebServlet</span>(<span class="hljs-string">"/loginServlet"</span>)public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> void doGet(<span class="hljs-type">HttpServletRequest</span> req, <span class="hljs-type">HttpServletResponse</span> resp)     <span class="hljs-keyword">throws</span> <span class="hljs-type">ServletException</span>, <span class="hljs-type">IOException</span> &#123;        <span class="hljs-comment">//1.设置编码</span>    req.setCharacterEncoding(<span class="hljs-string">"utf-8"</span>);        <span class="hljs-comment">//2.获取请求参数        </span>    <span class="hljs-type">String</span> username = req.getParameter(<span class="hljs-string">"username"</span>);    <span class="hljs-type">String</span> password = req.getParameter(<span class="hljs-string">"password"</span>);        <span class="hljs-comment">//3.封装user对象</span>    <span class="hljs-type">User</span> loginUser = <span class="hljs-keyword">new</span> <span class="hljs-type">User</span>();    loginUser.setUsername(username);    loginUser.setPassword(password);        <span class="hljs-comment">//4.调用UserDao的login方法</span>    <span class="hljs-type">UserDao</span> dao = <span class="hljs-keyword">new</span> <span class="hljs-type">UserDao</span>();    <span class="hljs-type">User</span> user = dao.login(loginUser);        <span class="hljs-comment">//5.判断user</span>    <span class="hljs-keyword">if</span>(user == <span class="hljs-literal">null</span>)&#123;    <span class="hljs-comment">//登录失败</span>req.getRequestDispatcher(<span class="hljs-string">"/failServlet"</span>).forward(req,resp);    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-comment">//登录成功</span>        <span class="hljs-comment">//存储数据</span>    req.setAttribute(<span class="hljs-string">"user"</span>,user);    <span class="hljs-comment">//转发</span>   req.getRequestDispatcher(<span class="hljs-string">"/successServlet"</span>).forward(req,resp);    &#125;&#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> void doPost(<span class="hljs-type">HttpServletRequest</span> req, <span class="hljs-type">HttpServletResponse</span> resp)     <span class="hljs-keyword">throws</span> <span class="hljs-type">ServletException</span>, <span class="hljs-type">IOException</span> &#123;    <span class="hljs-keyword">this</span>.doGet(req,resp);    &#125;&#125;</code></pre></div><ol start="7"><li>编写FailServlet和SuccessServlet类</li></ol><div class="hljs"><pre><code class="hljs scala"><span class="hljs-meta">@WebServlet</span>(<span class="hljs-string">"/successServlet"</span>)public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SuccessServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-keyword">protected</span> void doPost(<span class="hljs-type">HttpServletRequest</span> request, <span class="hljs-type">HttpServletResponse</span> response)     <span class="hljs-keyword">throws</span> <span class="hljs-type">ServletException</span>, <span class="hljs-type">IOException</span> &#123;        <span class="hljs-comment">//获取request域中共享的user对象</span>        <span class="hljs-type">User</span> user = (<span class="hljs-type">User</span>) request.getAttribute(<span class="hljs-string">"user"</span>);        <span class="hljs-keyword">if</span>(user != <span class="hljs-literal">null</span>)&#123;            <span class="hljs-comment">//给页面写一句话</span>            <span class="hljs-comment">//设置编码</span>            response.setContentType(<span class="hljs-string">"text/html;charset=utf-8"</span>);            <span class="hljs-comment">//输出</span>            response.getWriter().write(<span class="hljs-string">"登录成功！"</span>+user.getUsername()+<span class="hljs-string">",欢迎您"</span>);        &#125;&#125;    <span class="hljs-meta">@WebServlet</span>(<span class="hljs-string">"/failServlet"</span>)public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FailServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;    <span class="hljs-keyword">protected</span> void doPost(<span class="hljs-type">HttpServletRequest</span> request, <span class="hljs-type">HttpServletResponse</span> response)     <span class="hljs-keyword">throws</span> <span class="hljs-type">ServletException</span>, <span class="hljs-type">IOException</span> &#123;        <span class="hljs-comment">//给页面写一句话</span>        <span class="hljs-comment">//设置编码</span>        response.setContentType(<span class="hljs-string">"text/html;charset=utf-8"</span>);        <span class="hljs-comment">//输出</span>        response.getWriter().write(<span class="hljs-string">"登录失败，用户名或密码错误"</span>);    &#125;    <span class="hljs-keyword">protected</span> void doGet(<span class="hljs-type">HttpServletRequest</span> request, <span class="hljs-type">HttpServletResponse</span> response)     <span class="hljs-keyword">throws</span> <span class="hljs-type">ServletException</span>, <span class="hljs-type">IOException</span> &#123;        <span class="hljs-keyword">this</span>.doPost(request,response);    &#125;&#125;</code></pre></div><ol start="8"><li>login.html中form表单的action路径的写法</li></ol><ul><li>虚拟目录 + Servlet的资源路径</li></ul><ol start="9"><li><p>BeanUtils工具类，简化数据封装</p><ul><li>用于封装JavaBean的</li></ul><ol><li><p>JavaBean：标准的Java类</p><ul><li><p>要求</p><ol><li>类必须被public修饰</li><li>必须提供空参的构造器</li><li>成员变量必须使用private修饰</li><li>提供公共setter和getter方法</li></ol></li><li><p>功能：封装数据</p></li></ul></li><li><p>概念</p><ul><li>成员变量：<ul><li>例如：id、username、password</li></ul></li><li>属性：setter和getter方法截取后的产物<ul><li>例如：getUsername() –&gt; Username–&gt; username</li></ul></li></ul></li><li><p>方法：</p><ul><li><p><code>setProperty()</code>：设置属性值</p></li><li><p><code>getProperty()</code>：获得属性值</p></li><li><p><code>populate(Object obj , Map map)</code>：<u>将map集合的键值对信息，封装到对应的JavaBean对象中</u></p><blockquote><p>前两种方法的参数都是属性而不是成员变量</p></blockquote></li></ul></li></ol></li></ol></li></ol><h1 id="五-HTTP-响应消息"><a href="#五-HTTP-响应消息" class="headerlink" title="五.HTTP-响应消息"></a>五.HTTP-响应消息</h1><h2 id="1、数据格式"><a href="#1、数据格式" class="headerlink" title="1、数据格式"></a>1、数据格式</h2><h3 id="2-1响应行"><a href="#2-1响应行" class="headerlink" title="2.1响应行"></a>2.1响应行</h3><ul><li>组成：协议/版本   响应状态码   状态码描述</li><li>响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态<ol><li>状态码都是3位数字 </li><li>分类<ul><li>1xx：服务器就收客户端消息，但没有接受完成，等待一段时间后，发送1xx多状态码</li><li>2xx：成功<ul><li>代表：200</li></ul></li><li>3xx：重定向<ul><li>代表：302(重定向)，304(访问缓存)</li></ul></li><li>4xx：客户端错误<ul><li>代表<ol><li>404：请求路径没有对应的资源 </li><li>405：请求方式没有对应的doXxx方法</li></ol></li></ul></li><li>5xx：服务器端错误。代表：500(服务器内部出现异常)</li></ul></li></ol></li></ul><p>重定向示意图：</p><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_07/25.png" srcset="/img/loading.gif" alt=""></p><p>访问缓存示意图：</p><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_07/26.png" srcset="/img/loading.gif" alt=""></p><h3 id="2-2响应头"><a href="#2-2响应头" class="headerlink" title="2.2响应头"></a>2.2响应头</h3><ul><li><p>格式：头名称： 值</p></li><li><p>常见的响应头</p><ol><li>Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式</li><li>Content-disposition：服务器告诉客户端以什么格式打开响应体数据<ul><li>值<ol><li>in-line:默认值,在当前页面内打开</li><li>attachment ; filename=xxx：以附件形式打开响应体。文件下载</li></ol></li></ul></li></ol></li></ul><h3 id="2-3响应空行"><a href="#2-3响应空行" class="headerlink" title="2.3响应空行"></a>2.3响应空行</h3><h3 id="2-4响应体"><a href="#2-4响应体" class="headerlink" title="2.4响应体"></a>2.4响应体</h3><p>传输的数据</p><h2 id="2、字符串格式"><a href="#2、字符串格式" class="headerlink" title="2、字符串格式"></a>2、字符串格式</h2><div class="hljs"><pre><code class="hljs text">HTTP&#x2F;1.1 200 OKContent-Type: text&#x2F;html;charset&#x3D;UTF-8Content-Length: 101Date: Wed, 06 Jun 2018 07:08:42 GMT&lt;html&gt;  &lt;head&gt;    &lt;title&gt;$Title$&lt;&#x2F;title&gt;  &lt;&#x2F;head&gt;  &lt;body&gt;  hello , response  &lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div><h1 id="六-Response对象"><a href="#六-Response对象" class="headerlink" title="六.Response对象"></a>六.Response对象</h1><h2 id="1、功能"><a href="#1、功能" class="headerlink" title="1、功能"></a>1、功能</h2><ol><li><p>设置响应行</p><ul><li>格式：HTTP/1.1 200 ok</li><li>设置状态码：<code>setStatus(int sc)</code></li></ul></li><li><p>设置响应头：<code>setHeader(String name, String value)</code></p></li><li><p>设置响应体：</p><ul><li>使用步骤：<ol><li>获取输出流<ul><li>字符输出流：<code>PrintWriter getWriter()</code></li><li>字节输出流：<code>ServletOutputStream getOutputStream()</code></li></ul></li><li>使用输出流，将数据输出到客户端浏览器</li></ol></li></ul></li></ol><h2 id="2、案例"><a href="#2、案例" class="headerlink" title="2、案例"></a>2、案例</h2><ol><li><p>完成重定向</p><ul><li>重定向：资源跳转的方式</li><li>代码实现</li></ul><div class="hljs"><pre><code class="hljs less"><span class="hljs-comment">//1. 设置状态码为302</span><span class="hljs-selector-tag">response</span><span class="hljs-selector-class">.setStatus</span>(<span class="hljs-number">302</span>);<span class="hljs-comment">//2.设置响应头location</span><span class="hljs-selector-tag">response</span><span class="hljs-selector-class">.setHeader</span>(<span class="hljs-string">"location"</span>,<span class="hljs-string">"/day15/responseDemo2"</span>);<span class="hljs-comment">//简单的重定向方法</span><span class="hljs-selector-tag">response</span><span class="hljs-selector-class">.sendRedirect</span>(<span class="hljs-string">"/day15/responseDemo2"</span>);</code></pre></div><ul><li>重定向的特点:redirect<ol><li>地址栏发生变化</li><li>重定向可以访问其他站点(服务器)的资源</li><li>重定向是两次请求。不能使用request对象来共享数据</li></ol></li><li>转发的特点：forward<ol><li>转发地址栏路径不变</li><li>转发只能访问当前服务器下的资源</li><li>转发是一次请求，可以使用request对象来共享数据</li></ol></li></ul><blockquote><p> forward 和  redirect 区别即转发和重定向的区别</p></blockquote><ul><li><p>路径写法</p><ol><li><p>路径分类</p><ol><li><p>相对路径：通过相对路径不可以确定唯一资源，如：<code>./index.html</code></p><ul><li><p>不以<code>/</code>开头，以<code>.</code>开头路径</p></li><li><p>规则：找到当前资源和目标资源之间的相对位置关系</p><ul><li><code>./</code>当前目录</li><li><code>../</code>后退一级目录</li></ul></li></ul></li><li><p>绝对路径：通过绝对路径可以确定唯一资源，如：<code>http://localhost/day15/responseDemo2/day15/responseDemo2</code></p><ul><li>以<code>/</code>开头的路径</li><li>规则：判断定义的路径是给谁用的？判断请求将来从哪儿发出<ol><li>给客户端浏览器使用：需要加虚拟目录(项目的访问路径<ul><li>建议虚拟目录动态获取：<code>request.getContextPath()</code></li><li><code>&lt;a&gt;</code>、 <code>&lt;form&gt;</code>、 重定向…</li></ul></li><li>给服务器使用：不需要加虚拟目录<ul><li>转发路径</li></ul></li></ol></li></ul></li></ol></li></ol></li></ul></li><li><p>服务器输出字符数据到浏览器</p><ul><li><p>步骤</p><ol><li><p>获取字符输出流</p><p><code>PrintWriter pw = response.getWriter();</code></p></li><li><p>输出数据</p><p><code>pw.write(&quot;你好 response&quot;);</code></p></li></ol></li><li><p>注意</p><ul><li><p>乱码问题</p><ol><li><code>PrintWriter pw = response.getWriter();</code>获取的流的默认编码是ISO-8859-1</li><li>设置该流的默认编码</li><li>告诉浏览器响应体使用的编码</li></ol></li><li><p>解决乱码</p><ul><li><p>简单的形式设置编码：</p><p>在获取流之前设置<code>response.setContentType(&quot;text/html;charset=utf-8&quot;);</code></p></li></ul></li></ul></li></ul></li></ol><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_07/27.png" srcset="/img/loading.gif" alt=""></p><ol start="3"><li><p>服务器输出字节数据到浏览器</p><ul><li><p>步骤</p><ol><li><p>获取字节输出流</p><p><code>ServletOutputSteam sos = response.getOutputStream();</code></p></li><li><p>输出数据</p><p><code>sos.write(&quot;你好&quot;.getBytes());</code></p></li></ol></li><li><p>注意</p><ul><li>也要在获取流之前设置<code>response.setContentType(&quot;text/html;charset=utf-8&quot;);</code></li></ul></li></ul></li><li><p>验证码</p><ol><li>本质：图片</li><li>目的：防止恶意表单注册</li></ol></li></ol><h1 id="七-ServletContext对象"><a href="#七-ServletContext对象" class="headerlink" title="七.ServletContext对象"></a>七.ServletContext对象</h1><ol><li><p>概念：代表整个web应用，可以和程序的容器(服务器)来通信</p></li><li><p>获取</p><ol><li>通过request对象获取<code>request.getServletContext();</code></li><li>通过HttpServlet获取<code>this.getServletContext();</code></li></ol><blockquote><p>这两种方法获取的对象是同一个，地址值相同</p></blockquote></li><li><p>功能</p><ol><li>获取MIME类型<ul><li>MIME类型:在互联网通信过程中定义的一种文件数据类型<ul><li>格式： 大类型/小类型   如：text/html、image/jpeg</li></ul></li><li>获取：<code>String getMimeType(String file)</code></li></ul></li><li>域对象：共享数据<ul><li><code>setAttribute(String name,Object value)</code></li><li><code>getAttribute(String name)</code></li><li><code>removeAttribute(String name)</code></li></ul></li><li>获取文件的真实(服务器)路径</li></ol></li></ol><div class="hljs"><pre><code class="hljs java"><span class="hljs-function">String <span class="hljs-title">getRealPath</span><span class="hljs-params">(String path)</span>  </span><span class="hljs-function">String b </span>= context.getRealPath(<span class="hljs-string">"/b.txt"</span>);<span class="hljs-comment">//web目录下资源访问</span>System.out.println(b);String c = context.getRealPath(<span class="hljs-string">"/WEB-INF/c.txt"</span>);<span class="hljs-comment">//WEB-INF目录下的资源访问</span>System.out.println(c);String a = context.getRealPath(<span class="hljs-string">"/WEB-INF/classes/a.txt"</span>);<span class="hljs-comment">//src目录下的资源访问</span>System.out.println(a);</code></pre></div><h1 id="八-案例：文件下载"><a href="#八-案例：文件下载" class="headerlink" title="八.案例：文件下载"></a>八.案例：文件下载</h1><ul><li><p>文件下载需求</p><ol><li>页面显示超链接</li><li>点击超链接后弹出下载提示框</li><li>完成图片文件下载</li></ol></li><li><p>分析：</p><ol><li>超链接指向的资源如果能够被浏览器解析，则在浏览器中展示，如果不能解析，则弹出下载提示框。不满足需求</li><li>任何资源都必须弹出下载提示框</li><li>使用响应头设置资源的打开方式：<code>content-disposition:attachment;filename=xxx</code></li></ol></li><li><p>步骤</p><ol><li>定义页面，编辑超链接href属性，指向Servlet，传递资源名称filename</li><li>定义Servlet<ul><li>获取文件名称</li><li>使用字节输入流加载文件进内存</li><li>指定response的响应头： <code>content-disposition:attachment;filename=xxx</code></li><li>将数据写出到response输出流</li></ul></li></ol></li><li><p>问题</p><ul><li>中文文件问题<ul><li>解决思路：<ol><li>获取客户端使用的浏览器版本信息</li><li>根据不同的版本信息，设置filename的编码方式不同</li></ol></li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Servlet</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>兔酱碎碎念/生日快乐</title>
    <link href="/2020/07/16/%E5%85%94%E9%85%B1%E7%A2%8E%E7%A2%8E%E5%BF%B5/%E7%94%9F%E6%97%A5%E5%BF%AB%E4%B9%90/"/>
    <url>/2020/07/16/%E5%85%94%E9%85%B1%E7%A2%8E%E7%A2%8E%E5%BF%B5/%E7%94%9F%E6%97%A5%E5%BF%AB%E4%B9%90/</url>
    
    <content type="html"><![CDATA[<p>即将在地球上生活整20年</p><p>20岁在我看来是人生比较重要的一个年龄/分水岭</p><p>倒不是已经发生了什么重要的事情，而是觉得这个数字不一般</p><p>就像18、22一样，我觉得也是比较重要的数字/年龄</p><p><span class="label label-default">ᓚᘏᗢ</span></p><p>今年疫情的原因，生日是在家里过的，饭菜很丰盛</p><p>我的小伙伴们在生日这天都失忆忘记给我祝福了，还是我自己亲自在线讨伐的！疫情害得小伙伴们都待在家里，想不起来还有这么重要的节日了。疫情害人不浅呐 ~  o((&gt;ω&lt; ))o</p><p>早上刚醒就看见妈妈微信祝我生日快乐。怎么说呢，百感交集吧/////…</p>]]></content>
    
    
    <categories>
      
      <category>鱼酱碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Tomcat/Tomcat</title>
    <link href="/2020/07/15/Tomcat/Tomcat/"/>
    <url>/2020/07/15/Tomcat/Tomcat/</url>
    
    <content type="html"><![CDATA[<h1 id="一、web相关概念回顾"><a href="#一、web相关概念回顾" class="headerlink" title="一、web相关概念回顾"></a>一、web相关概念回顾</h1><ol><li><p>软件架构</p><ol><li>C/S：客户端/服务器端</li><li>B/S：浏览器/服务器端</li></ol></li><li><p>资源分类</p><ol><li>静态资源：所有用户访问后，得到的结果都是一样的，称为静态资源.静态资源可以直接被浏览器解析<ul><li>如： html,css,JavaScript</li></ul></li><li>动态资源:每个用户访问相同资源后，得到的结果可能不一样。称为动态资源。动态资源被访问后，需要先转换为静态资源，在返回给浏览器<ul><li>如：servlet/jsp,php,asp….</li></ul></li></ol></li></ol><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_07/17.png" srcset="/img/loading.gif" alt=""></p><ol start="3"><li><p>网络通信三要素</p><ol><li><p>IP：电子设备(计算机)在网络中的唯一标识。</p></li><li><p>端口：应用程序在计算机中的唯一标识。 0~65536</p></li><li><p>传输协议：规定了数据传输的规则</p><ul><li>基础协议：</li></ul><ol><li>tcp:安全协议，三次握手。 速度稍慢</li><li>udp：不安全协议。 速度快</li></ol></li></ol></li></ol><h1 id="二、web服务器软件"><a href="#二、web服务器软件" class="headerlink" title="二、web服务器软件"></a>二、web服务器软件</h1><ul><li><strong>服务器</strong>：安装了服务器软件的计算机</li><li><strong>服务器软件</strong>：接收用户的请求，处理请求，做出响应</li><li><strong>web服务器软件</strong>：接收用户的请求，处理请求，做出响应。<ul><li>在web服务器软件中，可以部署web项目，让用户通过浏览器来访问这些项目</li><li>web容器</li></ul></li><li><strong>常见的java相关的web服务器软件</strong>：<ul><li>webLogic：oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。</li><li>webSphere：IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。</li><li>JBOSS：JBOSS公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。</li><li>Tomcat：Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的JavaEE规范servlet/jsp。开源的，免费的。</li></ul></li><li><strong>JavaEE</strong>：Java语言在企业级开发中使用的技术规范的总和，一共规定了13项大的规范</li></ul><h1 id="三、Tomcat"><a href="#三、Tomcat" class="headerlink" title="三、Tomcat"></a>三、Tomcat</h1><p>web服务器软件</p><ol><li><p>下载：<a href="http://tomcat.apache.org/" target="_blank" rel="noopener">http://tomcat.apache.org/</a></p></li><li><p>安装：解压压缩包即可。</p><ul><li>注意：安装目录建议不要有中文和空格</li></ul></li><li><p>卸载：删除目录就行了</p></li><li><p>启动：</p><ul><li><p>bin/startup.bat ,双击运行该文件即可</p></li><li><p>访问：浏览器输入：<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> 回车访问自己</p><div class="hljs"><pre><code>http://别人的ip:8080 访问别人</code></pre></div></li><li><p>可能遇到的问题：</p><ol><li><p>黑窗口一闪而过：</p><ul><li>原因： 没有正确配置<code>JAVA_HOME</code>环境变量</li><li>解决方案：正确配置<code>JAVA_HOME</code>环境变量</li></ul></li><li><p>启动报错：</p><ol><li><p>暴力：找到占用的端口号，并且找到对应的进程，杀死该进程</p><ul><li>cmd命令行输入<code>netstat -ano</code>可以查看被占用端口号的进程id</li></ul></li><li><p>温柔：修改自身的端口号</p></li></ol><div class="hljs"><pre><code class="hljs xml">conf/server.xml<span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"8888"</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">"HTTP/1.1"</span></span><span class="hljs-tag">    <span class="hljs-attr">connectionTimeout</span>=<span class="hljs-string">"20000"</span></span><span class="hljs-tag">    <span class="hljs-attr">redirectPort</span>=<span class="hljs-string">"8445"</span> /&gt;</span></code></pre></div><ul><li>一般会将tomcat的默认端口号修改为80。80端口号是http协议的默认端口号。<ul><li>好处：在访问时，就不用输入端口号<div class="hljs"><pre><code></code></pre></div></li></ul></li></ul></li></ol></li></ul></li><li><p>关闭：</p><ol><li><p>正常关闭：</p><p>打开<code>bin/shutdown.bat</code>输入<code>ctrl+c</code></p></li><li><p>强制关闭：</p><ul><li>点击启动窗口的×</li></ul></li></ol></li><li><p>配置:</p><ul><li><p>部署项目的方式：</p><ol><li><p>直接将项目放到webapps目录下即可。</p><ul><li>/hello：项目的访问路径–&gt;虚拟目录</li><li>简化部署：将项目打成一个war包，再将war包放置到webapps目录下（war包会自动解压缩）</li></ul></li><li><p>配置conf/server.xml文件</p><p>   在<code>&lt;Host&gt;</code>标签体中配置<code>&lt;Context docBase=&quot;D:\hello&quot; path=&quot;/hehe&quot; /&gt;</code></p><ul><li>docBase:项目存放的路径</li><li>path：虚拟目录</li></ul></li><li><p>在conf\Catalina\localhost创建任意名称的xml文件。在文件中编写<code>&lt;Context docBase=&quot;D:\hello&quot; /&gt;</code></p><ul><li>虚拟目录：xml文件的名称</li></ul></li></ol></li></ul></li></ol><p>Tomcat目录结构:</p><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_07/16.png" srcset="/img/loading.gif" alt=""></p><h1 id="四、-项目目录结构"><a href="#四、-项目目录结构" class="headerlink" title="四、 项目目录结构"></a>四、 项目目录结构</h1><p>java动态项目的目录结构：    </p><p>——项目的根目录<br>————WEB-INF目录<br>——————web.xml：web项目的核心配置文件<br>——————classes目录：放置字节码文件的目录<br>——————lib目录：放置依赖的jar包</p><p>————静态资源，图片等</p><h1 id="五、Tomcat集成到IDEA"><a href="#五、Tomcat集成到IDEA" class="headerlink" title="五、Tomcat集成到IDEA"></a>五、Tomcat集成到IDEA</h1><p>并且创建JavaEE的项目，部署项目</p>]]></content>
    
    
    <categories>
      
      <category>Tomcat</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>BootStrap/BootStrap</title>
    <link href="/2020/07/14/BootStrap/BootStrap/"/>
    <url>/2020/07/14/BootStrap/BootStrap/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Bootstrap"><a href="#一、Bootstrap" class="headerlink" title="一、Bootstrap"></a>一、Bootstrap</h1><ol><li><p>概念： 一个前端开发的框架，Bootstrap，来自 Twitter，是目前很受欢迎的前端框架。Bootstrap 是基于 HTML、CSS、JavaScript 的，它简洁灵活，使得 Web 开发更加快捷。</p><ul><li>框架:一个半成品软件，开发人员可以在框架基础上，在进行开发，简化编码。</li><li>好处：<ol><li>定义了很多的css样式和js插件。我们开发人员直接可以使用这些样式和插件得到丰富的页面效果。</li><li>响应式布局<ul><li>同一套页面可以兼容不同分辨率的设备。</li></ul></li></ol></li></ul></li><li><p>快速入门</p><ol><li>下载Bootstrap</li><li>在项目中将这三个文件夹复制</li><li>创建html页面，引入必要的资源文件</li></ol></li></ol><div class="hljs"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"zh-CN"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"utf-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"X-UA-Compatible"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"IE=edge"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1"</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Bootstrap HelloWorld<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-comment">&lt;!-- Bootstrap --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"css/bootstrap.min.css"</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span>&gt;</span>        <span class="hljs-comment">&lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"js/jquery-3.2.1.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"js/bootstrap.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>你好，世界！<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h1 id="二、响应式布局"><a href="#二、响应式布局" class="headerlink" title="二、响应式布局"></a>二、响应式布局</h1><ul><li><p>同一套页面可以兼容不同分辨率的设备。</p></li><li><p>实现：依赖于栅格系统：将一行平均分成12个格子，可以指定元素占几个格子</p></li><li><p>步骤：</p><ol><li>定义容器。相当于之前的table、<ul><li>容器分类：<ol><li>container：两边留白</li><li>container-fluid：每一种设备都是100%宽度</li></ol></li></ul></li><li>定义行。相当于之前的tr   样式：row</li><li>定义元素。指定该元素在不同的设备上，所占的格子数目。样式：col-设备代号-格子数目<ul><li>设备代号：<ol><li>xs：超小屏幕 手机 (&lt;768px)：col-xs-12</li><li>sm：小屏幕 平板 (≥768px)</li><li>md：中等屏幕 桌面显示器 (≥992px)</li><li>lg：大屏幕 大桌面显示器 (≥1200px)</li></ol></li></ul></li></ol><ul><li>注意：<ol><li>一行中如果格子数目超过12，则超出部分自动换行。</li><li>栅格类属性可以向上兼容。栅格类适用于与屏幕宽度大于或等于分界点大小的设备。</li><li>如果真实设备宽度小于了设置栅格类属性的设备代码的最小值，会一个元素沾满一整行。</li></ol></li></ul></li></ul><h1 id="三、CSS样式和JS插件"><a href="#三、CSS样式和JS插件" class="headerlink" title="三、CSS样式和JS插件"></a>三、CSS样式和JS插件</h1><ol><li><p>全局CSS样式：</p><ul><li><p>按钮：<code>class=&quot;btn btn-default&quot;</code></p></li><li><p>图片</p><ul><li><p>图片在任意尺寸都占100%:<code>class=&quot;img-responsive&quot;</code></p></li><li><p>图片形状</p><ul><li><p>方形:<code>&lt;img src=&quot;...&quot; alt=&quot;...&quot; class=&quot;img-rounded&quot;&gt;</code></p></li><li><p>圆形 :<code>&lt;img src=&quot;...&quot; alt=&quot;...&quot; class=&quot;img-circle&quot;&gt;</code></p></li><li><p>相框:<code>&lt;img src=&quot;...&quot; alt=&quot;...&quot; class=&quot;img-thumbnail&quot;&gt;</code></p></li></ul></li></ul></li><li><p>表格</p><ul><li>table</li><li>table-bordered</li><li>table-hover</li></ul></li><li><p>表单</p><ul><li>给表单项添加：<code>class=&quot;form-control&quot;</code> </li></ul></li></ul></li><li><p>组件：</p><ul><li>导航条</li><li>分页条</li></ul></li><li><p>插件：</p><ul><li>轮播图</li></ul></li></ol><h1 id="四、案例"><a href="#四、案例" class="headerlink" title="四、案例"></a>四、案例</h1><div class="hljs"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"zh-CN"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"utf-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"X-UA-Compatible"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"IE=edge"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1"</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Bootstrap HelloWorld<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-comment">&lt;!-- Bootstrap --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"css/bootstrap.min.css"</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span>&gt;</span></code></pre></div><div class="hljs"><pre><code class="hljs html">    <span class="hljs-comment">&lt;!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"js/jquery-3.2.1.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"js/bootstrap.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">        <span class="hljs-selector-class">.paddtop</span>&#123;</span>            padding-top: 10px;        &#125;<span class="css">        <span class="hljs-selector-class">.search-btn</span>&#123;</span>            float: left;<span class="css">            <span class="hljs-selector-tag">border</span><span class="hljs-selector-pseudo">:1px</span> <span class="hljs-selector-tag">solid</span> <span class="hljs-selector-id">#ffc900</span>;</span>            width: 90px;            height: 35px;<span class="css">            <span class="hljs-selector-tag">background-color</span>:<span class="hljs-selector-id">#ffc900</span> ;</span>            text-align: center;            line-height: 35px;            margin-top: 15px;        &#125;<span class="css">        <span class="hljs-selector-class">.search-input</span>&#123;</span>            float: left;<span class="css">            <span class="hljs-selector-tag">border</span><span class="hljs-selector-pseudo">:2px</span> <span class="hljs-selector-tag">solid</span> <span class="hljs-selector-id">#ffc900</span>;</span>            width: 400px;            height: 35px;            padding-left: 5px;            margin-top: 15px;        &#125;<span class="css">        <span class="hljs-selector-class">.jx</span>&#123;</span><span class="css">            <span class="hljs-selector-tag">border-bottom</span>: 2<span class="hljs-selector-tag">px</span> <span class="hljs-selector-tag">solid</span> <span class="hljs-selector-id">#ffc900</span>;</span>            padding: 5px;        &#125;<span class="css">        <span class="hljs-selector-class">.company</span>&#123;</span>            height: 40px;<span class="css">            <span class="hljs-selector-tag">background-color</span>: <span class="hljs-selector-id">#ffc900</span>;</span>            text-align: center;<span class="css">            <span class="hljs-selector-tag">line-height</span><span class="hljs-selector-pseudo">:40px</span> ;</span>            font-size: 8px;        &#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>   <span class="hljs-comment">&lt;!-- 1.页眉部分--&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">header</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container-fluid"</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"row"</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"img/top_banner.jpg"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"img-responsive"</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"row paddtop"</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col-md-3"</span>&gt;</span>               <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"img/logo.jpg"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"img-responsive"</span>&gt;</span>           <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col-md-5"</span>&gt;</span>               <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"search-input"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"请输入线路名称"</span>&gt;</span>               <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"search-btn"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#"</span>&gt;</span>搜索<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>           <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col-md-4"</span>&gt;</span>               <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"img/hotel_tel.png"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"img-responsive"</span>&gt;</span>           <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>       <span class="hljs-comment">&lt;!--导航栏--&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"row"</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">nav</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"navbar navbar-default"</span>&gt;</span>               <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container-fluid"</span>&gt;</span>                   <span class="hljs-comment">&lt;!-- Brand and toggle get grouped for better mobile display --&gt;</span>                   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"navbar-header"</span>&gt;</span>                       <span class="hljs-comment">&lt;!-- 定义汉堡按钮 --&gt;</span>                       <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"navbar-toggle collapsed"</span> <span class="hljs-attr">data-toggle</span>=<span class="hljs-string">"collapse"</span> <span class="hljs-attr">data-target</span>=<span class="hljs-string">"#bs-example-navbar-collapse-1"</span> <span class="hljs-attr">aria-expanded</span>=<span class="hljs-string">"false"</span>&gt;</span>                           <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"sr-only"</span>&gt;</span>Toggle navigation<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>                           <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"icon-bar"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>                           <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"icon-bar"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>                           <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"icon-bar"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>                       <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>                       <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"navbar-brand"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#"</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>                   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>                   <span class="hljs-comment">&lt;!-- Collect the nav links, forms, and other content for toggling --&gt;</span>                   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"collapse navbar-collapse"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"bs-example-navbar-collapse-1"</span>&gt;</span>                       <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"nav navbar-nav"</span>&gt;</span>                           <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"active"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#"</span>&gt;</span>Link <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"sr-only"</span>&gt;</span>(current)<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>                           <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#"</span>&gt;</span>Link<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>                           <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#"</span>&gt;</span>Link<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>                           <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#"</span>&gt;</span>Link<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>                           <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#"</span>&gt;</span>Link<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>                           <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#"</span>&gt;</span>Link<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>                       <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>                   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-comment">&lt;!-- /.navbar-collapse --&gt;</span>               <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-comment">&lt;!-- /.container-fluid --&gt;</span>           <span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>       <span class="hljs-comment">&lt;!--轮播图--&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"row"</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"carousel-example-generic"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"carousel slide"</span> <span class="hljs-attr">data-ride</span>=<span class="hljs-string">"carousel"</span>&gt;</span>               <span class="hljs-comment">&lt;!-- Indicators --&gt;</span>               <span class="hljs-tag">&lt;<span class="hljs-name">ol</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"carousel-indicators"</span>&gt;</span>                   <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">data-target</span>=<span class="hljs-string">"#carousel-example-generic"</span> <span class="hljs-attr">data-slide-to</span>=<span class="hljs-string">"0"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"active"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>                   <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">data-target</span>=<span class="hljs-string">"#carousel-example-generic"</span> <span class="hljs-attr">data-slide-to</span>=<span class="hljs-string">"1"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>                   <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">data-target</span>=<span class="hljs-string">"#carousel-example-generic"</span> <span class="hljs-attr">data-slide-to</span>=<span class="hljs-string">"2"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>               <span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span>               <span class="hljs-comment">&lt;!-- Wrapper for slides --&gt;</span>               <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"carousel-inner"</span> <span class="hljs-attr">role</span>=<span class="hljs-string">"listbox"</span>&gt;</span>                   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item active"</span>&gt;</span>                       <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"img/banner_1.jpg"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">"..."</span>&gt;</span>                   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>                   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>&gt;</span>                       <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"img/banner_2.jpg"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">"..."</span>&gt;</span>                   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>                   <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>&gt;</span>                       <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"img/banner_3.jpg"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">"..."</span>&gt;</span>                   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>               <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>               <span class="hljs-comment">&lt;!-- Controls --&gt;</span>               <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"left carousel-control"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#carousel-example-generic"</span> <span class="hljs-attr">role</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">data-slide</span>=<span class="hljs-string">"prev"</span>&gt;</span>                   <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"glyphicon glyphicon-chevron-left"</span> <span class="hljs-attr">aria-hidden</span>=<span class="hljs-string">"true"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>                   <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"sr-only"</span>&gt;</span>Previous<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>               <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>               <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"right carousel-control"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#carousel-example-generic"</span> <span class="hljs-attr">role</span>=<span class="hljs-string">"button"</span> <span class="hljs-attr">data-slide</span>=<span class="hljs-string">"next"</span>&gt;</span>                   <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"glyphicon glyphicon-chevron-right"</span> <span class="hljs-attr">aria-hidden</span>=<span class="hljs-string">"true"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>                   <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"sr-only"</span>&gt;</span>Next<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>               <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>           <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="hljs"><pre><code class="hljs html">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><span class="hljs-comment">&lt;!-- 2.主体部分--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"row jx"</span>&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"img/icon_5.jpg"</span>&gt;</span>         <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>黑马精选<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"row paddtop"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col-md-3"</span>&gt;</span>             <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"thumbnail"</span>&gt;</span>                 <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"img/jiangxuan_3.jpg"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">""</span>&gt;</span>                 <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>                 <span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"red"</span>&gt;</span><span class="hljs-symbol">&amp;yen;</span> 699<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span>             <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col-md-3"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"thumbnail"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"img/jiangxuan_3.jpg"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">""</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"red"</span>&gt;</span><span class="hljs-symbol">&amp;yen;</span> 699<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col-md-3"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"thumbnail"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"img/jiangxuan_3.jpg"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">""</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"red"</span>&gt;</span><span class="hljs-symbol">&amp;yen;</span> 699<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col-md-3"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"thumbnail"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"img/jiangxuan_3.jpg"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">""</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"red"</span>&gt;</span><span class="hljs-symbol">&amp;yen;</span> 699<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"row jx"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"img/icon_6.jpg"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>国内游<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"row paddtop"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col-md-4"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"img/guonei_1.jpg"</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col-md-8"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"row"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col-md-4"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"thumbnail"</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"img/jiangxuan_3.jpg"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">""</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"red"</span>&gt;</span><span class="hljs-symbol">&amp;yen;</span> 699<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col-md-4"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"thumbnail"</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"img/jiangxuan_3.jpg"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">""</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"red"</span>&gt;</span><span class="hljs-symbol">&amp;yen;</span> 699<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col-md-4"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"thumbnail"</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"img/jiangxuan_3.jpg"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">""</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"red"</span>&gt;</span><span class="hljs-symbol">&amp;yen;</span> 699<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"row"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col-md-4"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"thumbnail"</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"img/jiangxuan_3.jpg"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">""</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"red"</span>&gt;</span><span class="hljs-symbol">&amp;yen;</span> 699<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col-md-4"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"thumbnail"</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"img/jiangxuan_3.jpg"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">""</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"red"</span>&gt;</span><span class="hljs-symbol">&amp;yen;</span> 699<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"col-md-4"</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"thumbnail"</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"img/jiangxuan_3.jpg"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">""</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">color</span>=<span class="hljs-string">"red"</span>&gt;</span><span class="hljs-symbol">&amp;yen;</span> 699<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="hljs"><pre><code class="hljs html">               <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>           <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>   <span class="hljs-comment">&lt;!-- 3.页脚部分--&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">footer</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container-fluid"</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"row"</span>&gt;</span>           <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"img/footer_service.png"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"img-responsive"</span>&gt;</span>       <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>       <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"row company"</span>&gt;</span>           江苏传智播客教育科技股份有限公司 版权所有Copyright 2006-2018, All Rights Reserved 苏ICP备16007882       <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>​    </p>]]></content>
    
    
    <categories>
      
      <category>BootStrap</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>xml/xml</title>
    <link href="/2020/07/14/xml/xml/"/>
    <url>/2020/07/14/xml/xml/</url>
    
    <content type="html"><![CDATA[<h1 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h1><p>Extensible Markup Language 可扩展标记语言</p><ul><li><p>可扩展：标签都是自定义的。<code>&lt;user&gt; &lt;student&gt;</code></p></li><li><p>功能</p><ul><li>存储数据<ol><li>配置文件</li><li>在网络中传输</li></ol></li></ul></li><li><p>xml与html的区别</p><ol><li>xml标签都是自定义的，html标签是预定义。</li><li>xml的语法严格，html语法松散</li><li>xml是存储数据的，html是展示数据</li></ol></li><li><p>w3c:万维网联盟</p></li></ul><h1 id="二、语法"><a href="#二、语法" class="headerlink" title="二、语法"></a>二、语法</h1><h2 id="1、基本语法："><a href="#1、基本语法：" class="headerlink" title="1、基本语法："></a>1、基本语法：</h2><ol><li>xml文档的后缀名 .xml</li><li>xml第一行必须定义为文档声明</li><li>xml文档中有且仅有一个根标签</li><li>属性值必须使用引号(单双都可)引起来</li><li>标签必须正确关闭</li><li>xml标签名称区分大小写</li></ol><h2 id="2、快速入门"><a href="#2、快速入门" class="headerlink" title="2、快速入门"></a>2、快速入门</h2><div class="hljs"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version='1.0' ?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">users</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">user</span> <span class="hljs-attr">id</span>=<span class="hljs-string">'1'</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>zhangsan<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">age</span>&gt;</span>23<span class="hljs-tag">&lt;/<span class="hljs-name">age</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">gender</span>&gt;</span>male<span class="hljs-tag">&lt;/<span class="hljs-name">gender</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">user</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">user</span> <span class="hljs-attr">id</span>=<span class="hljs-string">'2'</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>lisi<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">age</span>&gt;</span>24<span class="hljs-tag">&lt;/<span class="hljs-name">age</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">gender</span>&gt;</span>female<span class="hljs-tag">&lt;/<span class="hljs-name">gender</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">user</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">users</span>&gt;</span></code></pre></div><h2 id="3、组成部分"><a href="#3、组成部分" class="headerlink" title="3、组成部分"></a>3、组成部分</h2><ol><li><p>文档声明</p><ul><li>格式：<code>&lt;?xml 属性列表 ?&gt;</code></li><li>属性列表：<ul><li>version：版本号，必须的属性</li><li>encoding：编码方式。告知解析引擎当前文档使用的字符集，默认值：ISO-8859-1</li><li>standalone：是否独立<ul><li>取值：<ul><li>yes：不依赖其他文件</li><li>no：依赖其他文件</li></ul></li></ul></li></ul></li></ul></li><li><p>指令(了解)：结合css的</p><p><code>&lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;a.css&quot; ?&gt;</code></p></li><li><p>标签名称（自定义）</p><ul><li>规则：<ol><li>名称可以包含字母、数字以及其他的字符 </li><li>名称不能以数字或者标点符号开始 </li><li>名称不能以字母 xml（或者 XML、Xml 等等）开始 </li><li>名称不能包含空格 </li></ol></li></ul></li><li><p>属性：<br>id属性值唯一</p></li><li><p>文本：</p><ul><li>CDATA区：在该区域中的数据会被原样展示<ul><li>格式：  <code>&lt;![CDATA[ 数据 ]]&gt;</code></li></ul></li></ul></li></ol><h2 id="4、约束"><a href="#4、约束" class="headerlink" title="4、约束"></a>4、约束</h2><p>规定xml文档的书写规则</p><ul><li>作为框架的使用者(程序员)：<ol><li>能够在xml中引入约束文档</li><li>能够简单的读懂约束文档</li></ol></li></ul><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_07/15.png" srcset="/img/loading.gif" alt=""></p><ul><li><p>分类：</p><ol><li><p>DTD:一种简单的约束技术；引入dtd文档到xml文档中</p><ul><li>内部dtd：将约束规则定义在xml文档中</li><li>外部dtd：将约束的规则定义在外部的dtd文件中<ul><li>本地：<code>&lt;!DOCTYPE 根标签名 SYSTEM &quot;dtd文件的位置&quot;&gt;</code></li><li>网络：<code>&lt;!DOCTYPE 根标签名 PUBLIC &quot;dtd文件名字&quot; &quot;dtd文件的位置URL&quot;&gt;</code></li></ul></li></ul></li><li><p>Schema:一种复杂的约束技术</p><ul><li><p>引入：</p><ol><li><p>填写xml文档的根元素</p></li><li><p>引入xsi前缀. </p><p><code>xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</code></p></li><li><p>引入xsd文件命名空间.  </p><p><code>xsi:schemaLocation=&quot;http://www.itcast.cn/xml  student.xsd&quot;</code></p></li><li><p>为每一个xsd约束声明一个前缀,作为标识 </p><p><code>xmlns=&quot;http://www.itcast.cn/xml&quot;</code></p></li></ol></li><li><p>例如</p></li></ul><div class="hljs"><pre><code class="hljs xml">     <span class="hljs-tag">&lt;<span class="hljs-name">students</span>   <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag">     <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.itcast.cn/xml"</span></span><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.itcast.cn/xml  student.xsd"</span>&gt;</span></code></pre></div></li></ol></li></ul><h1 id="三、解析"><a href="#三、解析" class="headerlink" title="三、解析"></a>三、解析</h1><p>操作xml文档，将文档中的数据读取到内存中</p><h2 id="1-操作xml文档"><a href="#1-操作xml文档" class="headerlink" title="1.操作xml文档"></a>1.操作xml文档</h2><ol><li>解析(读取)：将文档中的数据读取到内存中</li><li>写入：将内存中的数据保存到xml文档中。持久化的存储</li></ol><h2 id="2-解析xml的方式："><a href="#2-解析xml的方式：" class="headerlink" title="2.解析xml的方式："></a>2.解析xml的方式：</h2><ol><li>DOM：将标记语言文档一次性加载进内存，在内存中形成一颗dom树<ul><li>优点：操作方便，可以对文档进行CRUD的所有操作</li><li>缺点：占内存</li></ul></li><li>SAX：逐行读取，基于事件驱动的。<ul><li>优点：不占内存。</li><li>缺点：只能读取，不能增删改</li></ul></li></ol><h2 id="3-xml常见的解析器："><a href="#3-xml常见的解析器：" class="headerlink" title="3.xml常见的解析器："></a>3.xml常见的解析器：</h2><ol><li>JAXP：sun公司提供的解析器，支持dom和sax两种思想</li><li>DOM4J：一款非常优秀的解析器</li><li>Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。</li><li>PULL：Android操作系统内置的解析器，sax方式的。</li></ol><h2 id="4-Jsoup"><a href="#4-Jsoup" class="headerlink" title="4.Jsoup"></a>4.Jsoup</h2><p>jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。</p><ol><li>快速入门：<ul><li>步骤<ol><li>导入jar包</li><li>获取Document对象</li><li>获取对应的标签Element对象</li><li>获取数据</li></ol></li><li>代码：</li></ul></li></ol><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//2.获取Document对象，根据xml文档获取</span><span class="hljs-comment">//2.1获取student.xml的path</span>String path = JsoupDemo1.class.getClassLoader().getResource("student.xml").getPath();<span class="hljs-comment">//2.2解析xml文档，加载文档进内存，获取dom树---&gt;Document</span>Document document = Jsoup.parse(<span class="hljs-keyword">new</span> File(path), <span class="hljs-string">"utf-8"</span>);<span class="hljs-comment">//3.获取元素对象 Element</span>Elements elements = document.getElementsByTag(<span class="hljs-string">"name"</span>);System.out.println(elements.size());<span class="hljs-comment">//3.1获取第一个name的Element对象</span>Element element = elements.get(<span class="hljs-number">0</span>);<span class="hljs-comment">//3.2获取数据</span>String name = element.text();System.out.println(name);</code></pre></div><h2 id="5-对象的使用："><a href="#5-对象的使用：" class="headerlink" title="5.对象的使用："></a>5.对象的使用：</h2><ol><li><p>Jsoup：工具类对象。可以解析html或xml文档，返回Document</p><ul><li>parse方法：解析html或xml文档，返回Document；很多重载<ul><li>parse(File in, String charsetName)：解析xml或html文件的。</li><li>parse(String html)：解析xml或html字符串</li><li>parse(URL url, int timeoutMillis)：通过网络路径获取指定的html或xml的文档对象</li></ul></li></ul></li><li><p>Document：文档对象。代表内存中的dom树</p><ul><li>主要是用来获取Element对象<ul><li>getElementById(String id)：根据id属性值获取唯一的element对象</li><li>getElementsByTag(String tagName)：根据标签名称获取元素对象集合</li><li>getElementsByAttribute(String key)：根据属性名称获取元素对象集合</li><li>getElementsByAttributeValue(String key, String value)：根据对应的属性名和属性值获取元素对象集合</li></ul></li></ul></li><li><p>Elements：元素Element对象的集合。可以当做 <code>ArrayList&lt;Element&gt;</code>来使用</p></li><li><p>Element：元素对象</p><ol><li><p>获取子元素对象</p><ul><li>getElementById(String id)：根据id属性值获取唯一的element对象</li><li>getElementsByTag(String tagName)：根据标签名称获取元素对象集合</li><li>getElementsByAttribute(String key)：根据属性名称获取元素对象集合</li><li>getElementsByAttributeValue(String key, String value)：根据对应的属性名和属性值获取元素对象集合</li></ul></li><li><p>获取属性值</p><ul><li>String attr(String key)：根据属性名称获取属性值</li></ul></li><li><p>获取文本内容</p><ul><li>String text():获取文本内容</li><li>String html():获取标签体的所有内容(包括子标签的字符串内容)</li></ul></li></ol></li><li><p>Node：节点对象</p><ul><li>是Document和Element的父 类</li></ul></li></ol><h2 id="6-快捷查询方式"><a href="#6-快捷查询方式" class="headerlink" title="6.快捷查询方式"></a>6.快捷查询方式</h2><ol><li>selector:选择器<ul><li>使用的方法：Elements    select(String cssQuery)</li><li>语法：参考Selector类中定义的语法</li></ul><ol start="2"><li>XPath：XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言</li></ol><ul><li>使用Jsoup的Xpath需要额外导入jar包。</li><li>查询w3cshool参考手册，使用xpath的语法完成查询</li><li>代码：</li></ul></li></ol><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//1.获取student.xml的path</span>        String path = JsoupDemo6.class.getClassLoader().getResource("student.xml").getPath();        <span class="hljs-comment">//2.获取Document对象</span>        Document document = Jsoup.parse(<span class="hljs-keyword">new</span> File(path), <span class="hljs-string">"utf-8"</span>);        <span class="hljs-comment">//3.根据document对象，创建JXDocument对象</span>        JXDocument jxDocument = <span class="hljs-keyword">new</span> JXDocument(document);        <span class="hljs-comment">//4.结合xpath语法查询</span>        <span class="hljs-comment">//4.1查询所有student标签</span>        List&lt;JXNode&gt; jxNodes = jxDocument.selN(<span class="hljs-string">"//student"</span>);        <span class="hljs-keyword">for</span> (JXNode jxNode : jxNodes) &#123;            System.out.println(jxNode);        &#125;        System.out.println(<span class="hljs-string">"--------------------"</span>);        <span class="hljs-comment">//4.2查询所有student标签下的name标签</span>        List&lt;JXNode&gt; jxNodes2 = jxDocument.selN(<span class="hljs-string">"//student/name"</span>);        <span class="hljs-keyword">for</span> (JXNode jxNode : jxNodes2) &#123;            System.out.println(jxNode);        &#125;        System.out.println(<span class="hljs-string">"--------------------"</span>);        <span class="hljs-comment">//4.3查询student标签下带有id属性的name标签</span>        List&lt;JXNode&gt; jxNodes3 = jxDocument.selN(<span class="hljs-string">"//student/name[@id]"</span>);        <span class="hljs-keyword">for</span> (JXNode jxNode : jxNodes3) &#123;            System.out.println(jxNode);        &#125;        System.out.println(<span class="hljs-string">"--------------------"</span>);        <span class="hljs-comment">//4.4查询student标签下带有id属性的name标签 并且id属性值为itcast</span>        List&lt;JXNode&gt; jxNodes4 = jxDocument.selN(<span class="hljs-string">"//student/name[@id='itcast']"</span>);        <span class="hljs-keyword">for</span> (JXNode jxNode : jxNodes4) &#123;            System.out.println(jxNode);        &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>xml</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo/Fluid主题完善</title>
    <link href="/2020/07/13/Hexo/Fluid%E4%B8%BB%E9%A2%98%E5%AE%8C%E5%96%84/"/>
    <url>/2020/07/13/Hexo/Fluid%E4%B8%BB%E9%A2%98%E5%AE%8C%E5%96%84/</url>
    
    <content type="html"><![CDATA[<p><a class="btn" href="https://hexo.fluid-dev.com/docs/guide/#tag-插件" target="_blank" rel="noopener" title="点我跳转啦/3/~">前往Tag插件文档</a></p><h1 id="一、Tag插件"><a href="#一、Tag插件" class="headerlink" title="一、Tag插件"></a>一、Tag插件</h1><h2 id="1、便签"><a href="#1、便签" class="headerlink" title="1、便签"></a>1、便签</h2><ul><li>样式</li></ul><p class="note note-secondary"> 我是标签 QWQ </p><ul><li>代码</li></ul><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"note note-secondary"</span>&gt;</span> 我是标签 QWQ <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre></div><ul><li>可选便签</li></ul><p class="note note-primary"> primary </p><p class="note note-secondary"> secondary </p><p class="note note-success"> success </p><p class="note note-danger"> danger </p><p class="note note-warning"> warning </p><p class="note note-info"> info </p><p class="note note-light"> light </p><h2 id="2、行内标签"><a href="#2、行内标签" class="headerlink" title="2、行内标签"></a>2、行内标签</h2><ul><li>样式</li></ul><p><span class="label label-primary">我是行内的小小标签   OAO</span></p><ul><li>代码</li></ul><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"label label-primary"</span>&gt;</span>我是行内的小小标签   OAO<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></code></pre></div><p><code>可选 Label：primary default info success warning danger</code></p><ul><li>可选便签</li></ul><p><span class="label label-primary">primary </span>  <span class="label label-default ">default</span>    <span class="label label-info ">info </span>  <span class="label label-success ">success </span>  <span class="label label-warning ">warning  </span> <span class="label label-danger">danger</span></p><h2 id="3、勾选框"><a href="#3、勾选框" class="headerlink" title="3、勾选框"></a>3、勾选框</h2><ul><li>样式</li></ul>            <input type="checkbox" disabled checked="checked">我被勾选了 OwO          <ul><li>代码</li></ul><div class="hljs"><pre><code class="hljs html">&#123;% cb text, checked?, incline? %&#125;</code></pre></div><p>内容解释：</p><ul><li>text：显示的文字</li><li>checked：默认是否已勾选，默认 false</li><li>incline: 是否内联（可以理解为后面的文字是否换行），默认 false</li></ul><h2 id="4、按钮"><a href="#4、按钮" class="headerlink" title="4、按钮"></a>4、按钮</h2><ul><li>样式</li></ul><p><a class="btn" href="https://rainbow0526.github.io/" target="_blank" rel="noopener" title="卡哇伊yiyyiyi~">点我可以前往博客首页~    / 3 /</a></p><ul><li>代码格式</li></ul><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"btn"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://rainbow0526.github.io/"</span> <span class="hljs-attr">title</span>=<span class="hljs-string">"卡哇伊yiyyiyi~"</span>&gt;</span>前往博客首页<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></code></pre></div><h1 id="二、文章摘要"><a href="#二、文章摘要" class="headerlink" title="二、文章摘要"></a>二、文章摘要</h1><p> <a href="https://hexo.io/zh-cn/docs/front-matter" target="_blank" rel="noopener">Front-matter</a> 里设置 </p><div class="hljs"><pre><code class="hljs shell">excerpt：摘要文字</code></pre></div><h1 id="三、加速加载"><a href="#三、加速加载" class="headerlink" title="三、加速加载"></a>三、加速加载</h1><h2 id="1、github图片"><a href="#1、github图片" class="headerlink" title="1、github图片"></a>1、github图片</h2><p>使用jsDelivr服务</p><p>使用方法（文件的绝对地址）</p><div class="hljs"><pre><code class="hljs text">https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;user&#x2F;repo@version&#x2F;file</code></pre></div><p>相关实例（博客仓库下 master 分支里 favicon 图片文件）</p><div class="hljs"><pre><code class="hljs text">https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;fluid-dev&#x2F;hexo-theme-fluid@master&#x2F;source&#x2F;img&#x2F;favicon.png</code></pre></div><h2 id="2、加快网页加载"><a href="#2、加快网页加载" class="headerlink" title="2、加快网页加载"></a>2、加快网页加载</h2><ul><li>对于所有用户，将各种第三方库配置公共 CDN 是最有效的方式，可以通过配置 <code>_static_prefix.yml</code> 来链接（默认已经使用 staticfile CDN，国内用户可不做改动）；</li><li>如果你的域名已备案，可以使用<a href="https://portal.qiniu.com/signup?code=1hlwhx3ztjz2q" target="_blank" rel="noopener">七牛云</a>、阿里云、腾讯云等大厂的 OSS 服务并绑定域名，将生成后的 public 目录下全部上传到 OSS，然后你不仅可以无服务器部署博客，加载速度也将无可比拟；</li><li>没有备案，也可以通过香港及海外地区的云，或者私有 CDN 等方式进行加速，推荐一份 <a href="https://www.julydate.com/post/60859300" target="_blank" rel="noopener">CDN 使用指南</a>。</li><li>如果图片是存在 source 目录中，建议搭配 <a href="https://github.com/chenzhutian/hexo-all-minifier" target="_blank" rel="noopener">hexo-all-minifier</a> 插件，可自动对图片进行压缩；</li><li>如果是存放在外部的图片，建议先使用 <a href="https://tinypng.com/" target="_blank" rel="noopener">tinypng</a> 进行压缩。</li></ul><h1 id="四、已实现插件"><a href="#四、已实现插件" class="headerlink" title="四、已实现插件"></a>四、已实现插件</h1><h2 id="1、密码"><a href="#1、密码" class="headerlink" title="1、密码"></a>1、密码</h2><p> <a href="https://hexo.io/zh-cn/docs/front-matter" target="_blank" rel="noopener">Front-matter</a> 里设置 </p><div class="hljs"><pre><code class="hljs shell">password: 131912</code></pre></div><h2 id="2、置顶"><a href="#2、置顶" class="headerlink" title="2、置顶"></a>2、置顶</h2><p> <a href="https://hexo.io/zh-cn/docs/front-matter" target="_blank" rel="noopener">Front-matter</a> 里设置 </p><div class="hljs"><pre><code class="hljs shell">top: True</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>兔酱碎碎念/暑假计划</title>
    <link href="/2020/07/11/%E5%85%94%E9%85%B1%E7%A2%8E%E7%A2%8E%E5%BF%B5/%E6%9A%91%E5%81%87%E8%AE%A1%E5%88%92/"/>
    <url>/2020/07/11/%E5%85%94%E9%85%B1%E7%A2%8E%E7%A2%8E%E5%BF%B5/%E6%9A%91%E5%81%87%E8%AE%A1%E5%88%92/</url>
    
    <content type="html"><![CDATA[<p>开始正式进入为期五十天的暑假。暑假目标：</p><ul><li><p>驾照</p></li><li><p>结束JavaWeb</p></li></ul><p><span class="label label-success">ᓚᘏᗢ</span></p><p>暑假快要结束了，一转眼已经9月2日了，5号晚上就要坐上火车去学校了。目标完成情况：</p><ul><li><p>科二已考过</p></li><li><p>一遍JavaWeb已完成</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>鱼酱碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Javascript/JavaScript</title>
    <link href="/2020/07/10/Javascript/JavaScript/"/>
    <url>/2020/07/10/Javascript/JavaScript/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Javascript简介"><a href="#一、Javascript简介" class="headerlink" title="一、Javascript简介"></a>一、Javascript简介</h1><ul><li><p>概念：    一门客户端脚本语言</p><ul><li>运行在客户端浏览器中的。每一个浏览器都有JavaScript的解析引擎</li><li>脚本语言：不需要编译，直接就可以被浏览器解析执行了</li></ul></li><li><p>功能：</p><ul><li>可以来增强用户和html页面的交互过程，可以来控制html元素，让页面有一些动态的效果，增强用户的体验。</li></ul></li><li><p>JavaScript发展史：</p><ol><li>1992年，Nombase公司，开发出第一门客户端脚本语言，专门用于表单的校验。命名为 ： C–    ，后来更名为：ScriptEase</li><li>1995年，Netscape(网景)公司，开发了一门客户端脚本语言：LiveScript。后来，请来SUN公司的专家，修改LiveScript，命名为JavaScript</li><li>1996年，微软抄袭JavaScript开发出JScript语言</li><li>1997年，ECMA(欧洲计算机制造商协会)，制定出客户端脚本语言的标准：ECMAScript，就是统一了所有客户端脚本语言的编码方式。</li></ol><ul><li>JavaScript = ECMAScript + JavaScript自己特有的东西(BOM+DOM)</li></ul></li></ul><h1 id="二、ECMAScript"><a href="#二、ECMAScript" class="headerlink" title="二、ECMAScript"></a>二、ECMAScript</h1><p>ECMAScript：客户端脚本语言的标准</p><h2 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1. 基本语法"></a>1. 基本语法</h2><ol><li><p>与html结合方式</p><ol><li>内部JS<ul><li>定义<code>&lt;script&gt;</code>，标签体内容就是js代码</li></ul></li><li>外部JS<ul><li>定义<code>&lt;script&gt;</code>，通过src属性引入外部的js文件</li></ul></li><li>注意<ul><li><code>&lt;script&gt;</code>可以定义在html页面的任何地方。但是定义的位置会影响执行顺序。</li><li><code>&lt;script&gt;</code>可以定义多个</li></ul></li></ol></li><li><p>注释</p><ul><li>单行注释：//注释内容</li><li>多行注释：/<em>注释内容</em>/</li></ul></li><li><p>数据类型</p><ol><li>原始数据类型(基本数据类型)：<ul><li>number：数字。 整数/小数/NaN(not a number 一个不是数字的数字类型)</li><li>string：字符串。 字符串  “abc” “a” ‘abc’</li><li>boolean: true和false</li><li>null：一个对象为空的占位符</li><li>undefined：未定义。如果一个变量没有给初始化值，则会被默认赋值为undefined</li></ul></li><li>引用数据类型：对象</li></ol></li><li><p>变量</p><ul><li>变量：一小块存储数据的内存空间</li><li>Java语言是强类型语言，而JavaScript是弱类型语言<ul><li>强类型：在开辟变量存储空间时，定义了空间将来存储的数据的数据类型。只能存储固定类型的数据</li><li>弱类型：在开辟变量存储空间时，不定义空间将来的存储数据类型，可以存放任意类型的数据</li></ul></li><li>语法<ul><li><code>var 变量名 = 初始化值;</code></li></ul></li><li>typeof运算符：获取变量的类型<ul><li>注：null运算后得到的是object</li></ul></li></ul></li><li><p>运算符</p><ol><li><p>元运算符：只有一个运算数的运算符</p><p><code>++，-- ， +(正号)</code></p><ul><li>++ –: 自增(自减)</li><li>+(-)：正负号</li><li>注意：在JS中，如果运算数不是运算符所要求的类型，那么js引擎会自动的将运算数进行类型转换<ul><li>其他类型转number：<ul><li>string转number：按照字面值转换。如果字面值不是数字，则转为NaN（不是数字的数字）</li><li>boolean转number：true转为1，false转为0</li></ul></li></ul></li></ul></li><li><p>算数运算符</p><p><code>+ - * / % ...</code></p></li><li><p>赋值运算符<br><code>= += -+....</code></p></li><li><p>比较运算符<br><code>&gt; &lt; &gt;= &lt;= == ===(全等于)</code></p><ul><li>比较方式<ul><li>类型相同：直接比较<ul><li>字符串：按照字典顺序比较。按位逐一比较，直到得出大小为止</li></ul></li><li>类型不同：先进行类型转换，再比较<ul><li>===：全等于。在比较之前，先判断类型，如果类型不一样，则直接返回false</li></ul></li></ul></li></ul></li><li><p>逻辑运算符<br><code>&amp;&amp; || !</code></p><ul><li>其他类型转boolean：<ol><li>number：0或NaN为假，其他为真</li><li>string：除了空字符串(“”)，其他都是true</li><li>null&amp;undefined:都是false</li><li>对象：所有对象都为true</li></ol></li></ul></li><li><p>三元运算符</p><p><code>? : 表达式</code></p><div class="hljs"><pre><code class="hljs ebnf"><span class="hljs-attribute">var a</span> = 3;<span class="hljs-attribute">var b</span> = 4;<span class="hljs-attribute">var c</span> = a &gt; b ? 1:0;</code></pre></div><ul><li>语法<ul><li>表达式? 值1:值2;</li><li>判断表达式的值，如果是true则取值1，如果是false则取值2；</li></ul></li></ul></li><li><p>流程控制语句</p><ol><li><p>if…else…</p></li><li><p>switch</p><ul><li><p>在java中，switch语句可以接受的数据类型： byte int shor char,枚举(1.5) ,String(1.7)</p>   <div class="hljs"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">switch</span><span class="hljs-params">(变量)</span></span>:case 值:</code></pre></div></li><li><p>在JS中,switch语句可以接受任意的原始数据类型</p></li></ul></li><li><p>while</p></li><li><p>do…while</p></li><li><p>for</p></li></ol></li><li><p>JS特殊语法</p><ol><li>语句以;结尾，如果一行只有一条语句则 ;可以省略 (不建议)</li><li>变量的定义使用var关键字，也可以不使用<ul><li>用： 定义的变量是局部变量</li><li>不用：定义的变量是全局变量(不建议)</li></ul></li></ol></li><li><p>练习：99乘法表</p></li></ol></li></ol><div class="hljs"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>99乘法表<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span>        td&#123;            border: 1px solid;        &#125;    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">        <span class="hljs-built_in">document</span>.write(<span class="hljs-string">"&lt;table  align='center'&gt;"</span>);</span><span class="actionscript">        <span class="hljs-comment">//1.完成基本的for循环嵌套，展示乘法表</span></span><span class="actionscript">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">9</span> ; i++) &#123;</span><span class="javascript">            <span class="hljs-built_in">document</span>.write(<span class="hljs-string">"&lt;tr&gt;"</span>);</span><span class="actionscript">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">1</span>; j &lt;=i ; j++) &#123;</span><span class="javascript">                <span class="hljs-built_in">document</span>.write(<span class="hljs-string">"&lt;td&gt;"</span>);</span><span class="actionscript">                <span class="hljs-comment">//输出  1 * 1 = 1</span></span><span class="javascript">                <span class="hljs-built_in">document</span>.write(i + <span class="hljs-string">" * "</span> + j + <span class="hljs-string">" = "</span> + ( i*j) +<span class="hljs-string">"&amp;nbsp;&amp;nbsp;&amp;nbsp;"</span>);</span><span class="javascript">                <span class="hljs-built_in">document</span>.write(<span class="hljs-string">"&lt;/td&gt;"</span>);</span>            &#125;            /*//输出换行<span class="javascript">            <span class="hljs-built_in">document</span>.write(<span class="hljs-string">"&lt;br&gt;"</span>);*<span class="hljs-regexp">/</span></span><span class="javascript">            <span class="hljs-built_in">document</span>.write(<span class="hljs-string">"&lt;/tr&gt;"</span>);</span>        &#125;<span class="actionscript">        <span class="hljs-comment">//2.完成表格嵌套</span></span><span class="javascript">        <span class="hljs-built_in">document</span>.write(<span class="hljs-string">"&lt;/table&gt;"</span>);</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h2 id="2-基本对象"><a href="#2-基本对象" class="headerlink" title="2.基本对象"></a>2.基本对象</h2><ol><li><p>Function：函数(方法)对象</p><ul><li>创建</li></ul><div class="hljs"><pre><code class="hljs js"><span class="hljs-number">1.</span> <span class="hljs-keyword">var</span> fun = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(形式参数列表,方法体);  <span class="hljs-comment">//忘掉吧</span><span class="hljs-number">2.</span>     <span class="hljs-function"><span class="hljs-keyword">function</span> 方法名称(<span class="hljs-params">形式参数列表</span>)</span>&#123;        方法体    &#125;<span class="hljs-number">3.</span>     <span class="hljs-keyword">var</span> 方法名 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">形式参数列表</span>)</span>&#123;    方法体    &#125;</code></pre></div><ul><li><p>方法</p></li><li><p>属性</p><p> length:代表形参的个数</p></li><li><p>特点</p><ol><li>方法定义是，形参的类型不用写,返回值类型也不写</li><li>方法是一个对象，如果定义名称相同的方法，会覆盖</li><li>在JS中，方法的调用只与方法的名称有关，和参数列表无关</li><li>在方法声明中有一个隐藏的内置对象（数组），arguments,封装所有的实际参数</li></ol></li><li><p>调用</p><p><code>方法名称(实际参数列表);</code></p></li></ul></li><li><p>Array:数组对象</p><ol><li><p>创建：</p><p><code>1. var arr = new Array(元素列表);</code></p><p><code>2. var arr = new Array(默认长度);</code></p><p><code>3. var arr = [元素列表];</code></p></li><li><p>方法</p><ul><li>join(参数):将数组中的元素按照指定的分隔符拼接为字符串</li><li>push()    向数组的末尾添加一个或更多元素，并返回新的长度</li></ul></li><li><p>属性</p><ul><li>length:数组的长度</li></ul></li><li><p>特点</p><ul><li>JS中，数组元素的类型可变的</li><li>JS中，数组长度可变的</li></ul></li></ol></li><li><p>Boolean</p></li><li><p>Date：日期对象</p><ol><li><p>创建</p><p><code>var date = new Date();</code></p></li><li><p>方法</p><ul><li>toLocaleString()：返回当前date对象对应的时间本地字符串格式</li><li>getTime():获取毫秒值。返回当前如期对象描述的时间到1970年1月1日零点的毫秒值差</li></ul></li></ol></li><li><p>Math：数学对象</p><ol><li>创建<ul><li>特点：Math对象不用创建，直接使用<code>Math.方法名();</code></li></ul></li><li>方法<ul><li>random():返回 0 ~ 1 之间的随机数。 含0不含1</li><li>ceil(x)：对数进行上舍入</li><li>floor(x)：对数进行下舍入</li><li>round(x)：把数四舍五入为最接近的整数</li></ul></li><li>属性  PI</li></ol></li><li><p>Number</p></li><li><p>String</p></li><li><p>RegExp：正则表达式对象</p><ol><li><p>正则表达式：定义字符串的组成规则。</p><ul><li><p>单个字符:[]</p><p>如： [a] [ab] [a-zA-Z0-9_]</p><ul><li><p>特殊符号代表特殊含义的单个字符:</p><p>\d:单个数字字符 [0-9]<br>\w:单个单词字符[a-zA-Z0-9_]</p></li></ul></li><li><p>量词符号</p><ol><li>?：表示出现0次或1</li><li>*：表示出现0次或多次</li><li>+：出现1次或多次</li><li>{m,n}:表示 m&lt;= 数量 &lt;= n<ul><li>m如果缺省： {,n}:最多n次</li><li>n如果缺省：{m,} 最少m次</li></ul></li></ol></li><li><p>开始结束符号</p><ul><li>^:开始</li><li>$:结束</li></ul></li></ul></li><li><p>正则对象</p><ol><li><p>创建</p><p><code>1. var reg = new RegExp(&quot;正则表达式&quot;);</code></p><p><code>2. var reg = /正则表达式/;</code></p></li><li><p>方法</p><ul><li>test(参数):验证指定的字符串是否符合正则定义的规范</li></ul></li></ol></li></ol></li><li><p>Global</p><ol><li>特点：全局对象，这个Global中封装的方法不需要对象就可以直接调用<code>方法名();</code></li><li>方法</li></ol><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">encodeURI</span>():url编码<span class="hljs-built_in">decodeURI</span>():url解码<span class="hljs-built_in">encodeURIComponent</span>():url编码,编码的字符更多<span class="hljs-built_in">decodeURIComponent</span>():url解码<span class="hljs-built_in">parseInt</span>():将字符串转为数字。逐一判断每一个字符是否是数字，直到不是数字为止，将前边数字部分转为number<span class="hljs-built_in">isNaN</span>():判断一个值是否是<span class="hljs-literal">NaN</span>。<span class="hljs-literal">NaN</span>六亲不认，连自己都不认。<span class="hljs-literal">NaN</span>参与的==比较全部问<span class="hljs-literal">false</span><span class="hljs-built_in">eval</span>():讲 JavaScript 字符串，并把它作为脚本代码来执行。</code></pre></div></li></ol><h1 id="三、BOM"><a href="#三、BOM" class="headerlink" title="三、BOM"></a>三、BOM</h1><ol><li><p>概念：Browser Object Model 浏览器对象模型</p><ul><li>将浏览器的各个组成部分封装成对象。</li></ul></li><li><p>组成：</p><ul><li>Window：窗口对象</li><li>Navigator：浏览器对象</li><li>Screen：显示器屏幕对象</li><li>History：历史记录对象</li><li>Location：地址栏对象</li></ul></li><li><p>Window：窗口对象</p><ol><li><p>创建</p></li><li><p>方法</p><ol><li><p>与弹出框有关的方法：</p><div class="hljs"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">alert</span>()显示带有一段消息和一个确认按钮的警告框</span><span class="hljs-function"></span><span class="hljs-function"><span class="hljs-title">confirm</span>()显示带有一段消息以及确认按钮和取消按钮的对话框。</span><span class="hljs-function">* 如果用户点击确定按钮，则方法返回<span class="hljs-variable"><span class="hljs-literal">true</span></span></span><span class="hljs-function">* 如果用户点击取消按钮，则方法返回<span class="hljs-variable"><span class="hljs-literal">false</span></span></span><span class="hljs-function"></span><span class="hljs-function"><span class="hljs-title">prompt</span>()显示可提示用户输入的对话框。</span><span class="hljs-function">* 返回值：获取用户输入的值</span></code></pre></div></li><li><p>与打开关闭有关的方法：</p><div class="hljs"><pre><code class="hljs gauss"><span class="hljs-built_in">close</span>()关闭浏览器窗口* 谁调用我 ，我关谁<span class="hljs-keyword">open</span>()打开一个新的浏览器窗口* 返回新的<span class="hljs-built_in">Window</span>对象</code></pre></div></li><li><p>与定时器有关的方式</p><div class="hljs"><pre><code class="hljs erlang"><span class="hljs-function"><span class="hljs-title">setTimeout</span><span class="hljs-params">()</span>在指定的毫秒数后调用函数或计算表达式</span><span class="hljs-function">*  参数</span><span class="hljs-function">  1. <span class="hljs-title">js</span>代码或者方法对象</span><span class="hljs-function">  2. 毫秒值</span><span class="hljs-function">* 返回值：唯一标识，用于取消定时器</span><span class="hljs-function"></span><span class="hljs-function"><span class="hljs-title">clearTimeout</span><span class="hljs-params">()</span>取消由 <span class="hljs-title">setTimeout</span><span class="hljs-params">()</span> 方法设置的 <span class="hljs-title">timeout</span></span><span class="hljs-function"></span><span class="hljs-function"><span class="hljs-title">setInterval</span><span class="hljs-params">()</span>按照指定的周期（以毫秒计）来调用函数或计算表达式</span><span class="hljs-function"></span><span class="hljs-function"><span class="hljs-title">clearInterval</span><span class="hljs-params">()</span>取消由 <span class="hljs-title">setInterval</span><span class="hljs-params">()</span> 设置的 <span class="hljs-title">timeout</span></span></code></pre></div></li></ol></li><li><p>属性：</p><ol><li>获取其他BOM对象：<br> history<br> location<br> Navigator<br> Screen:</li><li>获取DOM对象<br> document</li></ol></li><li><p>特点</p><ul><li>Window对象不需要创建可以直接使用 window使用<code>window.方法名();</code></li><li>window引用可以省略<code>方法名();</code></li></ul></li></ol></li><li><p>Location：地址栏对象</p><ol><li><p>创建(获取)：</p><p><code>1.window.location</code></p><p><code>2.location</code></p></li><li><p>方法：</p><p><code>reload()</code>    重新加载当前文档。刷新</p></li><li><p>属性</p><p>href设置或返回完整的 URL。</p></li></ol></li><li><p>History：历史记录对象</p><ol><li><p>创建(获取)：</p><p> <code>1.window.history</code></p><p> <code>2.history</code></p></li><li><p>方法：</p><p> <code>back()</code>    加载 history 列表中的前一个 URL。</p><p> <code>forward()</code>    加载 history 列表中的下一个 URL。</p><p> <code>go(参数)</code>    加载 history 列表中的某个具体页面。</p><ul><li>参数：<ul><li>正数：前进几个历史记录</li><li>负数：后退几个历史记录</li></ul></li></ul></li><li><p>属性：</p><ul><li>length    返回当前窗口历史列表中的 URL 数量。</li></ul></li></ol></li></ol><h1 id="四、DOM"><a href="#四、DOM" class="headerlink" title="四、DOM"></a>四、DOM</h1><ul><li><p>概念： Document Object Model 文档对象模型</p><ul><li>将标记语言文档的各个组成部分，封装为对象。可以使用这些对象，对标记语言文档进行CRUD的动态操作</li></ul></li><li><p>W3C DOM 标准被分为 3 个不同的部分：</p><ul><li><p>核心 DOM - 针对任何结构化文档的标准模型</p><ul><li><p>Document：文档对象</p></li><li><p>Element：元素对象</p></li><li><p>Attribute：属性对象</p></li><li><p>Text：文本对象</p></li><li><p>Comment:注释对象</p></li><li><p>Node：节点对象，其他5个的父对象</p></li></ul></li><li><p>XML DOM - 针对 XML 文档的标准模型</p></li><li><p>HTML DOM - 针对 HTML 文档的标准模型</p></li></ul></li><li><p>核心DOM模型：</p><ul><li><p>Document：文档对象</p><ol><li><p>创建(获取)：在html dom模型中可以使用window对象来获取</p><ol><li>window.document</li><li>document</li></ol></li><li><p>方法：</p><ol><li><p>获取Element对象：</p><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-number">1.</span> getElementById()： 根据id属性值获取元素对象。id属性值一般唯一<span class="hljs-number">2.</span> getElementsByTagName()：根据元素名称获取元素对象们。返回值是一个数组<span class="hljs-number">3.</span> getElementsByClassName():根据Class属性值获取元素对象们。返回值是一个数组<span class="hljs-number">4.</span> getElementsByName(): 根据name属性值获取元素对象们。返回值是一个数组</code></pre></div></li><li><p>创建其他DOM对象：</p><div class="hljs"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">createAttribute</span><span class="hljs-params">(name)</span></span><span class="hljs-function"><span class="hljs-title">createComment</span><span class="hljs-params">()</span></span><span class="hljs-function"><span class="hljs-title">createElement</span><span class="hljs-params">()</span></span><span class="hljs-function"><span class="hljs-title">createTextNode</span><span class="hljs-params">()</span></span></code></pre></div></li></ol></li><li><p>属性</p></li></ol></li><li><p>Element：元素对象</p><ol><li><p>获取/创建：通过document来获取和创建</p></li><li><p>方法：</p><p><code>removeAttribute()：删除属性</code></p><p><code>setAttribute()：设置属性</code></p></li></ol></li><li><p>Node：节点对象，其他5个的父对象</p><ul><li><p>特点：所有dom对象都可以被认为是一个节点</p></li><li><p>方法：</p><ul><li>CRUD dom树：<div class="hljs"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">appendChild</span><span class="hljs-params">()</span></span>：向节点的子节点列表的结尾添加新的子节点。<span class="hljs-function"><span class="hljs-title">removeChild</span><span class="hljs-params">()</span></span>：删除（并返回）当前节点的指定子节点。<span class="hljs-function"><span class="hljs-title">replaceChild</span><span class="hljs-params">()</span></span>：用新节点替换一个子节点。</code></pre></div></li></ul></li><li><p>属性：</p><ul><li>parentNode 返回节点的父节点。</li></ul></li></ul></li></ul></li><li><p>HTML DOM</p><ol><li><p>标签体的设置和获取：innerHTML</p></li><li><p>使用html元素对象的属性</p></li><li><p>控制元素样式</p><ol><li><p>使用元素的style属性来设置</p> <div class="hljs"><pre><code class="hljs maxima">//修改样式方式<span class="hljs-number">1</span>div1.<span class="hljs-built_in">style</span>.<span class="hljs-built_in">border</span> = <span class="hljs-string">"1px solid red"</span>;div1.<span class="hljs-built_in">style</span>.<span class="hljs-built_in">width</span> = <span class="hljs-string">"200px"</span>;//<span class="hljs-built_in">font</span>-size--&gt; fontSizediv1.<span class="hljs-built_in">style</span>.fontSize = <span class="hljs-string">"20px"</span>;</code></pre></div></li><li><p>提前定义好类选择器的样式，通过元素的className属性来设置其class属性值。</p></li></ol></li></ol></li></ul><p>DOM树：</p><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_07/14.png" srcset="/img/loading.gif" alt=""></p><h1 id="五、事件监听机制"><a href="#五、事件监听机制" class="headerlink" title="五、事件监听机制"></a>五、事件监听机制</h1><ul><li><p>概念：某些组件被执行了某些操作后，触发某些代码的执行。    </p><ul><li>事件：某些操作。如： 单击，双击，键盘按下了，鼠标移动了</li><li>事件源：组件。如： 按钮 文本输入框…</li><li>监听器：代码。</li><li>注册监听：将事件，事件源，监听器结合在一起。 当事件源上发生了某个事件，则触发执行某个监听器代码。</li></ul></li><li><p>常见的事件：</p><ol><li><p>点击事件：</p><ol><li><code>onclick</code>：单击事件</li><li><code>ondblclick</code>：双击事件</li></ol></li><li><p>焦点事件</p><ol><li><code>onblur</code>：失去焦点</li><li><code>onfocus</code>:元素获得焦点。</li></ol></li><li><p>加载事件：</p><ol><li><code>onload</code>：一张页面或一幅图像完成加载。</li></ol></li><li><p>鼠标事件：</p><ol><li><code>onmousedown</code>    鼠标按钮被按下。</li><li><code>onmouseup</code>    鼠标按键被松开。</li><li><code>onmousemove</code>    鼠标被移动。</li><li><code>onmouseover</code>    鼠标移到某元素之上。</li><li><code>onmouseout</code>    鼠标从某元素移开。</li></ol></li><li><p>键盘事件：</p><ol><li><code>onkeydown</code>    某个键盘按键被按下。    </li><li><code>onkeyup</code>        某个键盘按键被松开。</li><li><code>onkeypress</code>    某个键盘按键被按下并松开。</li></ol></li><li><p>选择和改变</p><ol><li><code>onchange</code>    域的内容被改变。</li><li><code>onselect</code>    文本被选中。</li></ol></li><li><p>表单事件：</p><ol><li><code>onsubmit</code>    确认按钮被点击。</li><li><code>onreset</code>    重置按钮被点击。</li></ol></li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JDBC/JDBC</title>
    <link href="/2020/07/07/JDBC/JDBC/"/>
    <url>/2020/07/07/JDBC/JDBC/</url>
    
    <content type="html"><![CDATA[<h1 id="一、JDBC"><a href="#一、JDBC" class="headerlink" title="一、JDBC"></a>一、JDBC</h1><div class="hljs"><pre><code>1. 概念：Java DataBase Connectivity  Java 数据库连接， Java语言操作数据库    * JDBC本质：其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。2. 快速入门：    * 步骤：        1. 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar            1.复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下            2.右键--&gt;Add As Library        2. 注册驱动        3. 获取数据库连接对象 Connection        4. 定义sql        5. 获取执行sql语句的对象 Statement        6. 执行sql，接受返回结果        7. 处理结果        8. 释放资源    * 代码实现：          //1. 导入驱动jar包        //2.注册驱动        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);        //3.获取数据库连接对象        Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/db3&quot;, &quot;root&quot;, &quot;root&quot;);        //4.定义sql语句        String sql = &quot;update account set balance = 500 where id = 1&quot;;        //5.获取执行sql的对象 Statement        Statement stmt = conn.createStatement();        //6.执行sql        int count = stmt.executeUpdate(sql);        //7.处理结果        System.out.println(count);        //8.释放资源        stmt.close();        conn.close();3. 详解各个对象：    1. DriverManager：驱动管理对象        * 功能：            1. 注册驱动：告诉程序该使用哪一个数据库驱动jar                static void registerDriver(Driver driver) :注册与给定的驱动程序 DriverManager 。                 写代码使用：  Class.forName(&quot;com.mysql.jdbc.Driver&quot;);                通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块                 static {                        try {                            java.sql.DriverManager.registerDriver(new Driver());                        } catch (SQLException E) {                            throw new RuntimeException(&quot;Can&apos;t register driver!&quot;);                        }                    }                注意：mysql5之后的驱动jar包可以省略注册驱动的步骤。            2. 获取数据库连接：                * 方法：static Connection getConnection(String url, String user, String password)                 * 参数：                    * url：指定连接的路径                        * 语法：jdbc:mysql://ip地址(域名):端口号/数据库名称                        * 例子：jdbc:mysql://localhost:3306/db3                        * 细节：如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:///数据库名称                    * user：用户名                    * password：密码     2. Connection：数据库连接对象        1. 功能：            1. 获取执行sql 的对象                * Statement createStatement()                * PreparedStatement prepareStatement(String sql)              2. 管理事务：                * 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务                * 提交事务：commit()                 * 回滚事务：rollback()     3. Statement：执行sql的对象        1. 执行sql            1. boolean execute(String sql) ：可以执行任意的sql 了解             2. int executeUpdate(String sql) ：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句                * 返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功 返回值&gt;0的则执行成功，反之，则失败。            3. ResultSet executeQuery(String sql)  ：执行DQL（select)语句        2. 练习：            1. account表 添加一条记录            2. account表 修改记录            3. account表 删除一条记录            代码：                Statement stmt = null;                Connection conn = null;                try {                    //1. 注册驱动                    Class.forName(&quot;com.mysql.jdbc.Driver&quot;);                    //2. 定义sql                    String sql = &quot;insert into account values(null,&apos;王五&apos;,3000)&quot;;                    //3.获取Connection对象                    conn = DriverManager.getConnection(&quot;jdbc:mysql:///db3&quot;, &quot;root&quot;, &quot;root&quot;);                    //4.获取执行sql的对象 Statement                    stmt = conn.createStatement();                    //5.执行sql                    int count = stmt.executeUpdate(sql);//影响的行数                    //6.处理结果                    System.out.println(count);                    if(count &gt; 0){                        System.out.println(&quot;添加成功！&quot;);                    }else{                        System.out.println(&quot;添加失败！&quot;);                    }                } catch (ClassNotFoundException e) {                    e.printStackTrace();                } catch (SQLException e) {                    e.printStackTrace();                }finally {                    //stmt.close();                    //7. 释放资源                    //避免空指针异常                    if(stmt != null){                        try {                            stmt.close();                        } catch (SQLException e) {                            e.printStackTrace();                        }                    }                    if(conn != null){                        try {                            conn.close();                        } catch (SQLException e) {                            e.printStackTrace();                        }                    }                }    4. ResultSet：结果集对象,封装查询结果        * boolean next(): 游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true        * getXxx(参数):获取数据            * Xxx：代表数据类型   如： int getInt() ,    String getString()            * 参数：                1. int：代表列的编号,从1开始   如： getString(1)                2. String：代表列名称。 如： getDouble(&quot;balance&quot;)        * 注意：            * 使用步骤：                1. 游标向下移动一行                2. 判断是否有数据                3. 获取数据               //循环判断游标是否是最后一行末尾。                while(rs.next()){                    //获取数据                    //6.2 获取数据                    int id = rs.getInt(1);                    String name = rs.getString(&quot;name&quot;);                    double balance = rs.getDouble(3);                    System.out.println(id + &quot;---&quot; + name + &quot;---&quot; + balance);                }        * 练习：            * 定义一个方法，查询emp表的数据将其封装为对象，然后装载集合，返回。                1. 定义Emp类                2. 定义方法 public List&lt;Emp&gt; findAll(){}                3. 实现方法 select * from emp;    5. PreparedStatement：执行sql的对象        1. SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题            1. 输入用户随便，输入密码：a&apos; or &apos;a&apos; = &apos;a            2. sql：select * from user where username = &apos;fhdsjkf&apos; and password = &apos;a&apos; or &apos;a&apos; = &apos;a&apos;         2. 解决sql注入问题：使用PreparedStatement对象来解决        3. 预编译的SQL：参数使用?作为占位符        4. 步骤：            1. 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar            2. 注册驱动            3. 获取数据库连接对象 Connection            4. 定义sql                * 注意：sql的参数使用？作为占位符。 如：select * from user where username = ? and password = ?;            5. 获取执行sql语句的对象 PreparedStatement  Connection.prepareStatement(String sql)             6. 给？赋值：                * 方法： setXxx(参数1,参数2)                    * 参数1：？的位置编号 从1 开始                    * 参数2：？的值            7. 执行sql，接受返回结果，不需要传递sql语句            8. 处理结果            9. 释放资源        5. 注意：后期都会使用PreparedStatement来完成增删改查的所有操作            1. 可以防止SQL注入            2. 效率更高</code></pre></div><p>JDBC本质：</p><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_07/12.png" srcset="/img/loading.gif" alt=""></p><h1 id="二、抽取JDBC工具类JDBCUtils"><a href="#二、抽取JDBC工具类JDBCUtils" class="headerlink" title="二、抽取JDBC工具类JDBCUtils"></a>二、抽取JDBC工具类JDBCUtils</h1><div class="hljs"><pre><code>* 目的：简化书写* 分析：    1. 注册驱动也抽取    2. 抽取一个方法获取连接对象        * 需求：不想传递参数（麻烦），还得保证工具类的通用性。        * 解决：配置文件            jdbc.properties                url=                user=                password=</code></pre></div><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-number">3.</span> 抽取一个方法释放资源* 代码实现：public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JDBCUtils</span> </span>&#123;    private <span class="hljs-keyword">static</span> <span class="hljs-built_in">String</span> url;    private <span class="hljs-keyword">static</span> <span class="hljs-built_in">String</span> user;    private <span class="hljs-keyword">static</span> <span class="hljs-built_in">String</span> password;    private <span class="hljs-keyword">static</span> <span class="hljs-built_in">String</span> driver;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 文件的读取，只需要读取一次即可拿到这些值。使用静态代码块</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">static</span>&#123;        <span class="hljs-comment">//读取资源文件，获取值。</span>        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//1. 创建Properties集合类。</span>            Properties pro = <span class="hljs-keyword">new</span> Properties();            <span class="hljs-comment">//获取src路径下的文件的方式---&gt;ClassLoader 类加载器</span>            ClassLoader classLoader = JDBCUtils.class.getClassLoader();            URL res  = classLoader.getResource(<span class="hljs-string">"jdbc.properties"</span>);            <span class="hljs-built_in">String</span> path = res.getPath();            System.out.println(path);<span class="hljs-comment">///D:/IdeaProjects/itcast/out/production/day04_jdbc/jdbc.properties</span>            <span class="hljs-comment">//2. 加载文件</span>           <span class="hljs-comment">// pro.load(new FileReader("D:\\IdeaProjects\\itcast\\day04_jdbc\\src\\jdbc.properties"));</span>            pro.load(<span class="hljs-keyword">new</span> FileReader(path));            <span class="hljs-comment">//3. 获取数据，赋值</span>            url = pro.getProperty(<span class="hljs-string">"url"</span>);            user = pro.getProperty(<span class="hljs-string">"user"</span>);            password = pro.getProperty(<span class="hljs-string">"password"</span>);            driver = pro.getProperty(<span class="hljs-string">"driver"</span>);            <span class="hljs-comment">//4. 注册驱动</span>            Class.forName(driver);        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125;    &#125;</code></pre></div><div class="hljs"><pre><code class="hljs javascript">    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 释放资源</span><span class="hljs-comment">     * <span class="hljs-doctag">@param <span class="hljs-variable">stmt</span></span></span><span class="hljs-comment">     * <span class="hljs-doctag">@param <span class="hljs-variable">conn</span></span></span><span class="hljs-comment">     */</span>    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> close(ResultSet rs,Statement stmt, Connection conn)&#123;        <span class="hljs-keyword">if</span>( rs != <span class="hljs-literal">null</span>)&#123;            <span class="hljs-keyword">try</span> &#123;                rs.close();            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;                e.printStackTrace();            &#125;        &#125;        <span class="hljs-keyword">if</span>( stmt != <span class="hljs-literal">null</span>)&#123;            <span class="hljs-keyword">try</span> &#123;                stmt.close();            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;                e.printStackTrace();            &#125;        &#125;        <span class="hljs-keyword">if</span>( conn != <span class="hljs-literal">null</span>)&#123;            <span class="hljs-keyword">try</span> &#123;                conn.close();            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs javascript">练习：* 需求：  <span class="hljs-number">1.</span> 通过键盘录入用户名和密码   <span class="hljs-number">2.</span> 判断用户是否登录成功       * select * <span class="hljs-keyword">from</span> user where username = <span class="hljs-string">""</span> and password = <span class="hljs-string">""</span>;         * 如果这个sql有查询结果，则成功，反之，则失败                  * 步骤：<span class="hljs-number">1.</span> 创建数据库表 userCREATE TABLE USER(id INT PRIMARY KEY AUTO_INCREMENT,username VARCHAR(<span class="hljs-number">32</span>),PASSWORD VARCHAR(<span class="hljs-number">32</span>));INSERT INTO USER VALUES(NULL,<span class="hljs-string">'zhangsan'</span>,<span class="hljs-string">'123'</span>);INSERT INTO USER VALUES(NULL,<span class="hljs-string">'lisi'</span>,<span class="hljs-string">'234'</span>);<span class="hljs-number">2.</span> 代码实现：public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JDBCDemo9</span> </span>&#123;    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-built_in">String</span>[] args) &#123;        <span class="hljs-comment">//1.键盘录入，接受用户名和密码</span>        Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);        System.out.println(<span class="hljs-string">"请输入用户名："</span>);        <span class="hljs-built_in">String</span> username = sc.nextLine();        System.out.println(<span class="hljs-string">"请输入密码："</span>);        <span class="hljs-built_in">String</span> password = sc.nextLine();        <span class="hljs-comment">//2.调用方法</span>        boolean flag = <span class="hljs-keyword">new</span> JDBCDemo9().login(username, password);        <span class="hljs-comment">//3.判断结果，输出不同语句</span>        <span class="hljs-keyword">if</span>(flag)&#123;            <span class="hljs-comment">//登录成功</span>            System.out.println(<span class="hljs-string">"登录成功！"</span>);        &#125;<span class="hljs-keyword">else</span>&#123;            System.out.println(<span class="hljs-string">"用户名或密码错误！"</span>);        &#125;   &#125;   <span class="hljs-comment">/**</span><span class="hljs-comment">     * 登录方法</span><span class="hljs-comment">     */</span>    public boolean login(<span class="hljs-built_in">String</span> username ,<span class="hljs-built_in">String</span> password)&#123;        <span class="hljs-keyword">if</span>(username == <span class="hljs-literal">null</span> || password == <span class="hljs-literal">null</span>)&#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        &#125;        <span class="hljs-comment">//连接数据库判断是否登录成功</span>        Connection conn = <span class="hljs-literal">null</span>;        Statement stmt =  <span class="hljs-literal">null</span>;        ResultSet rs = <span class="hljs-literal">null</span>;        <span class="hljs-comment">//1.获取连接</span>        <span class="hljs-keyword">try</span> &#123;            conn =  JDBCUtils.getConnection();            <span class="hljs-comment">//2.定义sql</span>            <span class="hljs-built_in">String</span> sql = <span class="hljs-string">"select * from user where username = '"</span>+username+<span class="hljs-string">"' and password = '"</span>+password+<span class="hljs-string">"' "</span>;            <span class="hljs-comment">//3.获取执行sql的对象</span>            stmt = conn.createStatement();            <span class="hljs-comment">//4.执行查询</span>            rs = stmt.executeQuery(sql);            <span class="hljs-comment">//5.判断</span>           <span class="hljs-comment">/* if(rs.next())&#123;//如果有下一行，则返回true</span><span class="hljs-comment">                return true;</span><span class="hljs-comment">            &#125;else&#123;</span><span class="hljs-comment">                return false;</span><span class="hljs-comment">            &#125;*/</span>           <span class="hljs-keyword">return</span> rs.next();<span class="hljs-comment">//如果有下一行，则返回true</span>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;            e.printStackTrace();        &#125;<span class="hljs-keyword">finally</span> &#123;            JDBCUtils.close(rs,stmt,conn);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;</code></pre></div><h1 id="三、JDBC控制事务"><a href="#三、JDBC控制事务" class="headerlink" title="三、JDBC控制事务"></a>三、JDBC控制事务</h1><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-number">1.</span> 事务：一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。<span class="hljs-number">2.</span> 操作：<span class="hljs-number">1.</span> 开启事务<span class="hljs-number">2.</span> 提交事务<span class="hljs-number">3.</span> 回滚事务<span class="hljs-number">3.</span> 使用Connection对象来管理事务* 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为<span class="hljs-literal">false</span>，即开启事务* 在执行sql之前开启事务* 提交事务：commit() * 当所有sql都执行完提交事务* 回滚事务：rollback() * 在<span class="hljs-keyword">catch</span>中回滚事务<span class="hljs-number">4.</span> 代码：public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JDBCDemo10</span> </span>&#123;    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-built_in">String</span>[] args) &#123;        Connection conn = <span class="hljs-literal">null</span>;        PreparedStatement pstmt1 = <span class="hljs-literal">null</span>;        PreparedStatement pstmt2 = <span class="hljs-literal">null</span>;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//1.获取连接</span>            conn = JDBCUtils.getConnection();            <span class="hljs-comment">//开启事务</span>            conn.setAutoCommit(<span class="hljs-literal">false</span>);            <span class="hljs-comment">//2.定义sql</span>            <span class="hljs-comment">//2.1 张三 - 500</span>            <span class="hljs-built_in">String</span> sql1 = <span class="hljs-string">"update account set balance = balance - ? where id = ?"</span>;            <span class="hljs-comment">//2.2 李四 + 500</span>            <span class="hljs-built_in">String</span> sql2 = <span class="hljs-string">"update account set balance = balance + ? where id = ?"</span>;            <span class="hljs-comment">//3.获取执行sql对象</span>            pstmt1 = conn.prepareStatement(sql1);            pstmt2 = conn.prepareStatement(sql2);            <span class="hljs-comment">//4. 设置参数</span>            pstmt1.setDouble(<span class="hljs-number">1</span>,<span class="hljs-number">500</span>);            pstmt1.setInt(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>);            pstmt2.setDouble(<span class="hljs-number">1</span>,<span class="hljs-number">500</span>);            pstmt2.setInt(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>);            <span class="hljs-comment">//5.执行sql</span>            pstmt1.executeUpdate();            <span class="hljs-comment">// 手动制造异常</span>            int i = <span class="hljs-number">3</span>/<span class="hljs-number">0</span>;            pstmt2.executeUpdate();            <span class="hljs-comment">//提交事务</span>            conn.commit();        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            <span class="hljs-comment">//事务回滚</span>            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-keyword">if</span>(conn != <span class="hljs-literal">null</span>) &#123;                    conn.rollback();                &#125;            &#125; <span class="hljs-keyword">catch</span> (SQLException e1) &#123;                e1.printStackTrace();            &#125;            e.printStackTrace();        &#125;<span class="hljs-keyword">finally</span> &#123;            JDBCUtils.close(pstmt1,conn);            JDBCUtils.close(pstmt2,<span class="hljs-literal">null</span>);        &#125;     &#125; &#125;</code></pre></div><h1 id="四、数据库连接池"><a href="#四、数据库连接池" class="headerlink" title="四、数据库连接池"></a>四、数据库连接池</h1><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_07/13.png" srcset="/img/loading.gif" alt=""></p><div class="hljs"><pre><code>1. 概念：其实就是一个容器(集合)，存放数据库连接的容器。        当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。2. 好处：    1. 节约资源    2. 用户访问高效3. 实现：    1. 标准接口：DataSource   javax.sql包下的        1. 方法：            * 获取连接：getConnection()            * 归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接    2. 一般我们不去实现它，有数据库厂商来实现        1. C3P0：数据库连接池技术        2. Druid：数据库连接池实现技术，由阿里巴巴提供的4. C3P0：数据库连接池技术    * 步骤：        1. 导入jar包 (两个) c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar ，            * 不要忘记导入数据库驱动jar包        2. 定义配置文件：            * 名称： c3p0.properties 或者 c3p0-config.xml            * 路径：直接将文件放在src目录下即可。        3. 创建核心对象 数据库连接池对象 ComboPooledDataSource        4. 获取连接： getConnection    * 代码：         //1.创建数据库连接池对象        DataSource ds  = new ComboPooledDataSource();        //2. 获取连接对象        Connection conn = ds.getConnection();5. Druid：数据库连接池实现技术，由阿里巴巴提供的    1. 步骤：        1. 导入jar包 druid-1.0.9.jar        2. 定义配置文件：            * 是properties形式的            * 可以叫任意名称，可以放在任意目录下        3. 加载配置文件。Properties        4. 获取数据库连接池对象：通过工厂来来获取  DruidDataSourceFactory        5. 获取连接：getConnection    * 代码：         //3.加载配置文件        Properties pro = new Properties();        InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;);        pro.load(is);        //4.获取连接池对象        DataSource ds = DruidDataSourceFactory.createDataSource(pro);        //5.获取连接        Connection conn = ds.getConnection();    2. 定义工具类        1. 定义一个类 JDBCUtils        2. 提供静态代码块加载配置文件，初始化连接池对象        3. 提供方法            1. 获取连接方法：通过数据库连接池获取连接            2. 释放资源            3. 获取连接池的方法</code></pre></div><div class="hljs"><pre><code class="hljs javascript">* 代码：public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JDBCUtils</span> </span>&#123;    <span class="hljs-comment">//1.定义成员变量 DataSource</span>    private <span class="hljs-keyword">static</span> DataSource ds ;    <span class="hljs-keyword">static</span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//1.加载配置文件</span>            Properties pro = <span class="hljs-keyword">new</span> Properties();            pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(<span class="hljs-string">"druid.properties"</span>));            <span class="hljs-comment">//2.获取DataSource</span>            ds = DruidDataSourceFactory.createDataSource(pro);        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取连接</span><span class="hljs-comment">     */</span>    public <span class="hljs-keyword">static</span> Connection getConnection() throws SQLException &#123;        <span class="hljs-keyword">return</span> ds.getConnection();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 释放资源</span><span class="hljs-comment">     */</span>    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> close(Statement stmt,Connection conn)&#123;       <span class="hljs-comment">/* if(stmt != null)&#123;</span><span class="hljs-comment">            try &#123;</span><span class="hljs-comment">                stmt.close();</span><span class="hljs-comment">            &#125; catch (SQLException e) &#123;</span><span class="hljs-comment">                e.printStackTrace();</span><span class="hljs-comment">            &#125;</span><span class="hljs-comment">        &#125;</span><span class="hljs-comment"></span><span class="hljs-comment">        if(conn != null)&#123;</span><span class="hljs-comment">            try &#123;</span><span class="hljs-comment">                conn.close();//归还连接</span><span class="hljs-comment">            &#125; catch (SQLException e) &#123;</span><span class="hljs-comment">                e.printStackTrace();</span><span class="hljs-comment">            &#125;</span><span class="hljs-comment">        &#125;*/</span>       close(<span class="hljs-literal">null</span>,stmt,conn);    &#125;    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> close(ResultSet rs , Statement stmt, Connection conn)&#123;       <span class="hljs-keyword">if</span>(rs != <span class="hljs-literal">null</span>)&#123;            <span class="hljs-keyword">try</span> &#123;                rs.close();            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;                e.printStackTrace();            &#125;        &#125;         <span class="hljs-keyword">if</span>(stmt != <span class="hljs-literal">null</span>)&#123;            <span class="hljs-keyword">try</span> &#123;                stmt.close();            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;                e.printStackTrace();            &#125;        &#125;        <span class="hljs-keyword">if</span>(conn != <span class="hljs-literal">null</span>)&#123;            <span class="hljs-keyword">try</span> &#123;                conn.close();<span class="hljs-comment">//归还连接</span>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取连接池方法</span><span class="hljs-comment">     */</span>    public <span class="hljs-keyword">static</span> DataSource getDataSource()&#123;        <span class="hljs-keyword">return</span>  ds;    &#125;&#125;</code></pre></div><h1 id="五、Spring-JDBC"><a href="#五、Spring-JDBC" class="headerlink" title="五、Spring JDBC"></a>五、Spring JDBC</h1><div class="hljs"><pre><code>* Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发* 步骤：    1. 导入jar包    2. 创建JdbcTemplate对象。依赖于数据源DataSource        * JdbcTemplate template = new JdbcTemplate(ds);    3. 调用JdbcTemplate的方法来完成CRUD的操作        * update():执行DML语句。增、删、改语句        * queryForMap():查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合            * 注意：这个方法查询的结果集长度只能是1        * queryForList():查询结果将结果集封装为list集合            * 注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中        * query():查询结果，将结果封装为JavaBean对象            * query的参数：RowMapper                * 一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装                * new BeanPropertyRowMapper&lt;类型&gt;(类型.class)        * queryForObject：查询结果，将结果封装为对象            * 一般用于聚合函数的查询    4. 练习：        * 需求：            1. 修改1号数据的 salary 为 10000            2. 添加一条记录            3. 删除刚才添加的记录            4. 查询id为1的记录，将其封装为Map集合            5. 查询所有记录，将其封装为List            6. 查询所有记录，将其封装为Emp对象的List集合            7. 查询总记录数</code></pre></div><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> cn.itcast.domain.Emp;<span class="hljs-keyword">import</span> cn.itcast.utils.JDBCUtils;<span class="hljs-keyword">import</span> org.junit.Test;<span class="hljs-keyword">import</span> org.springframework.jdbc.core.BeanPropertyRowMapper;<span class="hljs-keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;<span class="hljs-keyword">import</span> org.springframework.jdbc.core.RowMapper;<span class="hljs-keyword">import</span> java.sql.Date;<span class="hljs-keyword">import</span> java.sql.ResultSet;<span class="hljs-keyword">import</span> java.sql.SQLException;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">import</span> java.util.Map;public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdbcTemplateDemo2</span> </span>&#123;    <span class="hljs-comment">//Junit单元测试，可以让方法独立执行</span>     <span class="hljs-comment">//1. 获取JDBCTemplate对象</span>    private JdbcTemplate template = <span class="hljs-keyword">new</span> JdbcTemplate(JDBCUtils.getDataSource());    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 1. 修改1号数据的 salary 为 10000</span><span class="hljs-comment">     */</span>    @Test    public <span class="hljs-keyword">void</span> test1()&#123;        <span class="hljs-comment">//2. 定义sql</span>        <span class="hljs-built_in">String</span> sql = <span class="hljs-string">"update emp set salary = 10000 where id = 1001"</span>;        <span class="hljs-comment">//3. 执行sql</span>        int count = template.update(sql);        System.out.println(count);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 2. 添加一条记录</span><span class="hljs-comment">     */</span>    @Test    public <span class="hljs-keyword">void</span> test2()&#123;        <span class="hljs-built_in">String</span> sql = <span class="hljs-string">"insert into emp(id,ename,dept_id) values(?,?,?)"</span>;        int count = template.update(sql, <span class="hljs-number">1015</span>, <span class="hljs-string">"郭靖"</span>, <span class="hljs-number">10</span>);        System.out.println(count);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 3.删除刚才添加的记录</span><span class="hljs-comment">     */</span>    @Test    public <span class="hljs-keyword">void</span> test3()&#123;        <span class="hljs-built_in">String</span> sql = <span class="hljs-string">"delete from emp where id = ?"</span>;        int count = template.update(sql, <span class="hljs-number">1015</span>);        System.out.println(count);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 4.查询id为1001的记录，将其封装为Map集合</span><span class="hljs-comment">     * 注意：这个方法查询的结果集长度只能是1</span><span class="hljs-comment">     */</span>    @Test    public <span class="hljs-keyword">void</span> test4()&#123;        <span class="hljs-built_in">String</span> sql = <span class="hljs-string">"select * from emp where id = ? or id = ?"</span>;        <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">Object</span>&gt; map = template.queryForMap(sql, <span class="hljs-number">1001</span>,<span class="hljs-number">1002</span>);        System.out.println(map);        <span class="hljs-comment">//&#123;id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20&#125;</span>    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 5. 查询所有记录，将其封装为List</span><span class="hljs-comment">     */</span>    @Test    public <span class="hljs-keyword">void</span> test5()&#123;        <span class="hljs-built_in">String</span> sql = <span class="hljs-string">"select * from emp"</span>;        List&lt;<span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">Object</span>&gt;&gt; list = template.queryForList(sql);        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">Object</span>&gt; stringObjectMap : list) &#123;            System.out.println(stringObjectMap);        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 6. 查询所有记录，将其封装为Emp对象的List集合</span><span class="hljs-comment">     */</span>    @Test    public <span class="hljs-keyword">void</span> test6()&#123;        <span class="hljs-built_in">String</span> sql = <span class="hljs-string">"select * from emp"</span>;        List&lt;Emp&gt; list = template.query(sql, <span class="hljs-keyword">new</span> RowMapper&lt;Emp&gt;() &#123;            @Override            public Emp mapRow(ResultSet rs, int i) throws SQLException &#123;                Emp emp = <span class="hljs-keyword">new</span> Emp();                int id = rs.getInt(<span class="hljs-string">"id"</span>);                <span class="hljs-built_in">String</span> ename = rs.getString(<span class="hljs-string">"ename"</span>);                int job_id = rs.getInt(<span class="hljs-string">"job_id"</span>);                int mgr = rs.getInt(<span class="hljs-string">"mgr"</span>);                <span class="hljs-built_in">Date</span> joindate = rs.getDate(<span class="hljs-string">"joindate"</span>);                double salary = rs.getDouble(<span class="hljs-string">"salary"</span>);                double bonus = rs.getDouble(<span class="hljs-string">"bonus"</span>);                int dept_id = rs.getInt(<span class="hljs-string">"dept_id"</span>);                emp.setId(id);                emp.setEname(ename);                emp.setJob_id(job_id);                emp.setMgr(mgr);                emp.setJoindate(joindate);                emp.setSalary(salary);                emp.setBonus(bonus);                emp.setDept_id(dept_id);                <span class="hljs-keyword">return</span> emp;            &#125;        &#125;);        <span class="hljs-keyword">for</span> (Emp emp : list) &#123;            System.out.println(emp);        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 6. 查询所有记录，将其封装为Emp对象的List集合</span><span class="hljs-comment">     */</span>    @Test    public <span class="hljs-keyword">void</span> test6_2()&#123;        <span class="hljs-built_in">String</span> sql = <span class="hljs-string">"select * from emp"</span>;        List&lt;Emp&gt; list = template.query(sql, <span class="hljs-keyword">new</span> BeanPropertyRowMapper&lt;Emp&gt;(Emp.class));        <span class="hljs-keyword">for</span> (Emp emp : list) &#123;            System.out.println(emp);        &#125;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 7. 查询总记录数</span><span class="hljs-comment">     */</span>    @Test    public <span class="hljs-keyword">void</span> test7()&#123;        <span class="hljs-built_in">String</span> sql = <span class="hljs-string">"select count(id) from emp"</span>;        Long total = template.queryForObject(sql, Long.class);        System.out.println(total);    &#125;&#125;</code></pre></div><p>​                </p>]]></content>
    
    
    <categories>
      
      <category>JDBC</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL/相关的配置软件介绍</title>
    <link href="/2020/07/05/MySQL/%E7%9B%B8%E5%85%B3%E7%9A%84%E9%85%8D%E7%BD%AE%E8%BD%AF%E4%BB%B6%E4%BB%8B%E7%BB%8D/"/>
    <url>/2020/07/05/MySQL/%E7%9B%B8%E5%85%B3%E7%9A%84%E9%85%8D%E7%BD%AE%E8%BD%AF%E4%BB%B6%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<p><code>以下为2019/03/13当天下载</code></p><h2 id="1-MySQL-Documents-5-5"><a href="#1-MySQL-Documents-5-5" class="headerlink" title="1.MySQL Documents 5.5"></a>1.MySQL Documents 5.5</h2><p>类似于帮助文件，保留以备后用，可能要检查一下MySQL </p><h2 id="2-Examples-and-Samples-5-5"><a href="#2-Examples-and-Samples-5-5" class="headerlink" title="2.Examples and Samples 5.5"></a>2.Examples and Samples 5.5</h2><p>是一些数据库案例。连接到数据库后看到的sekila就是已安装的。</p><h2 id="3-MySQL-Installer"><a href="#3-MySQL-Installer" class="headerlink" title="3.MySQL Installer"></a>3.MySQL Installer</h2><p>效于软件安装和卸载修复程序</p><h2 id="4-MySQL-Notifier-1-1-6"><a href="#4-MySQL-Notifier-1-1-6" class="headerlink" title="4.MySQL Notifier 1.1.6"></a>4.MySQL Notifier 1.1.6</h2><p>启动和停止mysql服务的程序，只能在Windows下使用，可以完成新mysql产品的安装并卸载现有mysql， 产品（以上两种）以及修复原始产品的更新也都使用此产品</p><h2 id="5-MySQL-Utilities"><a href="#5-MySQL-Utilities" class="headerlink" title="5.MySQL Utilities"></a>5.MySQL Utilities</h2><p> 是官方提供的MySQL管理工具 ，提供一组命令行工具用于维护和管理 MySQL 服务器</p><h2 id="6-MySQL-Connector-C-1-1-4"><a href="#6-MySQL-Connector-C-1-1-4" class="headerlink" title="6. MySQL Connector C++ 1.1.4"></a>6. MySQL Connector C++ 1.1.4</h2><p> 用于连接到MySQL服务器的C ++应用程序的MySQL数据库连接器</p><p><code>以下为2019/10/09当天下载</code></p><h2 id="7-MySQL-Server5-5"><a href="#7-MySQL-Server5-5" class="headerlink" title="7.MySQL Server5.5"></a>7.MySQL Server5.5</h2><p>正常的MySQL的安装</p><h2 id="8-Navicat-for-MySQL-10-1-7"><a href="#8-Navicat-for-MySQL-10-1-7" class="headerlink" title="8.Navicat for MySQL 10.1.7"></a>8.Navicat for MySQL 10.1.7</h2><p> 为 MySQL 设计的数据库管理及开发工具</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL/MySQL</title>
    <link href="/2020/07/03/MySQL/MySQL/"/>
    <url>/2020/07/03/MySQL/MySQL/</url>
    
    <content type="html"><![CDATA[<h1 id="一、数据库的基本概念"><a href="#一、数据库的基本概念" class="headerlink" title="一、数据库的基本概念"></a>一、数据库的基本概念</h1><div class="hljs"><pre><code>1. 数据库的英文单词： DataBase 简称 ： DB2. 什么数据库？    * 用于存储和管理数据的仓库。3. 数据库的特点：    1. 持久化存储数据的。其实数据库就是一个文件系统    2. 方便存储和管理数据    3. 使用了统一的方式操作数据库 -- SQL    4. 常见的数据库软件</code></pre></div><h1 id="二、MySQL数据库软件"><a href="#二、MySQL数据库软件" class="headerlink" title="二、MySQL数据库软件"></a>二、MySQL数据库软件</h1><div class="hljs"><pre><code>1. 安装2. 卸载    1. 去mysql的安装目录找到my.ini文件        * 复制 datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&quot;    2. 卸载MySQL    3. 删除C:/ProgramData目录下的MySQL文件夹。3. 配置    * MySQL服务启动        1. 手动。        2. cmd--&gt; services.msc 打开服务的窗口        3. 使用管理员打开cmd            * net start mysql : 启动mysql的服务            * net stop mysql:关闭mysql服务    * MySQL登录        1. mysql -uroot -p密码        2. mysql -hip -uroot -p连接目标的密码        3. mysql --host=ip --user=root --password=连接目标的密码    * MySQL退出        1. exit        2. quit    * MySQL目录结构        1. MySQL安装目录：basedir=&quot;D:/develop/MySQL/&quot;            * 配置文件 my.ini        2. MySQL数据目录：datadir=&quot;C:/ProgramData/MySQL/MySQL Server 5.5/Data/&quot;            * 几个概念                * 数据库：文件夹                * 表：文件                * 数据：数据</code></pre></div><p>安装MySQL其实是在计算机上安装了MySQL服务，也就是说安装了MySQL数据库服务器软件。这台计算机也就成为了MySQL服务器。其他计算机作为客户端可以访问该MySQL服务器。</p><p>MySQL数据库、表、数据的关系:</p><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_07/10.png" srcset="/img/loading.gif" alt="MySQL数据库、表、数据的关系"></p><h1 id="三、SQL"><a href="#三、SQL" class="headerlink" title="三、SQL"></a>三、SQL</h1><div class="hljs"><pre><code>1.什么是SQL？    Structured Query Language：结构化查询语言    其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。2.SQL通用语法    1. SQL 语句可以单行或多行书写，以分号结尾。    2. 可使用空格和缩进来增强语句的可读性。    3. MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。    4. 3 种注释        * 单行注释: -- 注释内容 或 # 注释内容(mysql 特有)         * 多行注释: /* 注释 */3. SQL分类    1) DDL(Data Definition Language)数据定义语言        用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等    2) DML(Data Manipulation Language)数据操作语言        用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等    3) DQL(Data Query Language)数据查询语言        用来查询数据库中表的记录(数据)。关键字：select, where 等    4) DCL(Data Control Language)数据控制语言(了解)        用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等</code></pre></div><p>SQL分类：</p><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_07/11.png" srcset="/img/loading.gif" alt="SQL分类"></p><h2 id="1-DDL-操作数据库、表"><a href="#1-DDL-操作数据库、表" class="headerlink" title="1.DDL:操作数据库、表"></a>1.DDL:操作数据库、表</h2><div class="hljs"><pre><code class="hljs sql">1. 操作数据库：CRUD1. C(<span class="hljs-keyword">Create</span>):创建* 创建数据库：* <span class="hljs-keyword">create</span> <span class="hljs-keyword">database</span> 数据库名称;* 创建数据库，判断不存在，再创建：* create database if not exists 数据库名称;* 创建数据库，并指定字符集* create database 数据库名称 character set 字符集名;* 练习： 创建db4数据库，判断是否存在，并制定字符集为gbk* create database if not exists db4 character set gbk;2. R(Retrieve)：查询* 查询所有数据库的名称:* show databases;* 查询某个数据库的字符集:查询某个数据库的创建语句* show create database 数据库名称;3. U(<span class="hljs-keyword">Update</span>):修改* 修改数据库的字符集* <span class="hljs-keyword">alter</span> <span class="hljs-keyword">database</span> 数据库名称 <span class="hljs-built_in">character</span> <span class="hljs-keyword">set</span> 字符集名称;4. D(<span class="hljs-keyword">Delete</span>):删除* 删除数据库* <span class="hljs-keyword">drop</span> <span class="hljs-keyword">database</span> 数据库名称;* 判断数据库存在，存在再删除* drop database if exists 数据库名称;5. 使用数据库* 查询当前正在使用的数据库名称* select database();* 使用数据库* use 数据库名称;</code></pre></div><div class="hljs"><pre><code>2. 操作表    1. C(Create):创建        1. 语法：            create table 表名(                列名1 数据类型1,                列名2 数据类型2,                ....                列名n 数据类型n            );            * 注意：最后一列，不需要加逗号（,）            * 数据库类型：                1. int：整数类型                    * age int,                2. double:小数类型                    * score double(5,2)                3. date:日期，只包含年月日，yyyy-MM-dd                4. datetime:日期，包含年月日时分秒     yyyy-MM-dd HH:mm:ss                5. timestamp:时间戳类型    包含年月日时分秒     yyyy-MM-dd HH:mm:ss                        * 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值                6. varchar：字符串                    * name varchar(20):姓名最大20个字符                    * zhangsan 8个字符  张三 2个字符</code></pre></div><div class="hljs"><pre><code class="hljs sql">* 创建表<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> student(<span class="hljs-keyword">id</span> <span class="hljs-built_in">int</span>,<span class="hljs-keyword">name</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">32</span>),age <span class="hljs-built_in">int</span> ,score <span class="hljs-keyword">double</span>(<span class="hljs-number">4</span>,<span class="hljs-number">1</span>),birthday <span class="hljs-built_in">date</span>,insert_time <span class="hljs-built_in">timestamp</span>);* 复制表：* create table 表名 like 被复制的表名;  2. R(Retrieve)：查询* 查询某个数据库中所有的表名称* show tables;* 查询表结构* desc 表名;3. U(<span class="hljs-keyword">Update</span>):修改<span class="hljs-number">1.</span> 修改表名<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">rename</span> <span class="hljs-keyword">to</span> 新的表名;2. 修改表的字符集<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-built_in">character</span> <span class="hljs-keyword">set</span> 字符集名称;3. 添加一列<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">add</span> 列名 数据类型;4. 修改列名称 类型<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">change</span> 列名 新列名 新数据类型;<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">modify</span> 列名 新数据类型;5. 删除列<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> 表名 <span class="hljs-keyword">drop</span> 列名;4. D(<span class="hljs-keyword">Delete</span>):删除* <span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> 表名;* drop table  if exists 表名 ;</code></pre></div><ul><li>客户端图形化工具：SQLYog</li></ul><h2 id="2-DML：增删改表中数据"><a href="#2-DML：增删改表中数据" class="headerlink" title="2.DML：增删改表中数据"></a>2.DML：增删改表中数据</h2><div class="hljs"><pre><code class="hljs sql">1. 添加数据：* 语法：* insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n);* 注意：1. 列名和值要一一对应。2. 如果表名后，不定义列名，则默认给所有列添加值<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> 表名 <span class="hljs-keyword">values</span>(值<span class="hljs-number">1</span>,值<span class="hljs-number">2</span>,...值n);3. 除了数字类型，其他类型需要使用引号(单双都可以)引起来2. 删除数据：* 语法：* delete from 表名 [where 条件]* 注意：1. 如果不加条件，则删除表中所有记录。2. 如果要删除所有记录1. <span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> 表名; <span class="hljs-comment">-- 不推荐使用。有多少条记录就会执行多少次删除操作</span>2. <span class="hljs-keyword">TRUNCATE</span> <span class="hljs-keyword">TABLE</span> 表名; <span class="hljs-comment">-- 推荐使用，效率更高 先删除表，然后再创建一张一样的表。</span>3. 修改数据：* 语法：* update 表名 set 列名1 = 值1, 列名2 = 值2,... [where 条件];* 注意：1. 如果不加任何条件，则会将表中所有记录全部修改。</code></pre></div><h2 id="3-DQL：查询表中的记录"><a href="#3-DQL：查询表中的记录" class="headerlink" title="3.DQL：查询表中的记录"></a>3.DQL：查询表中的记录</h2><div class="hljs"><pre><code class="hljs sql">* select * from 表名;1. 语法：<span class="hljs-keyword">select</span>字段列表<span class="hljs-keyword">from</span>表名列表<span class="hljs-keyword">where</span>条件列表<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span>分组字段<span class="hljs-keyword">having</span>分组之后的条件<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span>排序<span class="hljs-keyword">limit</span>分页限定</code></pre></div><div class="hljs"><pre><code class="hljs sql">2. 基础查询1. 多个字段的查询<span class="hljs-keyword">select</span> 字段名<span class="hljs-number">1</span>，字段名<span class="hljs-number">2.</span>.. <span class="hljs-keyword">from</span> 表名；* 注意：* 如果查询所有字段，则可以使用*来替代字段列表。<span class="hljs-number">2.</span> 去除重复：* <span class="hljs-keyword">distinct</span><span class="hljs-number">3.</span> 计算列* 一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算）* <span class="hljs-keyword">ifnull</span>(表达式<span class="hljs-number">1</span>,表达式<span class="hljs-number">2</span>)：<span class="hljs-literal">null</span>参与的运算，计算结果都为<span class="hljs-literal">null</span>* 表达式<span class="hljs-number">1</span>：哪个字段需要判断是否为<span class="hljs-literal">null</span>* 如果该字段为<span class="hljs-literal">null</span>后的替换值。<span class="hljs-number">4.</span> 起别名：* <span class="hljs-keyword">as</span>：<span class="hljs-keyword">as</span>也可以省略</code></pre></div><div class="hljs"><pre><code class="hljs sql">3. 条件查询1. where子句后跟条件2. 运算符* &gt; 、&lt; 、&lt;= 、&gt;= 、= 、&lt;&gt;* BETWEEN...AND  * IN( 集合) * LIKE：模糊查询* 占位符：* _:单个任意字符* %：多个任意字符* IS NULL  * and  或 &amp;&amp;* or  或 || * not  或 !<span class="hljs-comment">-- 查询年龄大于20岁</span><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> age &gt; <span class="hljs-number">20</span>;<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> age &gt;= <span class="hljs-number">20</span>;<span class="hljs-comment">-- 查询年龄等于20岁</span><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> age = <span class="hljs-number">20</span>;<span class="hljs-comment">-- 查询年龄不等于20岁</span><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> age != <span class="hljs-number">20</span>;<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> age &lt;&gt; <span class="hljs-number">20</span>;<span class="hljs-comment">-- 查询年龄大于等于20 小于等于30</span><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> age &gt;= <span class="hljs-number">20</span> &amp;&amp;  age &lt;=<span class="hljs-number">30</span>;<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> age &gt;= <span class="hljs-number">20</span> <span class="hljs-keyword">AND</span>  age &lt;=<span class="hljs-number">30</span>;<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> age <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">20</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">30</span>;<span class="hljs-comment">-- 查询年龄22岁，18岁，25岁的信息</span><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> age = <span class="hljs-number">22</span> <span class="hljs-keyword">OR</span> age = <span class="hljs-number">18</span> <span class="hljs-keyword">OR</span> age = <span class="hljs-number">25</span><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> age <span class="hljs-keyword">IN</span> (<span class="hljs-number">22</span>,<span class="hljs-number">18</span>,<span class="hljs-number">25</span>);<span class="hljs-comment">-- 查询英语成绩为null</span><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> english = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">-- 不对的。null值不能使用 = （!=） 判断</span><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> english <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span>;<span class="hljs-comment">-- 查询英语成绩不为null</span><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> english  <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>;</code></pre></div><div class="hljs"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询姓马的有哪些？ like</span><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">NAME</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">'马%'</span>;<span class="hljs-comment">-- 查询姓名第二个字是化的人</span><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">NAME</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">"_化%"</span>;<span class="hljs-comment">-- 查询姓名是3个字的人</span><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">NAME</span> <span class="hljs-keyword">LIKE</span> <span class="hljs-string">'___'</span>;</code></pre></div><p>​                – 查询姓名中包含德的人<br>​                SELECT * FROM student WHERE NAME LIKE ‘%德%’;</p><h1 id="四、DQL-查询语句"><a href="#四、DQL-查询语句" class="headerlink" title="四、DQL:查询语句"></a>四、DQL:查询语句</h1><div class="hljs"><pre><code class="hljs sql">1. 排序查询* 语法：order by 子句* order by 排序字段1 排序方式1 ，  排序字段2 排序方式2...* 排序方式：* ASC：升序，默认的。* DESC：降序。* 注意：* 如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。</code></pre></div><div class="hljs"><pre><code class="hljs sql">2. 聚合函数：将一列数据作为一个整体，进行纵向的计算。1. count：计算个数1. 一般选择非空的列：主键2. count(*)2. max：计算最大值3. min：计算最小值4. sum：计算和5. avg：计算平均值</code></pre></div><div class="hljs"><pre><code class="hljs sql">* 注意：聚合函数的计算，排除null值。解决方案：1. 选择不包含非空的列进行计算2. IFNULL函数3. 分组查询:1. 语法：group by 分组字段；2. 注意：1. 分组之后查询的字段：分组字段、聚合函数2. where 和 having 的区别？1. where 在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行限定，如果不满足结果，则不会被查询出来2. where 后不可以跟聚合函数，having可以进行聚合函数的判断。<span class="hljs-comment">-- 按照性别分组。分别查询男、女同学的平均分</span><span class="hljs-keyword">SELECT</span> sex , <span class="hljs-keyword">AVG</span>(math) <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> sex;<span class="hljs-comment">-- 按照性别分组。分别查询男、女同学的平均分,人数</span><span class="hljs-keyword">SELECT</span> sex , <span class="hljs-keyword">AVG</span>(math),<span class="hljs-keyword">COUNT</span>(<span class="hljs-keyword">id</span>) <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> sex;<span class="hljs-comment">--  按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组</span><span class="hljs-keyword">SELECT</span> sex , <span class="hljs-keyword">AVG</span>(math),<span class="hljs-keyword">COUNT</span>(<span class="hljs-keyword">id</span>) <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> math &gt; <span class="hljs-number">70</span> <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> sex;<span class="hljs-comment">--  按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组,分组之后。人数要大于2个人</span><span class="hljs-keyword">SELECT</span> sex , <span class="hljs-keyword">AVG</span>(math),<span class="hljs-keyword">COUNT</span>(<span class="hljs-keyword">id</span>) <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> math &gt; <span class="hljs-number">70</span> <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> sex <span class="hljs-keyword">HAVING</span> <span class="hljs-keyword">COUNT</span>(<span class="hljs-keyword">id</span>) &gt; <span class="hljs-number">2</span>;<span class="hljs-keyword">SELECT</span> sex , <span class="hljs-keyword">AVG</span>(math),<span class="hljs-keyword">COUNT</span>(<span class="hljs-keyword">id</span>) 人数 <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> math &gt; <span class="hljs-number">70</span> <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> sex <span class="hljs-keyword">HAVING</span> 人数 &gt; <span class="hljs-number">2</span>;</code></pre></div><div class="hljs"><pre><code class="hljs sql">4. 分页查询1. 语法：limit 开始的索引,每页查询的条数;2. 公式：开始的索引 = （当前的页码 - 1） * 每页显示的条数<span class="hljs-comment">-- 每页显示3条记录 </span><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">0</span>,<span class="hljs-number">3</span>; <span class="hljs-comment">-- 第1页</span><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">3</span>,<span class="hljs-number">3</span>; <span class="hljs-comment">-- 第2页</span><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">6</span>,<span class="hljs-number">3</span>; <span class="hljs-comment">-- 第3页</span>3. limit 是一个MySQL"方言"</code></pre></div><h1 id="五、约束"><a href="#五、约束" class="headerlink" title="五、约束"></a>五、约束</h1><div class="hljs"><pre><code class="hljs sql">* 概念： 对表中的数据进行限定，保证数据的正确性、有效性和完整性。* 分类：1. 主键约束：primary key2. 非空约束：not null3. 唯一约束：unique4. 外键约束：foreign key* 非空约束：not null，值不能为null1. 创建表时添加约束<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> stu(<span class="hljs-keyword">id</span> <span class="hljs-built_in">INT</span>,<span class="hljs-keyword">NAME</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-comment">-- name为非空</span>);2. 创建表完后，添加非空约束<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> stu <span class="hljs-keyword">MODIFY</span> <span class="hljs-keyword">NAME</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>;3. 删除name的非空约束<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> stu <span class="hljs-keyword">MODIFY</span> <span class="hljs-keyword">NAME</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>);* 唯一约束：unique，值不能重复1. 创建表时，添加唯一约束<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> stu(<span class="hljs-keyword">id</span> <span class="hljs-built_in">INT</span>,phone_number <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">UNIQUE</span> <span class="hljs-comment">-- 添加了唯一约束</span>);* 注意mysql中，唯一约束限定的列的值可以有多个null2. 删除唯一约束<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> stu <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">INDEX</span> phone_number;3. 在创建表后，添加唯一约束<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> stu <span class="hljs-keyword">MODIFY</span> phone_number <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">UNIQUE</span>;* 主键约束：primary key。1. 注意：1. 含义：非空且唯一2. 一张表只能有一个字段为主键3. 主键就是表中记录的唯一标识</code></pre></div><div class="hljs"><pre><code class="hljs sql">2. 在创建表时，添加主键约束<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> stu(<span class="hljs-keyword">id</span> <span class="hljs-built_in">int</span> primary <span class="hljs-keyword">key</span>,<span class="hljs-comment">-- 给id添加主键约束</span><span class="hljs-keyword">name</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">20</span>));3. 删除主键<span class="hljs-comment">-- 错误 alter table stu modify id int ;</span><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> stu <span class="hljs-keyword">DROP</span> PRIMARY <span class="hljs-keyword">KEY</span>;4. 创建完表后，添加主键<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> stu <span class="hljs-keyword">MODIFY</span> <span class="hljs-keyword">id</span> <span class="hljs-built_in">INT</span> PRIMARY <span class="hljs-keyword">KEY</span>;5. 自动增长：1.  概念：如果某一列是数值类型的，使用 auto_increment 可以来完成值得自动增长2. 在创建表时，添加主键约束，并且完成主键自增长<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> stu(<span class="hljs-keyword">id</span> <span class="hljs-built_in">int</span> primary <span class="hljs-keyword">key</span> auto_increment,<span class="hljs-comment">-- 给id添加主键约束</span><span class="hljs-keyword">name</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">20</span>));3. 删除自动增长<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> stu <span class="hljs-keyword">MODIFY</span> <span class="hljs-keyword">id</span> <span class="hljs-built_in">INT</span>;4. 添加自动增长<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> stu <span class="hljs-keyword">MODIFY</span> <span class="hljs-keyword">id</span> <span class="hljs-built_in">INT</span> AUTO_INCREMENT;</code></pre></div><div class="hljs"><pre><code class="hljs sql">* 外键约束：foreign key,让表于表产生关系，从而保证数据的正确性。1. 在创建表时，可以添加外键* 语法：<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> 表名(....外键列<span class="hljs-keyword">constraint</span> 外键名称 <span class="hljs-keyword">foreign</span> <span class="hljs-keyword">key</span> (外键列名称) <span class="hljs-keyword">references</span> 主表名称(主表列名称));2. 删除外键<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">FOREIGN</span> <span class="hljs-keyword">KEY</span> 外键名称;3. 创建表之后，添加外键<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> 外键名称 <span class="hljs-keyword">FOREIGN</span> <span class="hljs-keyword">KEY</span> (外键字段名称) <span class="hljs-keyword">REFERENCES</span> 主表名称(主表列名称);4. 级联操作1. 添加级联操作语法：<span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> 外键名称 <span class="hljs-keyword">FOREIGN</span> <span class="hljs-keyword">KEY</span> (外键字段名称) <span class="hljs-keyword">REFERENCES</span> 主表名称(主表列名称) <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">CASCADE</span> <span class="hljs-keyword">ON</span> <span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">CASCADE</span>  ;2. 分类：1. 级联更新：ON <span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">CASCADE</span> <span class="hljs-number">2.</span> 级联删除：<span class="hljs-keyword">ON</span> <span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">CASCADE</span></code></pre></div><p>​        </p><h1 id="六、数据库的设计"><a href="#六、数据库的设计" class="headerlink" title="六、数据库的设计"></a>六、数据库的设计</h1><div class="hljs"><pre><code>1. 多表之间的关系    1. 分类：        1. 一对一(了解)：            * 如：人和身份证            * 分析：一个人只有一个身份证，一个身份证只能对应一个人        2. 一对多(多对一)：            * 如：部门和员工            * 分析：一个部门有多个员工，一个员工只能对应一个部门        3. 多对多：            * 如：学生和课程            * 分析：一个学生可以选择很多门课程，一个课程也可以被很多学生选择    2. 实现关系：        1. 一对多(多对一)：            * 如：部门和员工            * 实现方式：在多的一方建立外键，指向一的一方的主键。        2. 多对多：            * 如：学生和课程            * 实现方式：多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键        3. 一对一(了解)：            * 如：人和身份证            * 实现方式：一对一关系实现，可以在任意一方添加唯一外键指向另一方的主键。    3. 案例        -- 创建旅游线路分类表 tab_category        -- cid 旅游线路分类主键，自动增长        -- cname 旅游线路分类名称非空，唯一，字符串 100        CREATE TABLE tab_category (            cid INT PRIMARY KEY AUTO_INCREMENT,            cname VARCHAR(100) NOT NULL UNIQUE        );        -- 创建旅游线路表 tab_route        /*        rid 旅游线路主键，自动增长        rname 旅游线路名称非空，唯一，字符串 100        price 价格        rdate 上架时间，日期类型        cid 外键，所属分类        */        CREATE TABLE tab_route(            rid INT PRIMARY KEY AUTO_INCREMENT,            rname VARCHAR(100) NOT NULL UNIQUE,            price DOUBLE,            rdate DATE,            cid INT,            FOREIGN KEY (cid) REFERENCES tab_category(cid)        );        /*创建用户表 tab_user        uid 用户主键，自增长        username 用户名长度 100，唯一，非空        password 密码长度 30，非空        name 真实姓名长度 100        birthday 生日        sex 性别，定长字符串 1        telephone 手机号，字符串 11        email 邮箱，字符串长度 100        */        CREATE TABLE tab_user (            uid INT PRIMARY KEY AUTO_INCREMENT,            username VARCHAR(100) UNIQUE NOT NULL,            PASSWORD VARCHAR(30) NOT NULL,            NAME VARCHAR(100),            birthday DATE,            sex CHAR(1) DEFAULT &apos;男&apos;,            telephone VARCHAR(11),            email VARCHAR(100)        );        /*        创建收藏表 tab_favorite        rid 旅游线路 id，外键        date 收藏时间        uid 用户 id，外键        rid 和 uid 不能重复，设置复合主键，同一个用户不能收藏同一个线路两次        */        CREATE TABLE tab_favorite (            rid INT, -- 线路id            DATE DATETIME,            uid INT, -- 用户id            -- 创建复合主键            PRIMARY KEY(rid,uid), -- 联合主键            FOREIGN KEY (rid) REFERENCES tab_route(rid),            FOREIGN KEY(uid) REFERENCES tab_user(uid)        );2. 数据库设计的范式    * 概念：设计数据库时，需要遵循的一些规范。要遵循后边的范式要求，必须先遵循前边的所有范式要求        设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。        目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。    * 分类：        1. 第一范式（1NF）：每一列都是不可分割的原子数据项        2. 第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于码（在1NF基础上消除非主属性对主码的部分函数依赖）            * 几个概念：                1. 函数依赖：A--&gt;B,如果通过A属性(属性组)的值，可以确定唯一B属性的值。则称B依赖于A                    例如：学号--&gt;姓名。  （学号，课程名称） --&gt; 分数                2. 完全函数依赖：A--&gt;B， 如果A是一个属性组，则B属性值得确定需要依赖于A属性组中所有的属性值。                    例如：（学号，课程名称） --&gt; 分数                3. 部分函数依赖：A--&gt;B， 如果A是一个属性组，则B属性值得确定只需要依赖于A属性组中某一些值即可。                    例如：（学号，课程名称） -- &gt; 姓名                4. 传递函数依赖：A--&gt;B, B -- &gt;C . 如果通过A属性(属性组)的值，可以确定唯一B属性的值，在通过B属性（属性组）的值可以确定唯一C属性的值，则称 C 传递函数依赖于A                    例如：学号--&gt;系名，系名--&gt;系主任                5. 码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码                    例如：该表中码为：（学号，课程名称）                    * 主属性：码属性组中的所有属性                    * 非主属性：除过码属性组的属性        3. 第三范式（3NF）：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）</code></pre></div><h1 id="七、数据库的备份和还原"><a href="#七、数据库的备份和还原" class="headerlink" title="七、数据库的备份和还原"></a>七、数据库的备份和还原</h1><div class="hljs"><pre><code>1. 命令行：    * 语法：        * 备份： mysqldump -u用户名 -p密码 数据库名称 &gt; 保存的路径        * 还原：            1. 登录数据库            2. 创建数据库            3. 使用数据库            4. 执行文件。source 文件路径2. 图形化工具：</code></pre></div><h1 id="八、多表查询"><a href="#八、多表查询" class="headerlink" title="八、多表查询"></a>八、多表查询</h1><div class="hljs"><pre><code class="hljs sql">* 查询语法：<span class="hljs-keyword">select</span>列名列表<span class="hljs-keyword">from</span>表名列表where....* 准备<span class="hljs-keyword">sql</span><span class="hljs-comment"># 创建部门表</span><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> dept(<span class="hljs-keyword">id</span> <span class="hljs-built_in">INT</span> PRIMARY <span class="hljs-keyword">KEY</span> AUTO_INCREMENT,<span class="hljs-keyword">NAME</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>));<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> dept (<span class="hljs-keyword">NAME</span>) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'开发部'</span>),(<span class="hljs-string">'市场部'</span>),(<span class="hljs-string">'财务部'</span>);<span class="hljs-comment"># 创建员工表</span><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> emp (<span class="hljs-keyword">id</span> <span class="hljs-built_in">INT</span> PRIMARY <span class="hljs-keyword">KEY</span> AUTO_INCREMENT,<span class="hljs-keyword">NAME</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">10</span>),gender <span class="hljs-built_in">CHAR</span>(<span class="hljs-number">1</span>), <span class="hljs-comment">-- 性别</span>salary <span class="hljs-keyword">DOUBLE</span>, <span class="hljs-comment">-- 工资</span>join_date <span class="hljs-built_in">DATE</span>, <span class="hljs-comment">-- 入职日期</span>dept_id <span class="hljs-built_in">INT</span>,<span class="hljs-keyword">FOREIGN</span> <span class="hljs-keyword">KEY</span> (dept_id) <span class="hljs-keyword">REFERENCES</span> dept(<span class="hljs-keyword">id</span>) <span class="hljs-comment">-- 外键，关联部门表(部门表的主键)</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> emp(<span class="hljs-keyword">NAME</span>,gender,salary,join_date,dept_id) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'孙悟空'</span>,<span class="hljs-string">'男'</span>,<span class="hljs-number">7200</span>,<span class="hljs-string">'2013-02-24'</span>,<span class="hljs-number">1</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> emp(<span class="hljs-keyword">NAME</span>,gender,salary,join_date,dept_id) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'猪八戒'</span>,<span class="hljs-string">'男'</span>,<span class="hljs-number">3600</span>,<span class="hljs-string">'2010-12-02'</span>,<span class="hljs-number">2</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> emp(<span class="hljs-keyword">NAME</span>,gender,salary,join_date,dept_id) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'唐僧'</span>,<span class="hljs-string">'男'</span>,<span class="hljs-number">9000</span>,<span class="hljs-string">'2008-08-08'</span>,<span class="hljs-number">2</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> emp(<span class="hljs-keyword">NAME</span>,gender,salary,join_date,dept_id) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'白骨精'</span>,<span class="hljs-string">'女'</span>,<span class="hljs-number">5000</span>,<span class="hljs-string">'2015-10-07'</span>,<span class="hljs-number">3</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> emp(<span class="hljs-keyword">NAME</span>,gender,salary,join_date,dept_id) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">'蜘蛛精'</span>,<span class="hljs-string">'女'</span>,<span class="hljs-number">4500</span>,<span class="hljs-string">'2011-03-14'</span>,<span class="hljs-number">1</span>);* 笛卡尔积：* 有两个集合A,B .取这两个集合的所有组成情况。* 要完成多表查询，需要消除无用的数据* 多表查询的分类：1. 内连接查询：1. 隐式内连接：使用where条件消除无用数据* 例子：<span class="hljs-comment">-- 查询所有员工信息和对应的部门信息</span><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> emp,dept <span class="hljs-keyword">WHERE</span> emp.<span class="hljs-string">`dept_id`</span> = dept.<span class="hljs-string">`id`</span>;<span class="hljs-comment">-- 查询员工表的名称，性别。部门表的名称</span><span class="hljs-keyword">SELECT</span> emp.name,emp.gender,dept.name <span class="hljs-keyword">FROM</span> emp,dept <span class="hljs-keyword">WHERE</span> emp.<span class="hljs-string">`dept_id`</span> = dept.<span class="hljs-string">`id`</span>;<span class="hljs-keyword">SELECT</span> t1.name, <span class="hljs-comment">-- 员工表的姓名</span>t1.gender,<span class="hljs-comment">-- 员工表的性别</span>t2.name <span class="hljs-comment">-- 部门表的名称</span><span class="hljs-keyword">FROM</span>emp t1,dept t2<span class="hljs-keyword">WHERE</span> t1.<span class="hljs-string">`dept_id`</span> = t2.<span class="hljs-string">`id`</span>;</code></pre></div><div class="hljs"><pre><code class="hljs sql">2. 显式内连接：* 语法： select 字段列表 from 表名1 [inner] join 表名2 on 条件* 例如：* SELECT * FROM emp INNER JOIN dept ON emp.`dept_id` = dept.`id`;* SELECT * FROM emp JOIN dept ON emp.`dept_id` = dept.`id`;3. 内连接查询：1. 从哪些表中查询数据2. 条件是什么3. 查询哪些字段2. 外链接查询：1. 左外连接：* 语法：select 字段列表 from 表1 left [outer] join 表2 on 条件；* 查询的是左表所有数据以及其交集部分。* 例子：<span class="hljs-comment">-- 查询所有员工信息，如果员工有部门，则查询部门名称，没有部门，则不显示部门名称</span><span class="hljs-keyword">SELECT</span> t1.*,t2.<span class="hljs-string">`name`</span> <span class="hljs-keyword">FROM</span> emp t1 <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> dept t2 <span class="hljs-keyword">ON</span> t1.<span class="hljs-string">`dept_id`</span> = t2.<span class="hljs-string">`id`</span>;2. 右外连接：* 语法：select 字段列表 from 表1 right [outer] join 表2 on 条件；* 查询的是右表所有数据以及其交集部分。* 例子：<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> dept t2 <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> emp t1 <span class="hljs-keyword">ON</span> t1.<span class="hljs-string">`dept_id`</span> = t2.<span class="hljs-string">`id`</span>;3. 子查询：* 概念：查询中嵌套查询，称嵌套查询为子查询。<span class="hljs-comment">-- 查询工资最高的员工信息</span><span class="hljs-comment">-- 1 查询最高的工资是多少 9000</span><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">MAX</span>(salary) <span class="hljs-keyword">FROM</span> emp;<span class="hljs-comment">-- 2 查询员工信息，并且工资等于9000的</span><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">WHERE</span> emp.<span class="hljs-string">`salary`</span> = <span class="hljs-number">9000</span>;<span class="hljs-comment">-- 一条sql就完成这个操作。子查询</span><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">WHERE</span> emp.<span class="hljs-string">`salary`</span> = (<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">MAX</span>(salary) <span class="hljs-keyword">FROM</span> emp);* 子查询不同情况1. 子查询的结果是单行单列的：* 子查询可以作为条件，使用运算符去判断。 运算符： &gt; &gt;= &lt; &lt;= =* <span class="hljs-comment">-- 查询员工工资小于平均工资的人</span><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">WHERE</span> emp.salary &lt; (<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">AVG</span>(salary) <span class="hljs-keyword">FROM</span> emp);2. 子查询的结果是多行单列的：* 子查询可以作为条件，使用运算符in来判断<span class="hljs-comment">-- 查询'财务部'和'市场部'所有的员工信息</span><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">FROM</span> dept <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">NAME</span> = <span class="hljs-string">'财务部'</span> <span class="hljs-keyword">OR</span> <span class="hljs-keyword">NAME</span> = <span class="hljs-string">'市场部'</span>;<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">WHERE</span> dept_id = <span class="hljs-number">3</span> <span class="hljs-keyword">OR</span> dept_id = <span class="hljs-number">2</span>;<span class="hljs-comment">-- 子查询</span><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">WHERE</span> dept_id <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">FROM</span> dept <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">NAME</span> = <span class="hljs-string">'财务部'</span> <span class="hljs-keyword">OR</span> <span class="hljs-keyword">NAME</span> = <span class="hljs-string">'市场部'</span>);3. 子查询的结果是多行多列的：* 子查询可以作为一张虚拟表参与查询<span class="hljs-comment">-- 查询员工入职日期是2011-11-11日之后的员工信息和部门信息</span><span class="hljs-comment">-- 子查询</span><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> dept t1 ,(<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> emp <span class="hljs-keyword">WHERE</span> emp.<span class="hljs-string">`join_date`</span> &gt; <span class="hljs-string">'2011-11-11'</span>) t2<span class="hljs-keyword">WHERE</span> t1.id = t2.dept_id;<span class="hljs-comment">-- 普通内连接</span><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> emp t1,dept t2 <span class="hljs-keyword">WHERE</span> t1.<span class="hljs-string">`dept_id`</span> = t2.<span class="hljs-string">`id`</span> <span class="hljs-keyword">AND</span> t1.<span class="hljs-string">`join_date`</span> &gt;  <span class="hljs-string">'2011-11-11'</span>* 多表查询练习<span class="hljs-comment">-- 部门表</span><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> dept (  <span class="hljs-keyword">id</span> <span class="hljs-built_in">INT</span> PRIMARY <span class="hljs-keyword">KEY</span> PRIMARY <span class="hljs-keyword">KEY</span>, <span class="hljs-comment">-- 部门id</span>  dname <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">50</span>), <span class="hljs-comment">-- 部门名称</span>  loc <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-comment">-- 部门所在地</span>);<span class="hljs-comment">-- 添加4个部门</span><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> dept(<span class="hljs-keyword">id</span>,dname,loc) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">10</span>,<span class="hljs-string">'教研部'</span>,<span class="hljs-string">'北京'</span>),(<span class="hljs-number">20</span>,<span class="hljs-string">'学工部'</span>,<span class="hljs-string">'上海'</span>),(<span class="hljs-number">30</span>,<span class="hljs-string">'销售部'</span>,<span class="hljs-string">'广州'</span>),(<span class="hljs-number">40</span>,<span class="hljs-string">'财务部'</span>,<span class="hljs-string">'深圳'</span>);<span class="hljs-comment">-- 职务表，职务名称，职务描述</span><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> job (  <span class="hljs-keyword">id</span> <span class="hljs-built_in">INT</span> PRIMARY <span class="hljs-keyword">KEY</span>,  jname <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">20</span>),  description <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">50</span>));<span class="hljs-comment">-- 添加4个职务</span><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> job (<span class="hljs-keyword">id</span>, jname, description) <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">1</span>, <span class="hljs-string">'董事长'</span>, <span class="hljs-string">'管理整个公司，接单'</span>),(<span class="hljs-number">2</span>, <span class="hljs-string">'经理'</span>, <span class="hljs-string">'管理部门员工'</span>),(<span class="hljs-number">3</span>, <span class="hljs-string">'销售员'</span>, <span class="hljs-string">'向客人推销产品'</span>),(<span class="hljs-number">4</span>, <span class="hljs-string">'文员'</span>, <span class="hljs-string">'使用办公软件'</span>);</code></pre></div><div class="hljs"><pre><code class="hljs sql"><span class="hljs-comment">-- 员工表</span><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> emp (  <span class="hljs-keyword">id</span> <span class="hljs-built_in">INT</span> PRIMARY <span class="hljs-keyword">KEY</span>, <span class="hljs-comment">-- 员工id</span>  ename <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">50</span>), <span class="hljs-comment">-- 员工姓名</span>  job_id <span class="hljs-built_in">INT</span>, <span class="hljs-comment">-- 职务id</span>  mgr <span class="hljs-built_in">INT</span> , <span class="hljs-comment">-- 上级领导</span>  joindate <span class="hljs-built_in">DATE</span>, <span class="hljs-comment">-- 入职日期</span>  salary <span class="hljs-built_in">DECIMAL</span>(<span class="hljs-number">7</span>,<span class="hljs-number">2</span>), <span class="hljs-comment">-- 工资</span>  bonus <span class="hljs-built_in">DECIMAL</span>(<span class="hljs-number">7</span>,<span class="hljs-number">2</span>), <span class="hljs-comment">-- 奖金</span>  dept_id <span class="hljs-built_in">INT</span>, <span class="hljs-comment">-- 所在部门编号</span>  <span class="hljs-keyword">CONSTRAINT</span> emp_jobid_ref_job_id_fk <span class="hljs-keyword">FOREIGN</span> <span class="hljs-keyword">KEY</span> (job_id) <span class="hljs-keyword">REFERENCES</span> job (<span class="hljs-keyword">id</span>),  <span class="hljs-keyword">CONSTRAINT</span> emp_deptid_ref_dept_id_fk <span class="hljs-keyword">FOREIGN</span> <span class="hljs-keyword">KEY</span> (dept_id) <span class="hljs-keyword">REFERENCES</span> dept (<span class="hljs-keyword">id</span>));<span class="hljs-comment">-- 添加员工</span><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> emp(<span class="hljs-keyword">id</span>,ename,job_id,mgr,joindate,salary,bonus,dept_id) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1001</span>,<span class="hljs-string">'孙悟空'</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1004</span>,<span class="hljs-string">'2000-12-17'</span>,<span class="hljs-string">'8000.00'</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-number">20</span>),(<span class="hljs-number">1002</span>,<span class="hljs-string">'卢俊义'</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1006</span>,<span class="hljs-string">'2001-02-20'</span>,<span class="hljs-string">'16000.00'</span>,<span class="hljs-string">'3000.00'</span>,<span class="hljs-number">30</span>),(<span class="hljs-number">1003</span>,<span class="hljs-string">'林冲'</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1006</span>,<span class="hljs-string">'2001-02-22'</span>,<span class="hljs-string">'12500.00'</span>,<span class="hljs-string">'5000.00'</span>,<span class="hljs-number">30</span>),(<span class="hljs-number">1004</span>,<span class="hljs-string">'唐僧'</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1009</span>,<span class="hljs-string">'2001-04-02'</span>,<span class="hljs-string">'29750.00'</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-number">20</span>),(<span class="hljs-number">1005</span>,<span class="hljs-string">'李逵'</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1006</span>,<span class="hljs-string">'2001-09-28'</span>,<span class="hljs-string">'12500.00'</span>,<span class="hljs-string">'14000.00'</span>,<span class="hljs-number">30</span>),(<span class="hljs-number">1006</span>,<span class="hljs-string">'宋江'</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1009</span>,<span class="hljs-string">'2001-05-01'</span>,<span class="hljs-string">'28500.00'</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-number">30</span>),(<span class="hljs-number">1007</span>,<span class="hljs-string">'刘备'</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1009</span>,<span class="hljs-string">'2001-09-01'</span>,<span class="hljs-string">'24500.00'</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-number">10</span>),(<span class="hljs-number">1008</span>,<span class="hljs-string">'猪八戒'</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1004</span>,<span class="hljs-string">'2007-04-19'</span>,<span class="hljs-string">'30000.00'</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-number">20</span>),(<span class="hljs-number">1009</span>,<span class="hljs-string">'罗贯中'</span>,<span class="hljs-number">1</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-string">'2001-11-17'</span>,<span class="hljs-string">'50000.00'</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-number">10</span>),(<span class="hljs-number">1010</span>,<span class="hljs-string">'吴用'</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1006</span>,<span class="hljs-string">'2001-09-08'</span>,<span class="hljs-string">'15000.00'</span>,<span class="hljs-string">'0.00'</span>,<span class="hljs-number">30</span>),(<span class="hljs-number">1011</span>,<span class="hljs-string">'沙僧'</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1004</span>,<span class="hljs-string">'2007-05-23'</span>,<span class="hljs-string">'11000.00'</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-number">20</span>),(<span class="hljs-number">1012</span>,<span class="hljs-string">'李逵'</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1006</span>,<span class="hljs-string">'2001-12-03'</span>,<span class="hljs-string">'9500.00'</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-number">30</span>),(<span class="hljs-number">1013</span>,<span class="hljs-string">'小白龙'</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1004</span>,<span class="hljs-string">'2001-12-03'</span>,<span class="hljs-string">'30000.00'</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-number">20</span>),(<span class="hljs-number">1014</span>,<span class="hljs-string">'关羽'</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1007</span>,<span class="hljs-string">'2002-01-23'</span>,<span class="hljs-string">'13000.00'</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-number">10</span>);</code></pre></div><div class="hljs"><pre><code class="hljs sql"><span class="hljs-comment">-- 工资等级表</span><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> salarygrade (  grade <span class="hljs-built_in">INT</span> PRIMARY <span class="hljs-keyword">KEY</span>,   <span class="hljs-comment">-- 级别</span>  losalary <span class="hljs-built_in">INT</span>,  <span class="hljs-comment">-- 最低工资</span>  hisalary <span class="hljs-built_in">INT</span> <span class="hljs-comment">-- 最高工资</span>);<span class="hljs-comment">-- 添加5个工资等级</span><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> salarygrade(grade,losalary,hisalary) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>,<span class="hljs-number">7000</span>,<span class="hljs-number">12000</span>),(<span class="hljs-number">2</span>,<span class="hljs-number">12010</span>,<span class="hljs-number">14000</span>),(<span class="hljs-number">3</span>,<span class="hljs-number">14010</span>,<span class="hljs-number">20000</span>),(<span class="hljs-number">4</span>,<span class="hljs-number">20010</span>,<span class="hljs-number">30000</span>),(<span class="hljs-number">5</span>,<span class="hljs-number">30010</span>,<span class="hljs-number">99990</span>);<span class="hljs-comment">-- 需求：</span><span class="hljs-comment">-- 1.查询所有员工信息。查询员工编号，员工姓名，工资，职务名称，职务描述</span><span class="hljs-comment">/*</span><span class="hljs-comment">分析：</span><span class="hljs-comment">1.员工编号，员工姓名，工资，需要查询emp表  职务名称，职务描述 需要查询job表</span><span class="hljs-comment">2.查询条件 emp.job_id = job.id</span><span class="hljs-comment"></span><span class="hljs-comment">*/</span><span class="hljs-keyword">SELECT</span> t1.<span class="hljs-string">`id`</span>, <span class="hljs-comment">-- 员工编号</span>t1.<span class="hljs-string">`ename`</span>, <span class="hljs-comment">-- 员工姓名</span>t1.<span class="hljs-string">`salary`</span>,<span class="hljs-comment">-- 工资</span>t2.<span class="hljs-string">`jname`</span>, <span class="hljs-comment">-- 职务名称</span>t2.<span class="hljs-string">`description`</span> <span class="hljs-comment">-- 职务描述</span><span class="hljs-keyword">FROM</span> emp t1, job t2<span class="hljs-keyword">WHERE</span> t1.<span class="hljs-string">`job_id`</span> = t2.<span class="hljs-string">`id`</span>;</code></pre></div><div class="hljs"><pre><code class="hljs java">-- <span class="hljs-number">2</span>.查询员工编号，员工姓名，工资，职务名称，职务描述，部门名称，部门位置<span class="hljs-comment">/*</span><span class="hljs-comment">分析：</span><span class="hljs-comment">1. 员工编号，员工姓名，工资 emp  职务名称，职务描述 job  部门名称，部门位置 dept</span><span class="hljs-comment">2. 条件： emp.job_id = job.id and emp.dept_id = dept.id</span><span class="hljs-comment">*/</span>SELECT t1.`id`, -- 员工编号t1.`ename`, -- 员工姓名t1.`salary`,-- 工资t2.`jname`, -- 职务名称t2.`description`, -- 职务描述t3.`dname`, -- 部门名称t3.`loc` -- 部门位置FROM emp t1, job t2,dept t3WHERE t1.`job_id` = t2.`id` AND t1.`dept_id` = t3.`id`;   -- <span class="hljs-number">3</span>.查询员工姓名，工资，工资等级<span class="hljs-comment">/*</span><span class="hljs-comment">分析：</span><span class="hljs-comment">1.员工姓名，工资 emp  工资等级 salarygrade</span><span class="hljs-comment">2.条件 emp.salary &gt;= salarygrade.losalary and emp.salary &lt;= salarygrade.hisalary</span><span class="hljs-comment">emp.salary BETWEEN salarygrade.losalary and salarygrade.hisalary</span><span class="hljs-comment">*/</span>SELECT t1.ename ,t1.`salary`,t2.*FROM emp t1, salarygrade t2WHERE t1.`salary` BETWEEN t2.`losalary` AND t2.`hisalary`;</code></pre></div><div class="hljs"><pre><code class="hljs java">-- <span class="hljs-number">4</span>.查询员工姓名，工资，职务名称，职务描述，部门名称，部门位置，工资等级<span class="hljs-comment">/*</span><span class="hljs-comment">分析：</span><span class="hljs-comment">1. 员工姓名，工资 emp ， 职务名称，职务描述 job 部门名称，部门位置，dept  工资等级 salarygrade</span><span class="hljs-comment">2. 条件： emp.job_id = job.id and emp.dept_id = dept.id and emp.salary BETWEEN salarygrade.losalary and salarygrade.hisalary</span><span class="hljs-comment"></span><span class="hljs-comment">*/</span>SELECT t1.`ename`,t1.`salary`,t2.`jname`,t2.`description`,t3.`dname`,t3.`loc`,t4.`grade`FROM emp t1,job t2,dept t3,salarygrade t4WHERE t1.`job_id` = t2.`id` AND t1.`dept_id` = t3.`id`AND t1.`salary` BETWEEN t4.`losalary` AND t4.`hisalary`;</code></pre></div><div class="hljs"><pre><code class="hljs java">-- <span class="hljs-number">5</span>.查询出部门编号、部门名称、部门位置、部门人数<span class="hljs-comment">/*</span><span class="hljs-comment">分析：</span><span class="hljs-comment">1.部门编号、部门名称、部门位置 dept 表。 部门人数 emp表</span><span class="hljs-comment">2.使用分组查询。按照emp.dept_id完成分组，查询count(id)</span><span class="hljs-comment">3.使用子查询将第2步的查询结果和dept表进行关联查询</span><span class="hljs-comment"></span><span class="hljs-comment">*/</span>SELECT t1.`id`,t1.`dname`,t1.`loc` , t2.totalFROM dept t1,(SELECTdept_id,COUNT(id) totalFROM empGROUP BY dept_id) t2WHERE t1.`id` = t2.dept_id;</code></pre></div><div class="hljs"><pre><code class="hljs java">-- <span class="hljs-number">6</span>.查询所有员工的姓名及其直接上级的姓名,没有领导的员工也需要查询<span class="hljs-comment">/*</span><span class="hljs-comment">分析：</span><span class="hljs-comment">1.姓名 emp， 直接上级的姓名 emp</span><span class="hljs-comment">* emp表的id 和 mgr 是自关联</span><span class="hljs-comment">2.条件 emp.id = emp.mgr</span><span class="hljs-comment">3.查询左表的所有数据，和 交集数据</span><span class="hljs-comment">* 使用左外连接查询</span><span class="hljs-comment"></span><span class="hljs-comment">*/</span><span class="hljs-comment">/*</span><span class="hljs-comment">select</span><span class="hljs-comment">t1.ename,</span><span class="hljs-comment">t1.mgr,</span><span class="hljs-comment">t2.`id`,</span><span class="hljs-comment">t2.ename</span><span class="hljs-comment">from emp t1, emp t2</span><span class="hljs-comment">where t1.mgr = t2.`id`;</span><span class="hljs-comment"></span><span class="hljs-comment">*/</span>SELECT t1.ename,t1.mgr,t2.`id`,t2.`ename`FROM emp t1LEFT JOIN emp t2ON t1.`mgr` = t2.`id`;</code></pre></div><h1 id="九、事务"><a href="#九、事务" class="headerlink" title="九、事务"></a>九、事务</h1><div class="hljs"><pre><code class="hljs sql">1. 事务的基本介绍1. 概念：*  如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。2. 操作：1. 开启事务： <span class="hljs-keyword">start</span> <span class="hljs-keyword">transaction</span>;2. 回滚：<span class="hljs-keyword">rollback</span>;3. 提交：<span class="hljs-keyword">commit</span>;3. 例子：<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">account</span> (<span class="hljs-keyword">id</span> <span class="hljs-built_in">INT</span> PRIMARY <span class="hljs-keyword">KEY</span> AUTO_INCREMENT,<span class="hljs-keyword">NAME</span> <span class="hljs-built_in">VARCHAR</span>(<span class="hljs-number">10</span>),balance <span class="hljs-keyword">DOUBLE</span>);<span class="hljs-comment">-- 添加数据</span><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">account</span> (<span class="hljs-keyword">NAME</span>, balance) <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">'zhangsan'</span>, <span class="hljs-number">1000</span>), (<span class="hljs-string">'lisi'</span>, <span class="hljs-number">1000</span>);<span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">account</span>;<span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">account</span> <span class="hljs-keyword">SET</span> balance = <span class="hljs-number">1000</span>;<span class="hljs-comment">-- 张三给李四转账 500 元</span><span class="hljs-comment">-- 0. 开启事务</span><span class="hljs-keyword">START</span> <span class="hljs-keyword">TRANSACTION</span>;<span class="hljs-comment">-- 1. 张三账户 -500</span><span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">account</span> <span class="hljs-keyword">SET</span> balance = balance - <span class="hljs-number">500</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">NAME</span> = <span class="hljs-string">'zhangsan'</span>;<span class="hljs-comment">-- 2. 李四账户 +500</span><span class="hljs-comment">-- 出错了...</span><span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">account</span> <span class="hljs-keyword">SET</span> balance = balance + <span class="hljs-number">500</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">NAME</span> = <span class="hljs-string">'lisi'</span>;<span class="hljs-comment">-- 发现执行没有问题，提交事务</span><span class="hljs-keyword">COMMIT</span>;<span class="hljs-comment">-- 发现出问题了，回滚事务</span><span class="hljs-keyword">ROLLBACK</span>;</code></pre></div><div class="hljs"><pre><code>4. MySQL数据库中事务默认自动提交    * 事务提交的两种方式：        * 自动提交：            * mysql就是自动提交的            * 一条DML(增删改)语句会自动提交一次事务。        * 手动提交：            * Oracle 数据库默认是手动提交事务            * 需要先开启事务，再提交    * 修改事务的默认提交方式：        * 查看事务的默认提交方式：SELECT @@autocommit; -- 1 代表自动提交  0 代表手动提交        * 修改默认提交方式： set @@autocommit = 0;</code></pre></div><div class="hljs"><pre><code class="hljs sql">2. 事务的四大特征：1. 原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。2. 持久性：当事务提交或回滚后，数据库会持久化的保存数据。3. 隔离性：多个事务之间。相互独立。4. 一致性：事务操作前后，数据总量不变3. 事务的隔离级别（了解）* 概念：多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。* 存在问题：1. 脏读：一个事务，读取到另一个事务中没有提交的数据2. 不可重复读(虚读)：在同一个事务中，两次读取到的数据不一样。3. 幻读：一个事务操作(DML)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。* 隔离级别：1. read uncommitted：读未提交* 产生的问题：脏读、不可重复读、幻读2. read committed：读已提交 （Oracle）* 产生的问题：不可重复读、幻读3. repeatable read：可重复读 （MySQL默认）* 产生的问题：幻读4. serializable：串行化* 可以解决所有的问题* 注意：隔离级别从小到大安全性越来越高，但是效率越来越低* 数据库查询隔离级别：* select @@tx_isolation;* 数据库设置隔离级别：* set global transaction isolation level  级别字符串;* 演示：<span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> <span class="hljs-keyword">transaction</span> <span class="hljs-keyword">isolation</span> <span class="hljs-keyword">level</span> <span class="hljs-keyword">read</span> uncommitted;<span class="hljs-keyword">start</span> <span class="hljs-keyword">transaction</span>;<span class="hljs-comment">-- 转账操作</span><span class="hljs-keyword">update</span> <span class="hljs-keyword">account</span> <span class="hljs-keyword">set</span> balance = balance - <span class="hljs-number">500</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> = <span class="hljs-number">1</span>;<span class="hljs-keyword">update</span> <span class="hljs-keyword">account</span> <span class="hljs-keyword">set</span> balance = balance + <span class="hljs-number">500</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">id</span> = <span class="hljs-number">2</span>;</code></pre></div><h1 id="十、DCL"><a href="#十、DCL" class="headerlink" title="十、DCL"></a>十、DCL</h1><div class="hljs"><pre><code class="hljs sql">* SQL分类：1. DDL：操作数据库和表2. DML：增删改表中数据3. DQL：查询表中数据4. DCL：管理用户，授权* DBA：数据库管理员* DCL：管理用户，授权1. 管理用户1. 添加用户：* 语法：CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码';2. 删除用户：* 语法：DROP USER '用户名'@'主机名';3. 修改用户密码：<span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">USER</span> <span class="hljs-keyword">SET</span> <span class="hljs-keyword">PASSWORD</span> = <span class="hljs-keyword">PASSWORD</span>(<span class="hljs-string">'新密码'</span>) <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">USER</span> = <span class="hljs-string">'用户名'</span>;<span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">USER</span> <span class="hljs-keyword">SET</span> <span class="hljs-keyword">PASSWORD</span> = <span class="hljs-keyword">PASSWORD</span>(<span class="hljs-string">'abc'</span>) <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">USER</span> = <span class="hljs-string">'lisi'</span>;<span class="hljs-keyword">SET</span> <span class="hljs-keyword">PASSWORD</span> <span class="hljs-keyword">FOR</span> <span class="hljs-string">'用户名'</span>@<span class="hljs-string">'主机名'</span> = <span class="hljs-keyword">PASSWORD</span>(<span class="hljs-string">'新密码'</span>);<span class="hljs-keyword">SET</span> <span class="hljs-keyword">PASSWORD</span> <span class="hljs-keyword">FOR</span> <span class="hljs-string">'root'</span>@<span class="hljs-string">'localhost'</span> = <span class="hljs-keyword">PASSWORD</span>(<span class="hljs-string">'123'</span>);* mysql中忘记了root用户的密码？1. cmd <span class="hljs-comment">-- &gt; net stop mysql 停止mysql服务</span>* 需要管理员运行该cmd2. 使用无验证方式启动mysql服务： mysqld <span class="hljs-comment">--skip-grant-tables</span>3. 打开新的cmd窗口,直接输入mysql命令，敲回车。就可以登录成功4. <span class="hljs-keyword">use</span> mysql;5. <span class="hljs-keyword">update</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> <span class="hljs-keyword">password</span> = <span class="hljs-keyword">password</span>(<span class="hljs-string">'你的新密码'</span>) <span class="hljs-keyword">where</span> <span class="hljs-keyword">user</span> = <span class="hljs-string">'root'</span>;6. 关闭两个窗口7. 打开任务管理器，手动结束mysqld.exe 的进程8. 启动mysql服务9. 使用新密码登录。4. 查询用户：<span class="hljs-comment">-- 1. 切换到mysql数据库</span><span class="hljs-keyword">USE</span> myql;<span class="hljs-comment">-- 2. 查询user表</span><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">USER</span>;* 通配符： % 表示可以在任意主机使用用户登录数据库2. 权限管理：1. 查询权限：<span class="hljs-comment">-- 查询权限</span><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">GRANTS</span> <span class="hljs-keyword">FOR</span> <span class="hljs-string">'用户名'</span>@<span class="hljs-string">'主机名'</span>;<span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">GRANTS</span> <span class="hljs-keyword">FOR</span> <span class="hljs-string">'lisi'</span>@<span class="hljs-string">'%'</span>;2. 授予权限：<span class="hljs-comment">-- 授予权限</span><span class="hljs-keyword">grant</span> 权限列表 <span class="hljs-keyword">on</span> 数据库名.表名 <span class="hljs-keyword">to</span> <span class="hljs-string">'用户名'</span>@<span class="hljs-string">'主机名'</span>;<span class="hljs-comment">-- 给张三用户授予所有权限，在任意数据库任意表上</span><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> <span class="hljs-keyword">ON</span> *.* <span class="hljs-keyword">TO</span> <span class="hljs-string">'zhangsan'</span>@<span class="hljs-string">'localhost'</span>;3. 撤销权限：<span class="hljs-comment">-- 撤销权限：</span><span class="hljs-keyword">revoke</span> 权限列表 <span class="hljs-keyword">on</span> 数据库名.表名 <span class="hljs-keyword">from</span> <span class="hljs-string">'用户名'</span>@<span class="hljs-string">'主机名'</span>;<span class="hljs-keyword">REVOKE</span> <span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">ON</span> db3.<span class="hljs-string">`account`</span> <span class="hljs-keyword">FROM</span> <span class="hljs-string">'lisi'</span>@<span class="hljs-string">'%'</span>;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python/认识Python</title>
    <link href="/2020/07/03/Python/%E8%AE%A4%E8%AF%86Python/"/>
    <url>/2020/07/03/Python/%E8%AE%A4%E8%AF%86Python/</url>
    
    <content type="html"><![CDATA[<h1 id="一、python概述"><a href="#一、python概述" class="headerlink" title="一、python概述"></a>一、python概述</h1><ol><li>解释性脚本语言：Python语言写的程序不需要编译成二进制代码，可以直接从源代码运行程序。Python解释器把源代码转换成字节码的中间形式，然后再把它翻译成计算机使用的机器语言并运行</li><li>Python底层以及很多标准库和第三方库都是使用C语言写的，速度快</li><li>可移植性：由于开源，以及被移植在许多平台上（结果改动使它能够工作在不同平台上），例如Windows、Linux等</li></ol><h1 id="二、Python执行过程"><a href="#二、Python执行过程" class="headerlink" title="二、Python执行过程"></a>二、Python执行过程</h1><ol><li>先将.py文件中的源代码编译成字节码，字节码文件通常是.pyc格式</li><li>然后由Python虚拟机（Python Virtual Machine）执行字节码。<ul><li>python虚拟机相比java或.net虚拟机距离真实机器的距离更远</li><li>python可以以交互模式运行。比如Windows操作系统下可以直接在命令模式下直接实现交互操作</li></ul></li></ol><h1 id="三、Python标准库"><a href="#三、Python标准库" class="headerlink" title="三、Python标准库"></a>三、Python标准库</h1><ol><li>Python标准库提供系统管理、网络通信、数据库接口等功能。接口清晰。</li><li>第三方库使用方式和标准库类似，功能强大。</li><li>内置库可以通过import语句导入</li><li>外部库需要先下载，再在CMD命令窗口在pip.exede同级目录下输入 pip install 库名。外部库储存在include文件夹中。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C/加深理解</title>
    <link href="/2020/07/02/C/%E5%8A%A0%E6%B7%B1%E7%90%86%E8%A7%A3/"/>
    <url>/2020/07/02/C/%E5%8A%A0%E6%B7%B1%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="字符串标准函数"><a href="#字符串标准函数" class="headerlink" title="字符串标准函数"></a>字符串标准函数</h1><p>字符串标准函数的原型在头文件string.h中</p><ul><li><p>输入字符串：gets（字符数组名）。该函数输入的字符串中允许包含空格，而scanf（）不允许</p></li><li><p>输出字符串：puts（字符数组名）</p></li><li><p>求字符串长度：strlen（字符数组名）</p><h1 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h1></li><li><p>除数、被除数都是整数，结果也是整数。结果不能整除的情况下直接丢掉小数</p></li><li><p>除数、被除数有一个小数，结果也是小数，并且是double类型</p></li></ul><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><ol><li>声明数组a[11]表示有11个数，即a[0]到a[10]</li><li>内层外层循环的变量不能相同</li></ol><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><ol><li>理解<br>结构体其实是将数组、变量、指针变量等做了个封装，成为我们定义的一个新的数据类型。我们就可以把封装起来的内容作为整体对待。新数据类型每定义一个变量，就可以同时存储多个变量、数组等。</li><li>使用<div class="hljs"><pre><code class="hljs stan">struct queue&#123;<span class="hljs-keyword">int</span> <span class="hljs-title">data</span>[<span class="hljs-number">100</span>];<span class="hljs-comment">//队列的主体，用来存储内容 </span><span class="hljs-keyword">int</span> <span class="hljs-built_in">head</span>;<span class="hljs-comment">//队首 </span><span class="hljs-keyword">int</span> <span class="hljs-built_in">tail</span>;<span class="hljs-comment">//队尾 </span>&#125;;</code></pre></div></li></ol><ul><li>struct是结构体关键字，queue是为结构体起的名字</li><li>定义结构体的变量时不能忽略掉struct，例如：struct queue q；</li><li>末尾有分号</li><li>通常main函数外面</li></ul><ol start="3"><li>成员运算符 <code>.</code><br>声明的结构体变量用来访问结构体内部成员。例如：<div class="hljs"><pre><code class="hljs stan">struct queue&#123;<span class="hljs-keyword">int</span> <span class="hljs-title">data</span>[<span class="hljs-number">100</span>];<span class="hljs-comment">//队列的主体，用来存储内容 </span><span class="hljs-keyword">int</span> <span class="hljs-built_in">head</span>;<span class="hljs-comment">//队首 </span><span class="hljs-keyword">int</span> <span class="hljs-built_in">tail</span>;<span class="hljs-comment">//队尾 </span>&#125;;</code></pre></div><div class="hljs"><pre><code class="hljs routeros">struct<span class="hljs-built_in"> queue </span>q;q.<span class="hljs-attribute">head</span>=1;q.<span class="hljs-attribute">tail</span>=1;</code></pre></div></li><li>结构体指针运算符 <code>-&gt;</code><br>指向结构体的指针用来访问结构体内部成员。例如：</li></ol><div class="hljs"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">int</span> data;    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">next</span>;</span>&#125;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> *<span class="hljs-title">p</span>;</span>p=(struct node *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(struct node));<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;a);p-&gt;data=a; <span class="hljs-comment">//数据存储到当前节点的data域中</span>p-&gt;next=<span class="hljs-literal">NULL</span>;</code></pre></div><h1 id="指针和malloc函数"><a href="#指针和malloc函数" class="headerlink" title="指针和malloc函数"></a>指针和malloc函数</h1><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><ol><li><p>指针存储着一个内存空间的地址</p></li><li><p>定义一个指针</p><div class="hljs"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> a；<span class="hljs-built_in">int</span> * p；</code></pre></div><p>定义一个指针，只需在变量前面加一个 <code>*</code> 号。这里的指针只能存储一个<strong>存放整数的内存空间</strong>的地址</p></li><li><p>指针如何存储地址</p><div class="hljs"><pre><code class="hljs ini"><span class="hljs-attr">p</span> = &amp;a<span class="hljs-comment">;</span></code></pre></div><p><code>&amp;</code>叫取地址符。这样整形指针p获得了整型变量a的地址。理解为指针p指向了整型变量a</p></li><li><p>可以通过指针p来操作变量a。<br>例如，输出变量a的值</p><div class="hljs"><pre><code class="hljs perl"><span class="hljs-keyword">int</span> a=<span class="hljs-number">10</span>；<span class="hljs-keyword">int</span> * p；p=&amp;a；<span class="hljs-keyword">printf</span>(<span class="hljs-string">"%d"</span>,* p);</code></pre></div><p>这里的 * 号是间接访问运算符。作用是取得指针p所指向的内存中的值。</p></li><li><p>C语言中 * 号有三个用途</p><ul><li>乘号。加减乘除</li><li>声明指针变量。在定义指针变量时使用，如：int * p；</li><li>取得指针所指向的内存中的值。简介访问运算符。例如printf(“%d”,* p);</li></ul></li></ol><h2 id="malloc函数"><a href="#malloc函数" class="headerlink" title="malloc函数"></a>malloc函数</h2><ol start="6"><li><p>在内存中存储整数10</p><ul><li>int a=10;</li><li>malloc(4);</li></ul></li><li><p>使用malloc函数会从内存中申请分配指定字节大小的内存空间。此处申请的是4个字节。不知道int类型4个字节还可以通过sizeof(int)获取int类型所占字节数。申请好4个字节空间后，就需要用一个指针来指向这个空间。</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> * p;p=(<span class="hljs-keyword">int</span> * )<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));</code></pre></div><p>需要注意的是，malloc函数返回类型是void * 类型。void * 表示未确定类型的指针。在C语言和C++，可被强制转换为任何其他类型的指针。此处我们将其强制转化为整形指针</p></li><li><p>指针存储的是某空间地址，那为什么分不同类型的指针呢？<br>是为了让系统知道某空间应该取多少个连续内存作为一个数据。</p></li><li><p>例子<br>存储整数10的代码如下</p><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> *p;p=(<span class="hljs-keyword">int</span> * )<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));* p=<span class="hljs-number">10</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,* p);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;</code></pre></div></li><li><p>为什么要用如此复杂的办法存储数据？<br>预先的方法我们必须预先准确的知道所需变量的个数，也就是说我们必须定义出所有变量。定义一百个，程序就只能存储一百个。通过malloc函数我们可以在程序运行的过程中根据实际情况来申请空间</p></li></ol><p><strong>最后：</strong>个人觉得指针和malloc函数谁都离不开谁。malloc申请的内存需要指针指示，而指针用来指示一个不确定的空间才发挥了真正作用。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>getchar();和system(“pause”)都可以用来防止程序结果一闪而过。后者包含在头文件stdlib.h中</p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DataStructureAndAlgorithm/数据结构与算法</title>
    <link href="/2020/07/02/DataStructureAndAlgorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <url>/2020/07/02/DataStructureAndAlgorithm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="刷题顺序"><a href="#刷题顺序" class="headerlink" title="刷题顺序"></a>刷题顺序</h1><ul><li>基础篇<ul><li>数组，队列，栈</li><li>链表</li><li>树与递归</li><li>哈希表</li><li>双指针</li></ul></li><li>思想篇<ul><li>二分</li><li>滑动窗口</li><li>搜索（BFS，DFS，回溯)</li><li>动态规划</li></ul></li><li>提高<ul><li>贪心</li><li>分治</li><li>位运算</li><li>KMP &amp; RK</li><li>并查集</li><li>前缀树</li><li>线段树</li><li>堆</li></ul></li></ul><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><ol><li>tail不直接记录队尾，却要记录队尾的下一个位置，是为了队列中只剩下一个元素时，队首和队尾重合时会带来一些麻烦。队首和队尾重合时，队列为空</li><li>队列规定的是先进先出</li><li>队列实质<ul><li>数组和具有指针性质的变量封装成了一个结构体</li><li></li></ul></li></ol><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><ol><li>链表是变量和指针封装成了一个结点结构体</li><li>循环打印输出时，判断是否到最后一个结点的条件是用来后移的指针是否为NULL</li></ol>]]></content>
    
    
    <categories>
      
      <category>DataStructureAndAlgorithm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java/使用IntelliJ IDEA</title>
    <link href="/2020/07/02/Java/%E4%BD%BF%E7%94%A8IntelliJ%20IDEA/"/>
    <url>/2020/07/02/Java/%E4%BD%BF%E7%94%A8IntelliJ%20IDEA/</url>
    
    <content type="html"><![CDATA[<h1 id="一、项目结构"><a href="#一、项目结构" class="headerlink" title="一、项目结构"></a>一、项目结构</h1><p>项目Project——&gt;模块module——&gt;包package——&gt;类class</p><h1 id="二、Setting"><a href="#二、Setting" class="headerlink" title="二、Setting"></a>二、Setting</h1><ol><li>设置font的大小和字体</li><li>设置自动补全快捷键</li></ol><h1 id="三、快捷键"><a href="#三、快捷键" class="headerlink" title="三、快捷键"></a>三、快捷键</h1><ol><li><code>alt</code>+<code>回车</code> 导入包，自动修正代码</li><li><code>ctrl</code>+<code>alt</code>+<code>L</code>格式化代码</li><li><code>ctrl</code>+<code>/</code>单行注释，再按取消注释</li><li><code>ctrl</code>+<code>shift</code>+<code>/</code>多行注释，再按取消注释</li><li><code>alt</code>+<code>Insert</code>自动生成代码，toString，get，set等方法</li><li><code>alt</code>+<code>shift</code>+<code>上下箭头</code>移动当前代码行</li><li><code>alt</code>+<code>enter</code>代码抛异常</li><li><code>ctrl</code>+<code>alt</code>+<code>v</code>自动生成方法返回值</li><li><code>ctrl</code>+<code>alt</code>+<code>t</code>包裹代码</li></ol><h1 id="四、名称要求"><a href="#四、名称要求" class="headerlink" title="四、名称要求"></a>四、名称要求</h1><ol><li>类名：首字母要大写</li><li>包名Package：小写字母、句点、数字构成。例如：cn.itcast.hellojava20200703.demo01</li><li>模块名module：</li><li>工程名Project</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络/计算机网络</title>
    <link href="/2020/06/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2020/06/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="一、计算机网络概述"><a href="#一、计算机网络概述" class="headerlink" title="一、计算机网络概述"></a>一、计算机网络概述</h1><h2 id="1-1计算机网络在信息时代的作用"><a href="#1-1计算机网络在信息时代的作用" class="headerlink" title="1.1计算机网络在信息时代的作用"></a>1.1计算机网络在信息时代的作用</h2><p>三网：</p><ol><li><p>电信网络（电话）</p></li><li><p>计算机网络（因特网、其他网络等）</p></li><li><p>有线电视网络</p><h2 id="1-2因特网概述"><a href="#1-2因特网概述" class="headerlink" title="1.2因特网概述"></a>1.2因特网概述</h2></li><li><p>概述：</p><ul><li>网络：交换机将多台电脑连接（如电脑机房）</li><li>互联网：路由器连接多个网络</li><li>因特网：全球最大的一个互联网（TCP/IP Suite）</li></ul></li><li><p>多层次ISP结构的互联网：<br>第一层ISP、NAP——&gt; 第二层ISP、大公司——&gt; 第三层ISP ——&gt;本地ISP、公司——&gt;校园网</p></li><li><p>ISP、企业网以及网民</p><ul><li>各小区、工厂局域网 ——&gt;ISP运营商（电信、网通等）——&gt;电信机房、网通机房、双线机房等（跨运营商传输会变慢，双线机房很有必要）</li><li>网站——&gt;服务器（托管到机房、阿里云服务器等）</li></ul></li><li><p>因特网的标准化工作：因特网协会ISOC</p><h2 id="1-3因特网的组成"><a href="#1-3因特网的组成" class="headerlink" title="1.3因特网的组成"></a>1.3因特网的组成</h2></li><li><p>核心部分：数据交换方式</p><ul><li>电路交换方式：事先建立连接。电话-交换机-电话。</li><li>电路交换面向连接：电话-交换机-中继线-交换机-电话</li><li>分组交换方式：报文分组（不需要选择好路径，不确定路径）</li><li>报文交换 ：不分组直接传送（时间短）</li></ul></li><li><p>边缘部分：客户和服务器<br>主机之间的通信方式：</p><ul><li>客户服务器方式（C/S）</li><li>对等连接方式（P2P）：下载东西不是从一个地方下载，计算机既是客户端，又是服务器、路由器的存储转发功能</li></ul></li></ol><h2 id="1-4计算机网络的类别"><a href="#1-4计算机网络的类别" class="headerlink" title="1.4计算机网络的类别"></a>1.4计算机网络的类别</h2><ol><li><p>作用范围</p><ul><li>广域网：应用广域网技术，如电脑通过ADSL到运营商然后再去和邻居通信；花钱买服务，花钱买带宽</li><li>局域网：应用局域网技术，如电脑通过无线交流；自己购买设备，自己维护，带宽固定，距离100米以内</li></ul></li><li><p>使用者</p><ul><li>公用网</li><li>专用网</li></ul></li><li><p>拓扑结构</p><ul><li>总线型：计算机用一根线连接</li><li>环形：计算机接在环上</li><li>星型：计算机接在交换机上</li><li>树型：根交换机，分支交换机</li><li>网状：路由器连的网</li></ul></li><li><p>交换方式</p><ul><li>电路交换网</li><li>报文交换网</li><li>分组交换网</li></ul></li><li><p>工作方式：资源子网</p><ul><li>通信子网</li><li>接入网<h2 id="1-5计算机网络的性能"><a href="#1-5计算机网络的性能" class="headerlink" title="1.5计算机网络的性能"></a>1.5计算机网络的性能</h2></li></ul></li><li><p>速率：数字信道上传送数据位数的速率</p></li><li><p>带宽：数字信道所传送的最高速率</p></li><li><p>吞吐量：单位时间所有数据量总和</p></li><li><p>时延：发送时延、传播时延、处理时延、排队时延</p></li><li><p>时延带宽积：传播时延×带宽</p></li><li><p>往返时间：发数据到确认接收的时间</p></li><li><p>利用率：</p><ul><li>信道利用率：有数据通过时间/总时间</li><li>网络利用率：信道利用率加权平均值<h2 id="1-6计算机网络的体系结构"><a href="#1-6计算机网络的体系结构" class="headerlink" title="1.6计算机网络的体系结构"></a>1.6计算机网络的体系结构</h2></li></ul></li><li><p>基本概念</p><ul><li>ISO 国际标准化组织</li><li>OSI/RM 互联网法律上的国际标准</li><li>TCP/IP Suite 因特网事实上的国际标准</li><li>Network Protocols 数据交换遵守的规则、标准或约定</li><li>网络体系结构 计算机网络各层及其协议的集合</li></ul></li><li><p>OSI 七层</p><ul><li>应用层：能够产生网络流量能够和用户交互的应用程序（记事本不是应用层）开发人员考虑的问题</li><li>表示层：加密 压缩</li><li>会话层：服务和客户端建立的会话 查木马 netstat -nb </li><li>传输层 可靠传输建立会话 不可靠传输 流量控制</li><li>网络层：IP地址编址 选择最佳路径</li><li>数据链路层：数据如何封装 添加物理层地址 MAC地址</li><li>物理层：规定一些标准 电压 接口<blockquote><p>前三层是程序开发人员解决，接下来三层是网络工程师要解决的问题</p></blockquote></li></ul></li></ol><blockquote><p>网络排错：从底层到高层<br>物理层：网线<br>网络层：IP地址<br>应用层：浏览器是不是中了恶意插件</p></blockquote><blockquote><p>网络安全和OSI参考模型</p><ul><li>物理层安全：接入同一个交换机的电脑可能别人会接入你的电脑</li><li>数据链路层安全 ADSL的密码输入才可以打开网络 无线AP密码</li><li>网络层安全 哪片网络可以通过路由器出去</li><li>应用层安全 SQL注入漏洞 上传漏洞</li></ul><ol start="3"><li>开放系统信息交换设计的概念：实体、协议、服务、服务访问点</li><li>五层协议对应的数据单元</li></ol></blockquote><ul><li>应用层：传输数据单元</li><li>运输层：报文 加协议</li><li>网络层：数据报  加IP地址 数据包</li><li>数据链路层：数据帧 加MAC地址</li><li>物理层：比特0110… 加帧头帧尾<blockquote><p>电脑MAC地址是刻在电脑上的，但是可以修改和互联网接入时使用的MAC地址，修改后可以蹭网~<br>计算机匹配时注意网速也要匹配才能接通 自动协商即可</p></blockquote></li></ul><ol start="5"><li>虚拟机的网络设置</li></ol><h1 id="二、物理层"><a href="#二、物理层" class="headerlink" title="二、物理层"></a>二、物理层</h1><h2 id="2-1物理层的基本概念"><a href="#2-1物理层的基本概念" class="headerlink" title="2.1物理层的基本概念"></a>2.1物理层的基本概念</h2><ol><li>物理层：解决如何在传输媒体传输数据比特流，而不是指具体传输媒体</li><li>物理层确定与传输媒体的接口的一些特性：机械特性、电气特性、功能特性等</li></ol><h2 id="2-2数据通信的基础知识"><a href="#2-2数据通信的基础知识" class="headerlink" title="2.2数据通信的基础知识"></a>2.2数据通信的基础知识</h2><h3 id="2-2-1典型的数据通信模型"><a href="#2-2-1典型的数据通信模型" class="headerlink" title="2.2.1典型的数据通信模型"></a>2.2.1典型的数据通信模型</h3><p><u>PC机（输入汉字)</u>——&gt;变为数字比特流——&gt;<u>调制解调器</u>——&gt;变为模拟信号——&gt;<u>公用电话网</u>——&gt;变为模拟信号——&gt;<u>调制解调器</u>——&gt;变为数字比特流——&gt;<u>PC机</u></p><blockquote><p>源系统——&gt;传输系统——&gt;目的系统</p></blockquote><h3 id="2-2-2数据通信的基础知识"><a href="#2-2-2数据通信的基础知识" class="headerlink" title="2.2.2数据通信的基础知识"></a>2.2.2数据通信的基础知识</h3><ol><li><p>相关术语：通信、消息、数据、信号、模拟信号、数字信号、码元（波形）</p></li><li><p>有关信道的几个基本概念：信道是指传送信息的媒体 发送和接受的两条信道</p><ul><li>单向通信 单工通信 一个方向通信无双方交互 电台电视台.</li><li>双向交替通信 半双工通信 并不能同时发送或者接收 对讲机</li><li>双向同时通信 全双工通信 同时发送、接收 打电话</li></ul></li><li><p>基带信号和带通信号</p><ul><li>基带信号：源信号 传输距离短</li><li>带通信号：经过了调频 传输距离远</li></ul></li><li><p>几种最基本的调制方法：调幅、调频、 调相</p></li><li><p>常用编码：单极性不归零码、双极性不归零码、单极性归零码、双极性归零码、曼彻斯特编码、差分曼彻斯特编码（抗干扰性强）</p></li><li><p>信道的极限容量：发送信号波形会失真，如果失真大就难以识别  奈式准则</p></li></ol><blockquote><p>奈式准则：理想低通信道的最高码元传输速率<br>香农公式：带宽受限和干扰情况下信道的极限信息传输速率<br>奈式准则和香农公式的应用范围</p></blockquote><h2 id="2-3-物理层下面的传输媒体"><a href="#2-3-物理层下面的传输媒体" class="headerlink" title="2.3 物理层下面的传输媒体"></a>2.3 物理层下面的传输媒体</h2><ol><li><p>电信领域使用的电磁波的频谱</p></li><li><p>导向传输媒体：电磁波沿着固体媒体传播</p><ul><li>双绞线：无屏蔽、屏蔽双绞线</li><li>同轴电缆</li><li>光缆</li></ul></li><li><p>非导向传输媒体：自由空间 电磁波 无线电 短波通信（电离层反射） 微波（直线传播 接受塔）</p></li><li><p>集线器 目前被交换机替代 扩大网络传输范围 是一个大冲突域</p><h2 id="2-4信道复用技术"><a href="#2-4信道复用技术" class="headerlink" title="2.4信道复用技术"></a>2.4信道复用技术</h2></li><li><p>频分复用FDM：多个源信号经过调频变成不同频率的信号，然后一起运输</p></li><li><p>时分复用TDM：先放的数据先取出去；</p></li><li><p>统计时分复用STDM：数据帧里加标记</p></li><li><p>波分复用WDM</p></li><li><p>码分复用CDM：</p><ul><li>常用名词：码分多址CDMA</li><li>CDMA的工作原理：<ol><li>对于一个发送端信号，一个比特时间划分多个码片</li><li>多个信号复用运输</li><li>接收端通过格式化内积判断自己对应的码片信号(与自己格式化内积为1，与自己反码为-1，与其他码片为0)<h2 id="2-5数字传输系统"><a href="#2-5数字传输系统" class="headerlink" title="2.5数字传输系统"></a>2.5数字传输系统</h2></li></ol></li></ul></li><li><p>脉码调制——PCM体制</p></li><li><p>电话通讯局用到的，有两个标准</p></li><li><p>电话-PCM-TDM</p></li></ol><h2 id="2-6宽带接入技术"><a href="#2-6宽带接入技术" class="headerlink" title="2.6宽带接入技术"></a>2.6宽带接入技术</h2><ol><li>宽带接入技术指的是计算机如何接入Internet</li><li>xDSL：低端频谱留给传统电话，未利用的高端频谱留给用户上网；不用再铺线了</li><li>HFC 光纤同轴混合网：有线电视网基础上接入网；采用结点体系结构</li><li>FTTx 光纤到… ：</li></ol><h1 id="三、数据链路层"><a href="#三、数据链路层" class="headerlink" title="三、数据链路层"></a>三、数据链路层</h1><h2 id="3-1数据链路层基本概念及基本问题"><a href="#3-1数据链路层基本概念及基本问题" class="headerlink" title="3.1数据链路层基本概念及基本问题"></a>3.1数据链路层基本概念及基本问题</h2><ol><li><p>基本概念</p><ul><li>数据发送模型 仅从数据链路层观察帧的流动</li><li>数据链路层的信道类型：点对点信道（pc直接连接）、广播信道（通过集线器连接多个pc）</li><li>链路和数据链路</li><li>帧：数据链路层传送的是帧，有帧头帧尾，判断开始和结尾</li></ul></li><li><p>三个基本问题</p><ul><li>封装成帧：IP数据报加上帧头帧尾；半截子帧会被丢弃</li><li>透明运输：为了避免接收端错误地提前接收了帧，所以会字节填充，数据段中加上转义字符</li><li>差错控制：循环冗余检验；加一段帧校验序列；CRC差错检测技术得到FCS帧校验序列；接收端数据链路层接受的帧没有传输差错（有差错的帧被丢弃）；无差错接收</li></ul></li></ol><h2 id="3-2两种情况下的数据链路层"><a href="#3-2两种情况下的数据链路层" class="headerlink" title="3.2两种情况下的数据链路层"></a>3.2两种情况下的数据链路层</h2><h3 id="3-2-1-使用点对点的信道数据链路层"><a href="#3-2-1-使用点对点的信道数据链路层" class="headerlink" title="3.2.1.使用点对点的信道数据链路层"></a>3.2.1.使用点对点的信道数据链路层</h3><p>PPP协议使用最多</p><ol><li>PPP协议使用场合：用户接入网（PPP协议）到ISP（已向因特网管理机构申请到一批IP地址）至因特网</li><li>PPP协议应满足的要求：简单、封装成帧、透明性、多种网络层链路、差错检测、检测连接状态、最大传送单元、网络层地址协商、数据压缩协商</li><li>PPP协议的组成：从下向上分别为高级数据链路控制协议HDLC、链路控制协议LCP、网络控制协议NCP（针对每一个网络层协议）</li><li>PPP协议帧格式：一字节帧头+一字节FF+一字节03+两字节协议（标识信息部分是什么内容）+信息部分+两字节FCS+帧尾</li><li>PPP协议填充方式：<br>字节填充：传的是字节，将字节转义<br>零比特填充：传的是比特流</li><li>PPP协议的工作状态：链路静止——&gt;链路建立——&gt;鉴别——&gt;网络层协议——&gt;链路打开</li></ol><blockquote><p>PPP协议：错了就重新传，不纠错</p></blockquote><blockquote><p> 操作p31：配置路由器接口使用PPP协议封装</p></blockquote><h3 id="3-2-2使用广播信道数据链路层"><a href="#3-2-2使用广播信道数据链路层" class="headerlink" title="3.2.2使用广播信道数据链路层"></a>3.2.2使用广播信道数据链路层</h3><p>CSMA/CD协议</p><ol><li><p>局域网概述</p><ul><li>局域网拓扑：星型网、环线网、总线网（出现早，一根线）、树型网</li><li>局域网的特点与优点：有广播功能等</li><li>局域网共享通信媒体：PC共享链路<ol><li>静态划分信道：频分复用、时分复用、波分复用、码分复用；需要没两个电脑接通信道</li><li>动态媒体接入控制：随机接入（主要被以太网采用）、受控接入（用的少）</li></ol></li></ul></li><li><p>以太网</p><ol><li>认识以太网<ul><li>计算根据网卡MAC地址确认是否是自己的数据</li><li>不用划分信道</li><li>一个链路上只能有两个计算机发送接收、所有计算机都可以通过抓包、MAC欺骗等收到不属于自己的数据</li></ul></li><li>载波接听多点接入/碰撞检测  以太网使用CSMA/CD协议<ul><li>多点接入：计算机接入方式连接在一根总线上</li><li>载波接听：检测一下是否有计算机占用了线</li><li>碰撞检测：为了发现碰撞，因此不能太长，所以以太网不超过一百米。</li></ul></li><li>以太网重要特性<br>不能进行全双工通信，只能进行半双工通信</li><li>以太网冲突检测和避让机制<ol><li>争用期<ul><li>以太网的端到端往返时延成为争用期；</li><li>最短有效帧长：如果发生冲突就一定是在发送的前36字节之内；检测到了冲突就立即终止发送，成为由于冲突而异常中止的无效帧</li></ul></li><li>二进制指数类型退避算法<ul><li>碰撞中止后，要退避一个随机时间再发送数据</li><li>经过算法确定退避的时间，当重传达到16次仍不能成功则丢弃该帧，并向高层报告</li></ul></li></ol></li></ol></li></ol><h2 id="3-3-以太局域网（以太网）"><a href="#3-3-以太局域网（以太网）" class="headerlink" title="3.3 以太局域网（以太网）"></a>3.3 以太局域网（以太网）</h2><ol><li><p>概述</p><ul><li>以太网的两个标准：Ethernet V2标准、802.3标准</li><li>以太网与数据链路层的两个子层：起初为了数据链路层能更好适应多种局域网标准而定；现在TCP/IP体系经常使用的局域网是Ethernet V2，所以现在单说媒体接入控制MAC层；有的适配器仅装有MAC协议</li><li>以太网提供的服务：不可靠交付、尽最大努力交付</li></ul></li><li><p>星型拓扑：中心是集线器</p><ul><li>集线器特点：使用的CSMA/CD协议、工作在物理层、整个系统任然像一个传统的以太网那样运行</li><li>以太网10Base-T：每个站到集线器距离不超过100m</li></ul></li><li><p>信道利用率</p><ul><li>与碰撞事件（n个争用期）和占用期（发送时间）有关</li><li>以太网参数的要求：数据率一定时，以太网线长度受到限制；帧长不能太短</li><li>最大信道利用率</li></ul></li></ol><h4 id="4-MAC层"><a href="#4-MAC层" class="headerlink" title="4.MAC层"></a>4.MAC层</h4><ol><li>MAC层的硬件地址（MAC地址）<ul><li>MAC地址是48位二进制组成，前三个字节（高位24位）由组测管理机构分配给厂家，代表不同的厂，后三个字节由厂家自行指派</li><li>同一个网段的MAC地址相同会发生冲突</li><li>命令行<code>ipconfig /all</code>可查MAC地址，显示的是十六进制</li></ul></li><li>适配器检查MAC地址：网卡每收到MAC帧就先用硬件检查帧中的MAC地址决定手下还是丢弃；发往计算机的帧有单播帧、广播帧、多播帧</li><li>MAC帧格式（最常见的Ethernet V2标准）：六个字节目的地址+六个字节源地址+两个字节类型+数据+四个字节FCS<blockquote><p>以太网使用曼彻斯特编码，所以最后发现没有信号了就代表帧结束了</p></blockquote></li></ol><blockquote><p>操作抓包：抓取其他计算机数据、可用于排除电脑故障</p></blockquote><h2 id="3-4扩展以太网（优化以太网）"><a href="#3-4扩展以太网（优化以太网）" class="headerlink" title="3.4扩展以太网（优化以太网）"></a>3.4扩展以太网（优化以太网）</h2><ol><li><p>在物理层考虑扩展：</p><ul><li>光纤、光纤解调器</li><li>各自用集线器连成局域网 大冲突域 效率低</li></ul></li><li><p>在数据链路层考虑扩展：</p><ul><li>网桥<ol><li>站表记录MAC地址</li><li>目前使用最多的网桥是透明网桥（计算机不知道有没有经过网桥）</li><li>自学习算法：记下发送的站，若不知道转发路线就先转发到各个路线上</li></ol></li><li>交换机：交换机就是多端口网桥  生成树算法</li></ul></li><li><p>虚拟局域网VLAN  局域网LAN</p><ul><li>VLAN：交换机上的接口分为两个区域，两个区域互不相通，而且也ping不通，除非中间接了路由器</li><li>VLAN可跨交换机传送数据</li><li>VLAN干道链路和访问链路：干道链路连接两个交换机；访问链路是计算机和交换机相连</li><li>VLAN网帧格式：在以太网帧格式中插入VLAN标记，用来指明发送该帧的工作站属于哪一个虚拟局域网</li></ul></li></ol><blockquote><p>操作 更改交换机生成树的根（优先级）</p></blockquote><h2 id="3-5高速以太网"><a href="#3-5高速以太网" class="headerlink" title="3.5高速以太网"></a>3.5高速以太网</h2><ol><li>100BASE-T 以太网 快速以太网<ul><li>100BASE-T特点：双工方式下工作而无冲突发生，因此不使用CSMA/CD协议。MAC帧格式仍然是802.3标准规定的</li></ul></li><li>吉比特以太网</li><li>组建局域网3层模型：接入层、汇聚层、核心层<blockquote><p>案例： 交换机上实现的接入安全</p><ul><li>设置交换机可以接的MAC地址唯一来保证不接其他计算机</li><li>设置交换机口只可以接一台计算机</li></ul></blockquote></li></ol><h1 id="四、网络层"><a href="#四、网络层" class="headerlink" title="四、网络层"></a>四、网络层</h1><h2 id="4-1网络层提供的两种服务"><a href="#4-1网络层提供的两种服务" class="headerlink" title="4.1网络层提供的两种服务"></a>4.1网络层提供的两种服务</h2><blockquote><p>端系统来负责可靠性交付，而不是网络层</p></blockquote><ol><li>虚电路服务：逻辑上的连接。分组都沿着这条逻辑连接传送，而不是真正建立了物理连接</li></ol><p><strong>注意</strong>：电路交换的电话通信不同<br>2. 数据报服务（现在都是该服务）：分组有重点地址。不需要先建立连接，不事先确定传送路径，分组可能沿着不同路径传送</p><h2 id="4-2网际协议-IP"><a href="#4-2网际协议-IP" class="headerlink" title="4.2网际协议 IP"></a>4.2网际协议 IP</h2><h3 id="4-2-1虚拟互联网"><a href="#4-2-1虚拟互联网" class="headerlink" title="4.2.1虚拟互联网"></a>4.2.1虚拟互联网</h3><ol><li><p>中间设备/中继系统</p><ul><li>物理层：转发器（集线器）</li><li>数据链路层：交换机或网桥</li><li>网络层：路由器<blockquote><p>网关：</p><ul><li>现在：网络层使用的路由器</li><li>原始：网络层以上</li></ul></blockquote></li></ul></li><li><p>互联网、</p><ul><li>前两层经过中继系统连接往往不称为网络互连，仍是网络</li><li>用路由器进行互联的网络才称为互联网</li></ul></li><li><p>虚拟互联网络：通过逻辑互联，让IP协议使使用者看起来像统一的网络</p></li><li><p>网络层协议 四个：IP、ARP、ICMP、IGMP </p><h3 id="4-2-2-IP地址"><a href="#4-2-2-IP地址" class="headerlink" title="4.2.2 IP地址"></a>4.2.2 IP地址</h3></li><li><p>IP地址就是给接在因特网上的主机（或路由器）的每个接口分配一个唯一的32位标识符</p></li><li><p>IP层次结构：32位IP分为网络IP和主机IP</p></li><li><p>网络IP：指定每个网络；同一个网络的计算机网络地址相同，是IP地址的一部分</p></li><li><p>IP地址的类别：ABCDE类</p></li><li><p>常用的三类地址</p><ul><li>越往后网络地址位数越来越长</li><li>A类地址：1-126</li><li>B类地址：128-191</li><li>C类地址：192-224<blockquote><p>IP地址在计算机网卡上，路由器每个接口上也有。路由器上还有MAC地址</p></blockquote></li></ul></li></ol><blockquote><p>—-二进制——-十进制<br>———1———-1<br>——–10———-2<br>——-100———-4<br>——1000———-8<br>—–10000———16<br>—-100000———32<br>—1000000———64<br>–10000000——–128</p><p>–10000000——–128<br>–11000000——–192<br>–11100000——–224<br>–11110000——–240<br>–11111000——–248<br>–11111100——–252<br>–11111110——–254<br>–11111111——–255</p></blockquote><blockquote><ul><li>127.0.0.1本地环回地址</li><li>169.254.0.0 特殊情况暂用的地址</li><li>保留的私网地址</li></ul><p>10.0.0.0<br>172.16.0.0 — 172.31.0.0<br>192.168.0.0 — 192.168.255.0<br>6. 子网掩码的作用</p></blockquote><ul><li><p>用来将IP地址分为网络地址和主机地址两个部分</p></li><li><p>A类一个255，B类两个255，C类三个255</p></li><li><p>子网掩码与自身IP地址写成二进制，做与运算，主机位归零</p><ol start="7"><li><p>子网划分</p></li><li><p>C类网络子网划分</p></li></ol><ul><li>划分方法：IP地址变为二进制，若划分2个子网，主机IP地址多1位进行与运算，若划分4个子网主机IP地址多2位进行与运算，若划分8个子网主机IP地址多3位进行与运算。这里韩老师直接用横轴将0-255进行分割，每多一位相当于分割一次</li><li>子网IP地址范围：如果经过划分是0-32，则可用的地址位1-30（31为广播地址）</li></ul><ol start="2"><li><p>变长子网划分</p></li><li><p>B类网络子网划分</p><blockquote><ul><li>主机位不能全为0或全为1</li><li>点到点网络的子网掩码最好为252</li></ul></blockquote></li><li><p>超网<br>将不同的网段进行合并。小的是偶数可以合并</p></li><li><p>IP地址与MAC地址</p></li></ol></li><li><p>数据帧=数据包（数据段+IP地址）+MAC地址</p></li><li><p>IP地址决定了数据最后要去的位置，MAC地址决定了下一站要去的位置</p><h3 id="4-2-3ARP-amp-RARP"><a href="#4-2-3ARP-amp-RARP" class="headerlink" title="4.2.3ARP&amp;RARP"></a>4.2.3ARP&amp;RARP</h3></li></ul><ol><li><p>概念</p><ul><li>ARP：广播，通过IP地址获得MAC地址</li><li>RARP：通过MAC地址获得IP地址（逆向ARP）</li></ul></li><li><p>ARP欺骗的应用</p><ul><li>截取信息：流氓计算机给其他计算机发的是自己的MAC地址，然后流氓计算机再去转发到正确的网关</li><li>断网：流氓计算机给其他计算机发的是随意的MAC地址</li></ul></li><li><p>ARP欺骗的断定<br>cmd查看自己和其他计算机得到的网关MAC地址是否一致</p><h3 id="4-2-4-IP数据报格式"><a href="#4-2-4-IP数据报格式" class="headerlink" title="4.2.4 IP数据报格式"></a>4.2.4 IP数据报格式</h3></li><li><p>IP数据报=首部+数据部分<br>首部=可变部分+固定部分</p></li><li><p>首部</p><ul><li>标志-片偏移：数据太大拆分成IP数据报分片，然后根据字节位数可以得到片偏移<blockquote><p>一个字节八位八比特</p></blockquote></li></ul></li></ol><h3 id="4-2-5-IP转发分组的流程"><a href="#4-2-5-IP转发分组的流程" class="headerlink" title="4.2.5 IP转发分组的流程"></a>4.2.5 IP转发分组的流程</h3><ol><li><p>数据路由：路由器在不同网段转发数据包</p></li><li><p>网络畅通的条件：数据包能去能回。沿途路由器必须有一个网段到另一个网段的路由</p></li><li><p>静态路由：管理员给路由器加路由表——所有没有直连的网络该怎么走</p></li><li><p>添加静态路由：</p><ul><li><code>config t</code></li><li><code>show ip route</code></li><li><code>ip route 192.168.0.0 255.255.255.0 IP地址</code></li><li><code>show ip route</code></li></ul><ol start="5"><li>windows网关就是默认路由</li><li>网络负载均衡：给网络中的路由器添加路由使得两个网段可以不用路径去和回，从而实现负载均衡<h2 id="4-3-网际控制报文协议-ICMP"><a href="#4-3-网际控制报文协议-ICMP" class="headerlink" title="4.3.网际控制报文协议 ICMP"></a>4.3.网际控制报文协议 ICMP</h2></li></ol></li><li><p>ICMP简介：主机或路由器报告差错情况</p></li><li><p>ICMP不是高层协议，而是IP层协议</p></li><li><p>ICMP报文类型：</p><ul><li>ICMP差错报告报文<ol><li>种类：重点不可达、源点抑制、时间超过、参数问题、改变路由（重定向）</li><li>差错报告报文的数据字段的内容<br><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_06/ICMP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F%E5%9B%BE.png" srcset="/img/loading.gif" alt="ICMP"></li></ol></li><li>ICMP询问报文<br>种类：回送请求和回答报文、时间戳请求和回答报文</li></ul><ol start="4"><li><p>ping和pathping</p><ul><li>ping：检测从哪通，从哪不通</li><li>pathping：跟踪数据包的路径，能检测到哪里不通<h2 id="4-4因特网的路由选择协议"><a href="#4-4因特网的路由选择协议" class="headerlink" title="4.4因特网的路由选择协议"></a>4.4因特网的路由选择协议</h2></li></ul></li><li><p>动态路由协议RIP</p><ul><li>特点：最早 周期性广播 30秒 度量值是跳数（不是看带宽） 16跳</li><li>配置RIP协议<br><code>router rip</code><br><code>network</code>  （写几个network取决于是否是同一类地址）</li></ul></li></ol></li><li><p>动态路由协议OSPF（内部网关协议）</p><ul><li>特点：触发式更新 度量值是带宽 支持多区域 三个表（a.邻居表-hello包；b.链路状态表-最佳路径；c.计算路由表）OSPF分为两种不同的区域</li><li>配置OSTF协议</li></ul></li><li><p>动态路由协议BGP（外部网关协议）</p><ul><li>特点： 连接自治系统  BGP发言人交换路径向量 <h2 id="4-5-IP多播"><a href="#4-5-IP多播" class="headerlink" title="4.5 IP多播"></a>4.5 IP多播</h2></li></ul></li></ol><h2 id="4-6-虚拟专用网VPN和网络地址转换NAT"><a href="#4-6-虚拟专用网VPN和网络地址转换NAT" class="headerlink" title="4.6 虚拟专用网VPN和网络地址转换NAT"></a>4.6 虚拟专用网VPN和网络地址转换NAT</h2><ol><li>虚拟专用网VPN<ul><li>VPN的功能：远程访问私网</li><li>创建VPN拨号连接</li><li>用隧道技术实现VPN</li></ul></li></ol><blockquote><ul><li>本地地址：近代机构内部使用的IP地址</li><li>全球地址：全球唯一的IP地址</li><li>RFC知名的专用地址（私网）：</li></ul><p>10.0.0.0-10.255.255.255<br>172.16.0.0-172.31.255.255<br>192.168.1.1-192.168.255.255</p></blockquote><ol start="2"><li>网络地址转换NAT4<ul><li>NAT和PAT</li><li>NAT的端口映射</li></ul></li></ol><h1 id="五、传输层"><a href="#五、传输层" class="headerlink" title="五、传输层"></a>五、传输层</h1><blockquote><p>应用层 http https ftp DNS SMTP PoP3 RDP<br>传输层 TCP UDP<br>网络层 IP（RIP OSPF BGP）ICMP IGMP ARP</p></blockquote><ol><li><p>传输层两个协议应用场景</p><ul><li>TCP 分段 编号 流量控制 建立会话 netstat -n</li><li>UDP 一个数据包就可以完成通信 不建立绘画 多播</li></ul></li><li><p>传输层和应用层之间的关系</p><div class="hljs"><pre><code class="hljs routeros"><span class="hljs-attribute">http</span>=TCP+80端口<span class="hljs-attribute">https</span>=TCP+443端口<span class="hljs-attribute">ftp</span>=TCP+21端口<span class="hljs-attribute">SMTP</span>=TCP+25端口<span class="hljs-attribute">POP3</span>=TCP+110端口<span class="hljs-attribute">RDP</span>=TCP+3389端口共享文件夹=TCP+445端口<span class="hljs-attribute">SQL</span>=TCP+1433端口<span class="hljs-attribute">DNS</span>=TCP+1433端口 <span class="hljs-keyword">or</span>  TCP+53端口</code></pre></div></li><li><p>应用层协议和服务之间的关系</p><ul><li>服务运行后在TCP或UDP的某个端口侦听客户端请求</li><li>查看自己计算机侦听的端口：<br><code>netstat -an</code><br><code>telnet 10.7.1.53.21</code></li><li>端口代表服务</li><li>更改端口增加服务器安全</li><li>mstsc</li></ul></li><li><p>Windows防火墙</p><ul><li>外面的不能进来、里面的可以出去</li><li>windows防火墙不能防空灰鸽子木马程序</li><li>木马可以通过查会话和查看系统配置中的服务查看有没有木马服务</li></ul></li><li><p>TCPIP筛选实现服务器安全</p><ul><li>每增加服务就更新端口</li><li>用端口区分服务</li><li>计算机通过开启端口筛选来决定是否开TCPIP的服务来保证安全<blockquote><p>IPSec严格控制网络流量</p></blockquote></li></ul></li><li><p>TCP传送的协议数据单元是TCP报文段<br> UDP传送的协议数据单元是UDP报文</p></li><li><p>UDP数据报：<br><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_06/UDP%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.png" srcset="/img/loading.gif" alt="UDP"></p></li><li><p>传输控制协议TCP</p><ul><li>可靠传输 流量控制 避免网络拥塞</li><li>面向连接：三次握手</li><li>只能有两个端点 点对点</li><li>提供全双工通信</li><li>面向字节流：传送端文件里的字节无数量规律规律地加到TCP缓存里，然后缓存里的字节加头部再无数量规律地合成数据报传送到接收端，接收端去掉头部将数据组合起来，然后读到空文件里</li><li>TCP如何实现可靠传输：（网络层不可靠，可靠性传输由传输层实现）<ol><li>停止等待协议<ul><li>无差错情况：发送M1确认M1发送M2确认M2…</li><li>超时重传：丢弃有差错的报文M1超时重传M1确认M1…</li></ul></li><li>确认丢失和确认迟到（ARQ）<ul><li>确认丢失</li><li>确认迟到</li></ul></li><li>补充：<ul><li>停止等待协议信道利用率低，发送方可以连续发送多个分组，不必发完一个分组就停顿下来等待对方的确认，成为流水线传输</li><li>流水线传输——连续ARQ协议：发送方维持发送窗口；发送窗口里的数据不能删除要等着确认</li></ul></li></ol></li></ul></li><li><p>TCP报文<br>TCP报文=TCP首部（固定+可变）+TCP数据部分<br><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_06/%E4%BC%A0%E8%BE%93%E5%B1%82%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93.png" srcset="/img/loading.gif" alt=""><br><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_06/TCP%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.png" srcset="/img/loading.gif" alt="TCP报文格式"></p></li><li><p>TCP攻击</p></li><li><p>TCP如何实现可靠传输</p><ul><li>以字节为单位的滑动窗口技术：发送窗口  发送缓存 A将窗口里的数据拆成数据包然后发送  B向A发送确认数据包 AB窗口后移 A删除部分数据 A继续传送下一个窗口数据 </li><li>数据包丢失：确认数据包返回数据有丢失  SAK选择确认 丢包窗口依旧后移</li><li>超时重传时间的选择：设置计时器 重传时间到但是没有收到确认 就会重传这个数据包<br>12.TCP的流量控制</li></ul></li><li><p>TCP避免拥塞</p><ul><li>拥塞条件：资源需求&gt;资源总和</li><li>实际的拥塞控制：拥塞窗口cwnd 慢开始 慢开始门限 </li><li>快重传快恢复：丢包以后直接要求重发而不是等到去人返回的时候才要求重传</li><li>发送窗口的实际上限值：取接收方窗口和拥塞窗口两个变量最小值</li></ul></li><li><p>TCP的传输连接管理</p><ul><li>三阶段：连接建立、数据传送、连接释放</li><li>采用客户端服务器方式</li><li>三次握手建立TCP连接：ACK确认号；seq序号；建立连接时的各状态closed、synrcvd、established</li><li>TCP的连接释放：finwait-1、closewait、timewait、lastack<h1 id="六、应用层"><a href="#六、应用层" class="headerlink" title="六、应用层"></a>六、应用层</h1></li></ul></li></ol><h2 id="6-1网络应用概述"><a href="#6-1网络应用概述" class="headerlink" title="6.1网络应用概述"></a>6.1网络应用概述</h2><ol><li>网络应用体系结构<br>① 客户机/服务器 ② P2P ③ 混合结构</li><li>网络应用的服务需求<br>① 可靠性 ② 带宽 ③ 时延</li><li>Internet传输层服务模型<br>① TCP ② UDP</li><li>特定网络应用及协议<br>①  HTTP ② SMTP POP IMAP ③ DNS ④ P2P应用</li><li>Socket编程<br>① TCP ② UDP<h2 id="6-2网络应用基本原理"><a href="#6-2网络应用基本原理" class="headerlink" title="6.2网络应用基本原理"></a>6.2网络应用基本原理</h2></li></ol><h3 id="6-2-1网络应用的体系结构"><a href="#6-2-1网络应用的体系结构" class="headerlink" title="6.2.1网络应用的体系结构"></a>6.2.1网络应用的体系结构</h3><ol><li><p>网络应用：百度、QQ、Email、迅雷、支付宝、微信、百度云、淘宝网、网易</p></li><li><p>网络应用的体系结构：客户机/服务器结构（Client/Sever）、点对点结构（PeerToPeer）、混合结构</p><ul><li>服务器：持续提供服务、永久性访问地址/域名、利用大量服务器实现可扩展性</li><li>客户机：使用服务器的服务、可能使用动态IP地址、不会与其他客户机直接通信</li><li>C/S举例——Web<br>计算机客户端运行IE或者Sarari等浏览器，服务器运行Web服务器软件</li><li>P2P举例——BT文件共享<br>没有永远在线的服务器，任意端系统/节点直接可以直接通讯，节点可能改变IP地址</li><li>混合结构举例——Napster<br>文件传输使用P2P结构，文件的搜索采用C/S结构（集中式）<h3 id="6-2-2-网络应用进程通信（网络应用的基础）"><a href="#6-2-2-网络应用进程通信（网络应用的基础）" class="headerlink" title="6.2.2 网络应用进程通信（网络应用的基础）"></a>6.2.2 网络应用进程通信（网络应用的基础）</h3></li></ul></li><li><p>进程：主机上运行的程序</p></li><li><p>同一主机上运行的进程之间通信：进程间通信机制、操作系统提供</p></li><li><p>不同主机上运行的进程之间通信：消息交换/报文交换</p><ul><li>客户机进程：发起通信的进程</li><li>服务器进程：等待通信请求的进程</li></ul></li><li><p>套接字：Socket</p><ul><li>进程间通信利用socket发送/接收消息实现， 类似于寄信</li><li>传输基础设施向进程提供API（传输协议的选择、参数的设置）</li></ul></li><li><p>如何寻址进程</p><ul><li>进程有标识符：IP地址+端口号</li><li>寻址主机——IP地</li><li>某一主机具体进程——端口号：每个需要通信的进程分配一个端口号</li></ul></li><li><p>应用层协议</p><ul><li>公开协议：由RFC定义、允许互操作、HTTP、SMTP、..</li><li>私有协议：多数P2P文件共享应用</li></ul></li><li><p>应用层协议的内容</p><ul><li>消息类型：请求消息、响应消息</li><li>消息的语法格式：字段、字段如何描</li><li>字段的语义：字段中信息的含义</li><li>规则</li></ul></li></ol><h3 id="6-2-3-网络应用的需求与传输层服务"><a href="#6-2-3-网络应用的需求与传输层服务" class="headerlink" title="6.2.3 网络应用的需求与传输层服务"></a>6.2.3 网络应用的需求与传输层服务</h3><ol><li>网络应用的需求<ul><li>数据丢失/可靠性（网络电话容忍一定的数据丢失，文件传输要求100%可靠）</li><li>时间延迟</li><li>带宽</li></ul></li><li>Internet提供的传输服务<ul><li>TCP服务（面向连接、可靠传输、流量控制、拥塞控制、不提供时间/延迟保障、不提供最小带宽保障）</li><li>UCP服务（无连接、不可靠数据传输、不提供可靠性保障+流量控制+拥塞控制+延迟保障+带宽保障）<h2 id="6-3Web应用"><a href="#6-3Web应用" class="headerlink" title="6.3Web应用"></a>6.3Web应用</h2></li></ul></li></ol><h3 id="6-3-1Web应用概述"><a href="#6-3-1Web应用概述" class="headerlink" title="6.3.1Web应用概述"></a>6.3.1Web应用概述</h3><ol><li><p>WorldWideWeb：网页、网页互相链接</p></li><li><p>网页包含多个对象：</p><ul><li>对象：HTML文件、JEPG图片、视频文件、动态脚本等</li><li>基本HTML文件：包含对其他对象引用的链接</li><li>对象的寻址：URL（协议 :// 主机 : 端口号 / 路径）</li></ul></li><li><p>HTTP协议概述</p><ul><li>万维网应用遵循HTTP协议</li><li>C/S结构</li><li>使用TCP传输服务（80端口）</li><li>是无状态协议（服务器不维护过去所发请求的信息）<h3 id="6-3-2-HTTP连接类型"><a href="#6-3-2-HTTP连接类型" class="headerlink" title="6.3.2 HTTP连接类型"></a>6.3.2 HTTP连接类型</h3></li></ul></li><li><p>HTTP连接的两种类型</p><ul><li>非持久性连接：每个TCP连接最多传输一个对象</li><li>持久性连接：每个TCP连接允许传输多个对象</li></ul></li><li><p>响应事件分析与建模 </p><ul><li>非持久性连接：2RTT+文件发送时间（一个对象）</li><li>持久性连接：无流水的持久性连接（一个对象1RTT）、带有流水机制的持久性连接（所有引用对象1RTT）<h3 id="6-3-3-HTTP消息格式"><a href="#6-3-3-HTTP消息格式" class="headerlink" title="6.3.3 HTTP消息格式"></a>6.3.3 HTTP消息格式</h3></li></ul></li><li><p>两类消息：请求消息、响应消息</p></li><li><p>请求消息消息格式：</p><ul><li>请求行+头部行（可扩展）+换行+entity body</li><li>请求消息通用格式：method、url、version、header field name、value、entity body..</li><li>上传输入的方法：<ol><li>POST方法：网页填写表格（在请求消息的消息体entity body中上传客户端的输入）</li><li>URL方法：使用GET方法（输入信息通过request行的URL字段上传）</li></ol></li><li>方法的类型：<ol><li>HTTP/1.0：GET、POST、HEAD</li><li>HTTP/1.1：GET、POST、HEAD、GET、DELETE</li></ol></li></ul></li><li><p>响应消息消息格式：状态行+头部行+空行+data</p><h3 id="6-3-4-Cookie技术"><a href="#6-3-4-Cookie技术" class="headerlink" title="6.3.4 Cookie技术"></a>6.3.4 Cookie技术</h3></li><li><p>Cookie技术：为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据（RFC6265）</p></li><li><p>Cookie的组件：</p><ul><li>HTTP响应消息的cookie头部行</li><li>HTTP请求消息的cookie头部行</li><li>保存在客户端主机上的cookie文件，有浏览器管理</li><li>Web服务器端的后台数据库</li></ul></li><li><p>Cookie的原理：客户端第一次访问服务器，服务器会为其创建ID，以后客户端请求消息里会有cookie id</p></li><li><p>Cookie的作用：能用于身份认证,购物车,推荐,Web e-mail</p></li><li><p>隐私问题</p><h3 id="6-3-5-Web缓存-代理服务器技术"><a href="#6-3-5-Web缓存-代理服务器技术" class="headerlink" title="6.3.5 Web缓存/代理服务器技术"></a>6.3.5 Web缓存/代理服务器技术</h3></li><li><p>功能：不访问服务器的前提下满足客户端HTTP请求。可以缩短客户请求的响应时间；减少机构/组织的流量；在大范围内实现有效的内容分发</p></li><li><p>Web缓存/代理服务器技术：</p><ul><li>浏览器通过缓存进行Web访问。如果请求对象在缓存中，缓存返回对象；否则向原始服务器发送HTTP请求，获取对象，返回给客户端并保存该对象</li><li>缓存即充当客户端也充当服务器</li><li>一般由ISP（Internet服务提供商）架设</li></ul></li><li><p>Web缓存实例</p><ul><li>性能对比：原始服务器、提升互联网接入带宽、安装Web缓存</li></ul></li><li><p>条件性GET方法</p><ul><li>目标：缓存有最新版本，则不需要发送请求对象</li><li>缓存：在HTTP请求消息中声明所持有版本的日期</li><li>服务器：如果版本是最新的，则响应消息中不包含对象<h2 id="6-4Email应用"><a href="#6-4Email应用" class="headerlink" title="6.4Email应用"></a>6.4Email应用</h2></li></ul></li></ol><h3 id="6-4-1Email应用概述"><a href="#6-4-1Email应用概述" class="headerlink" title="6.4.1Email应用概述"></a>6.4.1Email应用概述</h3><ol><li><p>Email应用的构成：邮件客户端、邮件服务器、SMTP协议</p><ul><li>邮件客户端：如Foxmail、Web客户端</li><li>邮件服务器：<ol><li>邮箱：存储发给该用户的Email</li><li>消息队列：存储等待发送的Email</li></ol></li><li>SMTP协议：邮件服务器之间传递消息使用的协议（邮件服务器既充当客户端又充当服务器)</li></ul></li><li><p>SMTP协议：RFC 2821</p><ul><li>使用TCP进行email消息的可靠传输</li><li>端口25</li><li>传输过程的三个阶段：握手、消息的传输、关闭</li><li>命令/响应交互模式</li></ul></li><li><p>Email应用实例</p></li><li><p>SMTP协议特点：</p><ul><li>使用持久性连接</li><li>利用CRLF.CRLF确定消息的结束</li></ul></li><li><p>与HTTP对比</p><ul><li>HTT是拉式；SMTP是退式</li><li>都使用命令/响应交互模式</li><li>命令和状态码都是ASCII码</li><li>HTTP：每个对象封装在独立的响应消息中</li><li>SMTP：多个对象在由多个部分构成的消息中发送<h3 id="6-4-2-Email消息格式与POP协议"><a href="#6-4-2-Email消息格式与POP协议" class="headerlink" title="6.4.2 Email消息格式与POP协议"></a>6.4.2 Email消息格式与POP协议</h3></li></ul></li><li><p>Email消息格式</p><ul><li><p>SMTP协议：头部行header（To、From、Subject）+消息体body</p><blockquote><p>这里的头部行与SMTP命令不同</p></blockquote></li><li><p>多媒体邮件扩展： MIME<br>邮件头部增加额外的行声明MIME的内容类型</p></li></ul></li><li><p>邮件访问协议：从服务器获取邮件</p><ul><li>POP协议</li><li>IMAP协议</li><li>HTTP协议（Web浏览器收发邮件）</li></ul></li><li><p>POP协议</p><ul><li>认证过程：客户端命令（User声明用户名、Pass声明密码）、服务器响应（+OK、-ERR）</li><li>事务阶段：List、Retr、Dele、Quit</li><li>“下载并删除”模式：换了客户端软件无法重读邮件</li><li>“下载并保持”模式：不同客户端都可以保留消息的拷贝</li><li>POP3是无状态的</li></ul></li><li><p>IMAP协议</p><ul><li>所有消息统一保存在一个地方：服务器</li><li>允许用户利用文件夹组织消息</li><li>IMAP支持跨会话（session）的用户状态：文件夹名字、文件夹与消息ID之间的映射等<h2 id="6-5DNS应用"><a href="#6-5DNS应用" class="headerlink" title="6.5DNS应用"></a>6.5DNS应用</h2></li></ul></li></ol><h3 id="6-5-1DNS概述"><a href="#6-5-1DNS概述" class="headerlink" title="6.5.1DNS概述"></a>6.5.1DNS概述</h3><ol><li><p>Internet上主机/路由器的识别问题：IP地址、域名</p></li><li><p>域名解析系统DNS</p><ul><li>多层命名服务器构成的分布式数据库</li><li>应用层协议：完成名字的解析</li><li>Internet核心功能，用应用层协议实现</li><li>网络边界复杂<blockquote><p>不适用集中式的DNS原因：单点失败问题、流量问题、距离问题、维护性问题</p></blockquote></li></ul></li><li><p>DNS服务：域名向IP地址的翻译、主机别名、邮件服务器别名、负载均衡（web服务器）</p></li><li><p>分布式层式数据库：Root DNS servers—com DNS serves—Amazon.com DNS servers</p><ul><li>根域名服务器</li><li>顶级域名服务器TLD：负责顶级域名com、org、net、edu等和国家顶级域名cn、uk、fr等</li><li>权威域名解析服务器：提供组织内部服务器的解析服务（组织负责维护或者服务提供商负责维护）</li><li>本地域名解析服务器：不属于层级体系；每个ISP有一个本地域名服务器；当主机进行DNS查询时，查询被发送到本地域名服务器（作为代理将查询转发给层级式）</li></ul></li><li><p>DNS查询示例</p><ul><li>迭代查询（平等询问）：主机先访问本地域名服务器——&gt;本地域名服务器访问根域名服务器——&gt;<u>我不认识这个域名，但是你可以问这个服务器</u>——&gt;根域名服务器继续访问com域名服务器——&gt;…</li><li>递归查询（被指示）：主机先访问本地域名服务器——&gt;本地域名服务器访问根域名服务器——&gt;<u>我帮你去问这个服务器</u>——&gt;根域名服务器访问com域名服务器——&gt;…</li></ul></li><li><p>DNS记录缓存和更新</p><ul><li>只要域名解析服务器获得域名IP映射，即缓存这一映射（一段时间后缓存条目删除</li><li>本地域名服务器一般会缓存顶级域名服务器的映射）<h3 id="6-5-2-DNS记录和消息"><a href="#6-5-2-DNS记录和消息" class="headerlink" title="6.5.2 DNS记录和消息"></a>6.5.2 DNS记录和消息</h3></li></ul></li><li><p>DNS记录： 资源记录RR</p><div class="hljs"><pre><code class="hljs ini"><span class="hljs-attr">Type</span>=A<span class="hljs-attr">Type</span>=NS<span class="hljs-attr">Type</span>=CNAME<span class="hljs-attr">Type</span>=MS</code></pre></div></li><li><p>DNS协议与消息</p><ul><li>查询和回复（消息格式相同）</li><li>消息头部：Identification、flag</li></ul></li><li><p>如何注册域名</p></li><li><p>找出那些在应用层实现的Internet核心服务，调研他们的协议、消息格式</p><h2 id="6-6-P2P应用"><a href="#6-6-P2P应用" class="headerlink" title="6.6 P2P应用"></a>6.6 P2P应用</h2></li></ol><h3 id="6-6-1-原理与文件分发"><a href="#6-6-1-原理与文件分发" class="headerlink" title="6.6.1 原理与文件分发"></a>6.6.1 原理与文件分发</h3><ol><li><p>纯P2P架构</p><ul><li>Peer-To-Peer</li><li>特点：没有服务器；任意端系统之间直接通信；节点阶段性接入Internet、节点可能更换IP地址</li></ul></li><li><p>文件分发（客户机/服务器 VS P2P）：随着节点数目增加CS架构文件分发所需时间呈线性增长，P2P逐渐趋于水平</p></li><li><p>应用：BitTorrent（比特流）协议</p><h3 id="6-6-2-索引技术"><a href="#6-6-2-索引技术" class="headerlink" title="6.6.2 索引技术"></a>6.6.2 索引技术</h3></li><li><p>搜索信息</p><ul><li>P2P系统的索引：信息到节点位置（IP地址+端口号）的映射</li><li>文件共享（电驴）：利用索引动态跟踪节点所共享的文件的位置；节点告诉索引它拥有哪些文件；节点搜索索引，从而获知能够得到哪些文件</li><li>即时消息（QQ）：索引负责将用户名映射到位置；当用户开启IM应用时，需要通知索引它的位置；节点检索索引，确定用户的IP地址</li></ul></li><li><p>集中式索引</p><ul><li>Napster最早采用这种设计：节点加入时，通知中央服务器IP地址和内容；其他节点查找时，从其他主机处获取文件</li><li>问题：单点时效问题、性能瓶颈、版权问题</li></ul></li><li><p>洪泛式查询：Query flooding</p><ul><li>完全分布式架构</li><li>Gnutella采用这种架构：查询消息通过已有的TCP连接发送；节点转发查询消息；如果查询命中，则利用反向路径发回查询节点</li></ul></li><li><p>层次式覆盖网络</p><ul><li>介于集中式索引和洪泛查询之间的方法：节点和超级节点间维持TCP连接；某些超级节点间维持TCP连接</li><li>Skype采用这种架构：本质上是P2P的（用户/节点对之间直接通信）；私有应用层协议；索引负责维护用户名和IP地址之间的映射（类似QQ）；索引分布在超级节点上<blockquote><p>还涉及到了Socket编程部分，作相关了解请查阅资料</p></blockquote></li></ul></li></ol><blockquote><p>附：本文内容最后一章出于哈尔滨工业大学聂兰顺老师的计算机网络课程，其他部分均参考韩老师</p></blockquote><blockquote><p><code>2020/06/20</code>——<code>2020/06/25</code></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>生活/语句</title>
    <link href="/2020/06/17/%E7%94%9F%E6%B4%BB/%E8%AF%AD%E5%8F%A5/"/>
    <url>/2020/06/17/%E7%94%9F%E6%B4%BB/%E8%AF%AD%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<p>Σ&gt;―(〃°ω°〃)→每次溜达去帅地的公众号都会让我膜拜一波</p><p>♡“要嘛不做，要嘛就以认真的态度去完成它。”<br>♡“如果感兴趣，就马上去做，千万不要等自己准备好了再去做，因为那时你可能没兴趣了。”<br>♡“先完成，再一步步着去完善。千万不要想到万全之策再去做。”</p><p>1.“先不管有钱没钱，一个人想内心安定祥和，平静幸福，这就需要幸福的能力。”</p><p>2.“生命在于运动，或者在于折腾”</p><p>3.“这个时代，社会变化的速度远超过大家的想象，大学四年必须密集接触各种社会尖端行业的信息，密切关注国家发布各类数据信息，一定要自己思考，自己手机数据，自己分析，然后去做正确的选择，现在早已不是360行，行行出状元，而是其他行业的状元收益还不如某些核心行业的童生。选择的重要性已经远远大过你努力的重要性了”</p><p>4.“我们也应该有健康的身体，不多但也还够的存款，最重要的是有一个不俗的认知。这个不俗不用太高，比我们现有的阶层高一点点就好，中国人口基数那么大，一点点，足够你大不相同了。”</p><p>5.“一定要认识到信息的重要性，多读书，多思考，多提问，切莫固步自封。不要安于现状，也不要愤愤不平，更不要妄自菲薄，十几岁读了几篇故作深沉的烂文章就要认命，幼不幼稚…….要有斗争精神，要有反抗精神，不能向逆境低头！”</p><p>6.“年轻就有无限可能，看不见未来大势就先把手头的小事做好，眼高手低是最致命的。”</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Git/陆续补充内容&amp;问题</title>
    <link href="/2020/06/09/Git/%E9%99%86%E7%BB%AD%E8%A1%A5%E5%85%85%E5%86%85%E5%AE%B9&amp;%E9%97%AE%E9%A2%98/"/>
    <url>/2020/06/09/Git/%E9%99%86%E7%BB%AD%E8%A1%A5%E5%85%85%E5%86%85%E5%AE%B9&amp;%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="1-工作区和暂存区"><a href="#1-工作区和暂存区" class="headerlink" title="1.工作区和暂存区"></a>1.工作区和暂存区</h1><p>在这里<code>learngit</code>文件夹就是一个工作区。工作区的隐藏目录<code>.git</code>不算工作区，而是Git的版本库</p><ul><li>第一步是用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区；</li><li>第二步是用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。</li></ul><h1 id="2-Git跟踪修改的方式"><a href="#2-Git跟踪修改的方式" class="headerlink" title="2.Git跟踪修改的方式"></a>2.Git跟踪修改的方式</h1><p>Git管理的是修改。每次修改，如果不用<code>git add</code>到暂存区，那就不会加入到<code>commit</code>中。</p><ul><li>第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改 -&gt; <code>git commit</code></li></ul><p>。当你用<code>git add</code>命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，<code>git commit</code>只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。</p><ul><li>第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改 -&gt; <code>git add</code> -&gt; <code>git commit</code></li></ul><p>现在把第二次修改也提交了。</p><h1 id="3-GitHub需要SSH-Key"><a href="#3-GitHub需要SSH-Key" class="headerlink" title="3.GitHub需要SSH Key"></a>3.GitHub需要SSH Key</h1><ul><li>因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。</li><li>GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。</li></ul><h1 id="4-error-failed-to-push-some-refs-to-‘xxx-远程库-’"><a href="#4-error-failed-to-push-some-refs-to-‘xxx-远程库-’" class="headerlink" title="4.error: failed to push some refs to ‘xxx(远程库)’"></a>4.error: failed to push some refs to ‘xxx(远程库)’</h1><ul><li><p>错误：使用git 对源代码进行push到gitHub时可能会出错</p></li><li><p>原因：出现错误的主要原因是GitHub仓库中的README.md文件不在本地代码目录中</p></li><li><p>解决：</p><ol><li><p>执行语句：</p><div class="hljs"><pre><code class="hljs crmsh">git pull –rebase origin <span class="hljs-literal">master</span></code></pre></div></li><li><p>再执行语句： </p><div class="hljs"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> -u <span class="hljs-built_in">origin</span> master</code></pre></div></li></ol></li><li><p>比较</p><div class="hljs"><pre><code class="hljs crmsh">git pull origin <span class="hljs-literal">master</span>其中：git pull = git fetch + git mergegit pull --rebase origin <span class="hljs-literal">master</span>其中：git pull --rebase = git fetch + git rebase</code></pre></div><ul><li><p>现在有两个分支：test和master，假设远端的master的代码已经更改了（在B基础上变动：C,E），test的代码更改了要提交代码（在B基础上变动：D,E），如下图</p><div class="hljs"><pre><code class="hljs brainfuck">     <span class="hljs-comment">D</span>--<span class="hljs-literal">-</span><span class="hljs-comment">E</span> <span class="hljs-comment">test</span><span class="hljs-comment"></span>     <span class="hljs-comment">/</span><span class="hljs-comment">A</span>--<span class="hljs-literal">-</span><span class="hljs-comment">B</span>--<span class="hljs-literal">-</span><span class="hljs-comment">C</span>--<span class="hljs-literal">-</span><span class="hljs-comment">F</span>--<span class="hljs-literal">-</span> <span class="hljs-comment">master</span></code></pre></div><p>问题就来了，如果C,F和D,E的更改发生冲突，那么就需要我们合并冲突了，下面我们来看看git merge和git rebase怎么合并的</p><ul><li><p>git merge:</p><div class="hljs"><pre><code class="hljs brainfuck">      <span class="hljs-comment">D</span>--<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">E</span><span class="hljs-comment"></span>     <span class="hljs-comment">/</span>          <span class="hljs-comment">\</span><span class="hljs-comment">A</span>--<span class="hljs-literal">-</span><span class="hljs-comment">B</span>--<span class="hljs-literal">-</span><span class="hljs-comment">C</span>--<span class="hljs-literal">-</span><span class="hljs-comment">F</span>--<span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">G</span>--<span class="hljs-literal">-</span>   <span class="hljs-comment">test</span><span class="hljs-string">,</span> <span class="hljs-comment">master</span></code></pre></div></li><li><p>git rebase</p><div class="hljs"><pre><code class="hljs brainfuck"><span class="hljs-comment">A</span>--<span class="hljs-literal">-</span><span class="hljs-comment">B</span>--<span class="hljs-literal">-</span><span class="hljs-comment">D</span>--<span class="hljs-literal">-</span><span class="hljs-comment">E</span>--<span class="hljs-literal">-</span><span class="hljs-comment">C</span>--<span class="hljs-literal">-</span><span class="hljs-comment">F</span>--<span class="hljs-literal">-</span>   <span class="hljs-comment">test</span><span class="hljs-string">,</span> <span class="hljs-comment">master</span></code></pre></div></li></ul></li><li><p>比较结果</p><ul><li>git merge多出了一个新的节点G，会将远端master的代码和test本地的代码在这个G节点合并，之前的提交会分开去显示</li><li>git –rebase会将两个分支融合成一个线性的提交，不会形成新的节点</li></ul></li><li><p>解决</p><ul><li>merge：操作遇到冲突的时候，当前merge不能继续进行下去。手动修改冲突内容后，<code>add</code> 修改，<code>commit</code>就可以了</li><li>rebase ：解决冲突后,将修改<code>add</code>后执行<code>git rebase –continue</code>继续操作，或者<code>git rebase –skip</code>忽略冲突</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Git/配置&amp;操作命令</title>
    <link href="/2020/06/09/Git/%E9%85%8D%E7%BD%AE&amp;%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/"/>
    <url>/2020/06/09/Git/%E9%85%8D%E7%BD%AE&amp;%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Git和GitHub的设置"><a href="#一、Git和GitHub的设置" class="headerlink" title="一、Git和GitHub的设置"></a>一、Git和GitHub的设置</h1><p>官网下载git，git的环境变量会随着下载安装自动添加</p><h2 id="1-设置用户名和邮件地址"><a href="#1-设置用户名和邮件地址" class="headerlink" title="1.设置用户名和邮件地址"></a>1.设置用户名和邮件地址</h2><div class="hljs"><pre><code class="hljs shell">git config --global  user.name "这里换上你的用户名"git config --global user.email "这里换上你的邮箱"查看当前用户名和邮箱：git config --global  --list</code></pre></div><ul><li>在此处设置用户名和邮件地址时，如果使用了 <code>--global</code> 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息。</li><li>想针对特定项目使用不同的用户名称与邮件地址，可以在那个项目目录下运行没有 <code>--global</code> 选项的命令来配置。</li></ul><h2 id="2-与GitHub设置ssh配对"><a href="#2-与GitHub设置ssh配对" class="headerlink" title="2.与GitHub设置ssh配对"></a>2.与GitHub设置ssh配对</h2><p>首先，需要生成ssh公钥。键入</p><div class="hljs"><pre><code class="hljs shell">ssh-keygen -t rsa -C "这里换上你的邮箱"</code></pre></div><p>  然后，就会出现等待你的三次输入，内容分别是：</p><ul><li>确认秘钥的保存路径（如果不需要改路径则直接回车）；</li><li>如果上一步置顶的保存路径下已经有秘钥文件，则需要确认是否覆盖（如果之前的秘钥不再需要则直接回车覆盖，如需要则手动拷贝到其他目录后再覆盖）；</li><li>创建密码（如果不需要密码则直接回车）</li></ul><p>最后，在上述指定的保存路径下(默认C:\Users\Administrator.ssh)会生成名为<code>id_rsa</code>和<code>id_rsa.pub</code>的文件。将生成的<code>id_rsa.pub</code>文件中的内容拷贝到GitHub中的key（其名称通常是用来区分不同主机），然后保存。</p><blockquote><ul><li><p>C:\Users\Administrator.ssh该路径下的.ssh文件夹如果存在，可以直接删除，按上述重新生成ssh文件夹</p></li><li><p>注意：秘钥对：<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p></li></ul></blockquote><div class="hljs"><pre><code class="hljs shell">查看当前本地与GitHub的连接情况：ssh -T git@github.com</code></pre></div><h1 id="二、本地库操作"><a href="#二、本地库操作" class="headerlink" title="二、本地库操作"></a>二、本地库操作</h1><h2 id="1-创建版本库"><a href="#1-创建版本库" class="headerlink" title="1.创建版本库"></a>1.创建版本库</h2><p>1.创建空目录（这里目录名为learngit）</p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> mkdir learngit</span></code></pre></div><p>2.进入目录</p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> learngit</span></code></pre></div><p>3.显示当前目录</p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">pwd</span></span></code></pre></div><p>4.将当前目录变为Git可以管理的仓库</p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git init</span></code></pre></div><p>　<code>.git</code>目录是Git来跟踪管理版本库的，要放到Git仓库的文件要放在该目录或者其子目录下</p><h2 id="2-把文件添加到版本库"><a href="#2-把文件添加到版本库" class="headerlink" title="2.把文件添加到版本库"></a>2.把文件添加到版本库</h2><p>1.在分支中新建文件（这里文件为readme.txt）</p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> touch readme.txt</span></code></pre></div><p>2.vim编辑文件</p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> vi readme.txt</span></code></pre></div><p>按 “i” 进入编辑，按 “esc” “:wq”保存并推出</p><p>3.把文件添加到仓库</p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git add readme.txt</span></code></pre></div><p>4.把文件提交到仓库</p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git commit -m <span class="hljs-string">"wrote a readme file"</span></span></code></pre></div><p><code>commit</code>可以一次提交很多文件，所以你可以多次<code>add</code>不同的文件</p><p>Git告诉我们当前没有需要提交的修改（<code>nothing to commit</code>），而且，工作目录是干净（working tree clean）的。</p><h2 id="3-修改文件、查看修改"><a href="#3-修改文件、查看修改" class="headerlink" title="3.修改文件、查看修改"></a>3.修改文件、查看修改</h2><p>1.查看仓库当前的状态（如：是否修改了文件、修改是否已提交、删除了什么文件、冲突的文件等）</p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git status</span></code></pre></div><p>2.查看具体修改了什么内容</p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git diff readme.txt</span></code></pre></div><h2 id="4-版本回退"><a href="#4-版本回退" class="headerlink" title="4.版本回退"></a>4.版本回退</h2><p>每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为<code>commit</code>。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个<code>commit</code>恢复，然后继续工作，而不是把几个月的工作成果全部丢失。</p><p>1.查看提交日志的历史记录</p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">log</span></span></code></pre></div><p>简略版</p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">log</span> --pretty=oneline</span></code></pre></div><p>一大串类似<code>1094adb...</code>的是<code>commit id</code>（版本号）</p><p>在Git中，用<code>HEAD</code>表示当前版本，最新的提交上一个版本是<code>HEAD^``，</code>上上一个版本就是<code>HEAD^^</code></p><p>2.回退到上一个版本</p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git reset --hard HEAD^</span></code></pre></div><p>3.指定回到未来的某个版本</p><p>（1）只要上面的命令行窗口还没有被关掉，你就可以顺着往上找，找到那个未来版本的<code>commit id，这里</code>是<code>1094adb...</code></p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git reset --hard 1094a</span></code></pre></div><p>（2）已经关闭了命令行，想恢复到新版本</p><ul><li>查看命令日志的历史记录（为了找commit id）</li></ul><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git reflog</span></code></pre></div><ul><li>找到待恢复版本的commit id，用$ git reset –hard 1094a回到新版本</li></ul><h2 id="5-撤销修改"><a href="#5-撤销修改" class="headerlink" title="5.撤销修改"></a>5.撤销修改</h2><p>1.丢弃工作区的修改</p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git checkout -- readme.txt</span></code></pre></div><p>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态</p><p><code>git checkout -- file</code>命令中的<code>--</code>很重要，没有<code>--</code>，就变成了“切换到另一个分支”的命令</p><p>2.修改后已经<code>git add</code>到暂存区，但是还没有提交</p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git reset HEAD readme.txt</span></code></pre></div><p><strong><code>git reset</code>命令既可以回退版本，也可以把暂存区的修改回退到工作区</strong>。当我们用<code>HEAD</code>时，表示最新的版本。</p><p>接下来通过命令<code>$ git checkout -- readme.txt</code>丢弃工作区的修改</p><p>3.已经提交到版本库（前提是没有推送到远程库）</p><p>想要撤销本次提交，参考四.版本回退</p><h2 id="6-删除文件"><a href="#6-删除文件" class="headerlink" title="6.删除文件"></a>6.删除文件</h2><p>1.从工作空间删除文件（和直接在文件管理器删除相同）</p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> rm test.txt</span></code></pre></div><p>2.从版本库删除文件</p><p>如果该文件已经提交到了版本库，从工作空间删除文件后，那么此时工作区和版本库就不一致了</p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git rm test.txt</span>然后<span class="hljs-meta">$</span><span class="bash"> git commit -m <span class="hljs-string">"remove test.txt"</span></span></code></pre></div><p>文件就从版本库中被删除了</p><p>3.从版本库恢复工作空间误删的文件</p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git checkout -- test.txt</span></code></pre></div><p><strong><code>git checkout</code>其实是用版本库里的版本替换工作区的版本</strong>，无论工作区是修改还是删除，都可以“一键还原”。</p><p>注意：从来没有被添加到版本库就被删除的文件，是无法恢复的！</p><h2 id="7-分支操作"><a href="#7-分支操作" class="headerlink" title="7.分支操作"></a>7.分支操作</h2><p><strong>1.查看分支</strong></p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git branch</span></code></pre></div><p><strong>2.创建分支（这里分支名为dev）</strong></p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git branch dev</span></code></pre></div><p><strong>3.切换分支</strong></p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git checkout dev</span></code></pre></div><p>或者</p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git switch dev</span></code></pre></div><p>注意：在切换分支时，分支上的文件要及时的add和commit，否则只是保存在工作空间，每个分支都会有共同的文件</p><p><strong>4.创建+切换分支</strong></p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git branch -d dev</span></code></pre></div><p>或者</p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git switch -c dev</span></code></pre></div><p><strong>5.合并某分支到当前分支</strong></p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git merge dev</span></code></pre></div><p><strong>6.删除分支</strong></p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git branch -d dev</span></code></pre></div><p><strong>7.查看分支合并图</strong></p><p>查看分支的合并情况，包括分支合并图、一行显示、提交校验码缩略显示</p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">log</span> --graph --pretty=oneline --abbrev-commit</span></code></pre></div><p><strong>8.禁用fast forward的合并</strong></p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git merge --no-ff -m <span class="hljs-string">"merge with no-ff"</span> dev</span></code></pre></div><p> 因为本次合并要创建一个新的commit，所以加上<code>-m</code>参数，把commit描述写进去。</p><p>通常，合并分支时，如果可能，Git会用<code>Fast forward</code>模式，但这种模式下，删除分支后，会丢掉分支信息。加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而<code>fast forward</code>合并就看不出来曾经做过合并。</p><h1 id="三、远程库操作"><a href="#三、远程库操作" class="headerlink" title="三、远程库操作"></a>三、远程库操作</h1><p><strong>1.本地仓库与远程库相关联</strong></p><p>在本地的<code>learngit</code>仓库下运行命令</p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git remote add origin GitHub仓库地址</span></code></pre></div><p>添加后，远程库的名字就是<code>origin</code>，这是Git默认的叫法，也可以改成别的，但是<code>origin</code>这个名字一看就知道是远程库</p><p><strong>2.本地仓库分支推送到远程库</strong></p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git push -u origin master</span></code></pre></div><p>把本地库的内容推送到远程，用<code>git push</code>命令，实际上是把当前分支<code>master</code>推送到远程。</p><p>由于远程库是空的，我们第一次推送<code>master</code>分支时，加上了<code>-u</code>参数，Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。以后只要本地作了提交，就可以把本地<code>master</code>分支的最新修改推送至GitHub</p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git push origin master</span></code></pre></div><p><strong>3.克隆仓库</strong></p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git <span class="hljs-built_in">clone</span> github仓库地址</span></code></pre></div><p><strong>4.本地创建远程库分支并推送（这里本地库名为dev）</strong></p><ul><li>待创建分支名称与本地相同</li></ul><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git push origin dev</span></code></pre></div><p>此时GitHub仓库里也会创建一个名为dev的分支，内容和本地库相同</p><ul><li>待创建分支名称与本地不同（这里远程库名为dev1）</li></ul><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git push origin dev:dev1</span></code></pre></div><p><strong>5.在本地创建和远程分支对应的分支（这里远程库名为dev）</strong></p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git checkout -b dev origin/dev</span></code></pre></div><p><strong>6.本地删除远程库分支（这里远程库分支为dev）</strong></p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git push origin :dev</span></code></pre></div><p><strong>7.查看远程库的信息</strong></p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git remote</span></code></pre></div><p>更详细的信息</p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git remote -v</span></code></pre></div><p><strong>8.指定本地<code>dev</code>分支与远程<code>origin/dev</code>分支的链接</strong></p><div class="hljs"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git branch --<span class="hljs-built_in">set</span>-upstream-to=origin/dev dev</span></code></pre></div><p> 参考资料：<a href="https://www.liaoxuefeng.com/wiki/896043488029600/900002180232448" target="_blank" rel="noopener">廖雪峰老师博客</a></p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>服务器/概述</title>
    <link href="/2020/06/05/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%A6%82%E8%BF%B0/"/>
    <url>/2020/06/05/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p>服务器有服务器硬件和服务器软件，下面主要叙述服务器软件。</p><p>静态服务：主要提供静态资源，不同用户访问到的资源相同<br>动态服务：提供动态服务，不同用户访问到的资源不同</p><p>服务器的几个叫法：<br>\1. web服务器：广义上来说，就是响应用户的需求，提供服务，当下所有的服务器软件都可以称之为web服务器软件<br>\2. HTTP服务器(静态服务)：使用HTTP协议传输资源，提供服务<br>\3. 应用服务器(动态服务)：一个特定应用的承载容器</p><p>常见的轻量级服务器软件：<br>1、Nginx：典型的静态服务器，可做反向代理、负载均衡，一般放在最前面直面用户，和后端Tomcat打配合；纯C写的，性能贼高、内存消耗极少、稳定性也相当好，互联网公司重度使用<br>2、Tengine：阿里出品，基于Nginx服务器做的改造(加强和封装)，对大流量场景做了很多高级功能，性能、稳定性优秀<br>3、Apache http server：也是静态服务器，但是不如Nginx<br>3、IIS：微软开发，只能用在Windows下，具有应用服务器能力的http服务器<br>4、Tomcat：Apache出品，典型的应用服务器软件，符合Servlet标准的应用容器，也可以提供http服务，但一般不会作为http服务器；是Spring Boot框架默认的内置服务器<br>5、Jetty：跟Tomcat是一个性质的东西，符合Servlet标准的应用容器，也是Spring Boot框架支持的服务器，但不是默认的<br>6、Undertow：红帽子出品，跟Tomcat、Jetty一样也是Spring Boot框架支持的服务器，但不是默认的；高并发时性能优于Tomcat、Jetty</p><p>几款商用重量级的服务器软件：<br>1、JBoss(从8版开始更名为WildFly)：不仅是Servlet应用容器，更是EJB的应用容器，整套JavaEE框架部署的解决方案<br>2、WebLogic：Oracle公司出品，用于部署企业级JavaEE应用，全能型，几乎支持JavaEE所有的应用规范<br>3、WebSphere：IBM公司出品，支持更多JavaEE的应用规范的综合应用服务器</p>]]></content>
    
    
    <categories>
      
      <category>服务器</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo/配置&amp;备份&amp;恢复</title>
    <link href="/2020/06/04/Hexo/%E9%85%8D%E7%BD%AE&amp;%E5%A4%87%E4%BB%BD&amp;%E6%81%A2%E5%A4%8D/"/>
    <url>/2020/06/04/Hexo/%E9%85%8D%E7%BD%AE&amp;%E5%A4%87%E4%BB%BD&amp;%E6%81%A2%E5%A4%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="一、本地搭建"><a href="#一、本地搭建" class="headerlink" title="一、本地搭建"></a>一、本地搭建</h1><ol><li>配置环境</li></ol><ul><li>安装Git</li></ul><p>(点击进入<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git官网</a>，如果嫌下载慢自行百度解决~） </p><ul><li>Git与远程库进行SSH授权（因为需要部署到GitHub）</li></ul><p>(点击查看教程<a href="https://www.cnblogs.com/wy0526/p/13068373.html" target="_blank" rel="noopener">Git的安装-与远程仓库GitHub配置</a>)</p><ul><li>安装node.js（点击进入<a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">nodejs官网</a>直接下载）<strong><a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener"></a></strong></li></ul><p>2.本地博客</p><ul><li>安装hexo</li></ul><p>任意位置右键git bash输入(npm命令即可安装)</p><div class="hljs"><pre><code class="hljs shell">npm install -g hexo-cli</code></pre></div><ul><li>Hexo建立网站所需要的所有文件</li></ul><p>创建一个文件夹，在文件夹内执行命令</p><div class="hljs"><pre><code class="hljs shell">hexo initnpm install</code></pre></div><ul><li>准备启动本地博客（可选）</li></ul><p>继续执行命令</p><div class="hljs"><pre><code class="hljs shell">hexo s</code></pre></div><div class="hljs"><pre><code class="hljs shell">会出现出现这些内容：INFO Start processingINFO Hexo is running at http://localhost:4000.Press Ctrl+C to stop.</code></pre></div><p>打开浏览器，在地址栏中输入 <a href="https://link.jianshu.com/?t=http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 就可以访问本地blog了，<code>Ctrl+C</code>可以退出本地访问</p><h1 id="二、远程部署Github"><a href="#二、远程部署Github" class="headerlink" title="二、远程部署Github"></a>二、远程部署Github</h1><ol><li>创建用于上传博客的仓库</li></ol><p>项目名称为：你的名字 + .github.io</p><ol start="2"><li>部署</li></ol><p>修改hexo的文件夹下的_config.yml文件 【注意：冒号后有空格】</p><div class="hljs"><pre><code class="hljs shell">deploy:type: gitrepository: github仓库地址</code></pre></div><p>在hexo文件夹右键git bash输入</p><div class="hljs"><pre><code class="hljs shell">hexo ghexo d</code></pre></div><ol start="3"><li>可启动博客</li></ol><p>网址：<a href="https://yourname.github.io" target="_blank" rel="noopener">https://yourname.github.io</a></p><p>参考如下：</p><ul><li><p><a href="https://www.jianshu.com/p/3217ecf4a789" target="_blank" rel="noopener">搭建参考一</a></p></li><li><p><a href="https://blog.csdn.net/qq_34149935/article/details/81113845" target="_blank" rel="noopener">搭建参考二</a></p></li><li><p><a href="https://www.cnblogs.com/imsoft/p/5228560.html" target="_blank" rel="noopener">搭建参考三</a></p></li></ul><h1 id="三、博客备份"><a href="#三、博客备份" class="headerlink" title="三、博客备份"></a>三、博客备份</h1><p>前言</p><ul><li>该操作不是下载安装使用hexo所必须的，但是提前操作以防万一</li><li>遇见如下突发情况：例如：多台电脑操作hexo/原先hexo所在电脑重装系统/要将hexo移动到其他磁盘，提前上传都可以让我们恢复对hexo像往常一样的使用</li><li>机制：也就是将hexo源码做备份，存在GitHub上。之前在GitHub上的部署（使用<code>hexo d</code>上传部署到github）其实是hexo编译后的文件，是用来生成网页的，不包含所有hexo生成的网站原始文件。也就是上传的是在本地目录里自动生成的<code>.deploy_git</code>文件夹内容，而没有其他内容。我们可以通过git的分支管理实现hexo分支存放网站全部的原始文件，另一个存放生成的网页文件</li></ul><ol><li>网站的github仓库创建分支</li></ol><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_06/01.jpg" srcset="/img/loading.gif" alt="img"></p><p>将其设置为默认分支</p><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_06/01.jpg" srcset="/img/loading.gif" alt="img"></p><ol start="2"><li>打包将要推送到GitHub上的原始文件</li></ol><ul><li>clone该仓库到本地（clone的是hexo默认分支）</li></ul><div class="hljs"><pre><code class="hljs shell">git clone git@github.com:Rainbow0526/Rainbow0526.github.io.git</code></pre></div><ul><li><p>下载的文件夹里仅留下.git 文件夹，其他的文件都删除</p></li><li><p>找见我们hexo原位置，将hexo文件夹内除.deploy_git 以外都复制到clone下来的文件夹中</p></li></ul><blockquote><p>注意：</p><ol><li><p>现在clone下来的文件夹内应该有个<code>.gitignore文件</code>，用来忽略一些不需要的文件，表示这些类型文件不需要git。如果没有，右键新建，内容如下：</p><div class="hljs"><pre><code class="hljs shell">.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/</code></pre></div><ol start="2"><li>如果已经clone过主题文件，那么需要把theme主题文件夹里的 .git 也删除。因为git不能嵌套上传，最好是显示隐藏文件，检查一下有没有，否则上传的时候会出错，导致你的主题文件无法上传，这样你的配置在别的电脑上就用不了了。鱼干已经设置了fluid主题，由于hexo主题设置的文章网上比较多，操作也相对容易，没有写随笔。所以小鱼干需要删除路径D:\myapp_EName\hexo\themes\fluid下的 .git 。</li></ol></li></ol></blockquote><ol start="3"><li>将clone并修改以后的文件夹推送到远程库</li></ol><div class="hljs"><pre><code class="hljs shell">git add .git commit –m add_branchgit push</code></pre></div><p>此时已经成功将整个网站推送到了远程库的默认分支hexo。后续写文章、修改配置后的保存推送操作按下面继续就好啦。</p><ol start="4"><li>定期push网站源文件备份</li></ol><p>至此，网站部署至master分支，整个网站备份至hexo分支。当网站的配置或文章修改后都要将远程仓库更新。首先，依次执行</p><div class="hljs"><pre><code class="hljs shell">git add .git commit -m ChangeFiles（更新信息内容可改)git push  （或者git push origin hexo)</code></pre></div><p>保证hexo分支版本最新。然后执行</p><div class="hljs"><pre><code class="hljs shell">hexo d -g</code></pre></div><p>（在此之前，有时可能需要执行<code>hexo clean</code>），完成后就会发现，最新改动已经更新到master分支了，两个分支互不干扰！</p><p>注意：换到不同电脑上时，首先拉下 github 上的 hexo分支的更新：</p><div class="hljs"><pre><code class="hljs shell">git pull origin hexo</code></pre></div><p>参考文章链接如下：</p><p>参考资料1：<a href="https://www.zhihu.com/question/21193762/answer/489124966" target="_blank" rel="noopener">https://www.zhihu.com/question/21193762/answer/489124966</a></p><p>参考资料2：<a href="https://www.jianshu.com/p/0b1fccce74e0" target="_blank" rel="noopener">https://www.jianshu.com/p/0b1fccce74e0</a></p><h1 id="四、博客恢复"><a href="#四、博客恢复" class="headerlink" title="四、博客恢复"></a>四、博客恢复</h1><ol><li>配置环境</li></ol><ul><li><p>安装git（点击进入<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git官网</a>，如果嫌下载慢自行百度解决~） </p></li><li><p>Git与远程库进行SSH授权(点击查看教程<a href="https://www.cnblogs.com/wy0526/p/13068373.html" target="_blank" rel="noopener">Git的安装-与远程仓库GitHub配置</a>)</p></li><li><p>安装node.js（点击进入<a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">nodejs官网</a>直接下载）</p></li></ul><ol start="2"><li>配置本地博客</li></ol><ul><li>安装hexo</li></ul><div class="hljs"><pre><code class="hljs shell">npm install -g hexo-cli</code></pre></div><p>安装好后不需要初始化（hexo init）</p><ul><li>克隆GitHub上保存的hexo网站原文件</li></ul><div class="hljs"><pre><code class="hljs shell">git clone git@github.com:Rainbow0526/Rainbow0526.github.io.git</code></pre></div><ul><li>生成缺少的网站文件。进入克隆的目录，执行：</li></ul><div class="hljs"><pre><code class="hljs shell">npm installnpm install hexo-deployer-git --save</code></pre></div><p>因为上传GitHub时有.gitignore文件，所以上传到github上默认是忽略掉 node_modules等文件夹，即仓库的hexo分支并没有存储这些文件，所以需要install生成。</p><ol start="3"><li>生成、部署（推荐）</li></ol><div class="hljs"><pre><code class="hljs shell">hexo ghexo d</code></pre></div><p>刚恢复本地hexo最好生成部署一下，接下来就像以前一样了。</p><p> 参考资料1：<a href="https://www.zhihu.com/question/21193762/answer/489124966" target="_blank" rel="noopener">https://www.zhihu.com/question/21193762/answer/489124966</a></p><p>参考资料2：<a href="https://www.jianshu.com/p/0b1fccce74e0" target="_blank" rel="noopener">https://www.jianshu.com/p/0b1fccce74e0</a></p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java/下载&amp;配置</title>
    <link href="/2020/05/24/Java/%E4%B8%8B%E8%BD%BD&amp;%E9%85%8D%E7%BD%AE/"/>
    <url>/2020/05/24/Java/%E4%B8%8B%E8%BD%BD&amp;%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>注：JDK11之后的版本没有jre文件，为了避雷下载了java8</p><h1 id="一、下载JDK"><a href="#一、下载JDK" class="headerlink" title="一、下载JDK"></a>一、下载JDK</h1><ol><li>下载安装文件</li></ol><p><a href="https://www.oracle.com/java/technologies/javase-downloads.html" target="_blank" rel="noopener">https://www.oracle.com/java/technologies/javase-downloads.html</a></p><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_07/01.jpg" srcset="/img/loading.gif" alt="img"></p><p>可能需要登录oracle账号（转载）账号：<a href="mailto:2696671285@qq.com">2696671285@qq.com</a>密码：Oracle123</p><ol start="2"><li>运行安装文件安装jdk</li></ol><p>下载好安装文件后，点击运行</p><p>注：第一次保存路径为jdk保存位置，第二次保存路径为jre文件夹保存位置</p><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_07/02.png" srcset="/img/loading.gif" alt="img"></p><h1 id="二、配置环境变量"><a href="#二、配置环境变量" class="headerlink" title="二、配置环境变量"></a>二、配置环境变量</h1><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_07/03.jpg" srcset="/img/loading.gif" alt="img"></p><ol><li>新建变量Java_Home</li></ol><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_07/04.png" srcset="/img/loading.gif" alt="img"></p><p> 变量名：<code>Java_Home</code></p><p>变量值：为JDK安装路径，笔者的路径是<code>D:\ComputerSoftware\Java\jdk1.8.0_251</code></p><p>点击确定保存新建变量~</p><ol start="2"><li>修改变量path</li></ol><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_07/05.png" srcset="/img/loading.gif" alt="img"></p><p>在<code>path</code>变量中添加JDK和JRE下的Bin目录所在的路径</p><p>点击确定保存修改~</p><ol start="3"><li>新建变量ClassPath</li></ol><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_07/06.png" srcset="/img/loading.gif" alt="img"></p><p>变量名：<code>ClassPath</code></p><p>变量值：<code>.;%Java_Home%\lib;%Java_Home%\lib\tools.jar</code></p><p>注意前面的<code>.;</code>不要丢掉</p><p>点击确定保存新建变量~</p><h1 id="三、测试是否安装成功"><a href="#三、测试是否安装成功" class="headerlink" title="三、测试是否安装成功"></a>三、测试是否安装成功</h1><ol><li><p>回到电脑桌面，按快捷键<code>Win+R</code>，输入<code>cmd</code>出现命令行窗口</p></li><li><p>输入<code>java</code></p></li></ol><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_07/07.jpg" srcset="/img/loading.gif" alt="img"></p><ol start="3"><li>输入<code>javac</code></li></ol><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_07/08.jpg" srcset="/img/loading.gif" alt="img"></p><ol start="4"><li>输入<code>java -version</code>注意 - 前有一个空格</li></ol><p><img src="https://raw.githubusercontent.com/Rainbow0526/PictureGithub/master/2020_07/09.jpg" srcset="/img/loading.gif" alt="img"></p><p>如果三个命令都有如上结果，那么恭喜你，Java安装成功啦~✿✿ヽ(°▽°)ノ✿</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>兔酱碎碎念/计划实习</title>
    <link href="/2020/05/20/%E5%85%94%E9%85%B1%E7%A2%8E%E7%A2%8E%E5%BF%B5/%E8%AE%A1%E5%88%92%E5%AE%9E%E4%B9%A0/"/>
    <url>/2020/05/20/%E5%85%94%E9%85%B1%E7%A2%8E%E7%A2%8E%E5%BF%B5/%E8%AE%A1%E5%88%92%E5%AE%9E%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>突然想去找一份与计算机专业相关的暑期实习</p><p>所以搜集了各招聘网站的信息，发现自己欠缺了太多</p><p>虽然以前也清楚只靠学校学的一些入门知识压根是不够的，但是一直以来都是处于一种自我慰藉的状态，三天打鱼两天晒网</p><p>每次学习一段时间就开始漫无目的了，然后就不去继续坚持</p><p>经过了这次，彻底说明了还是要自学</p><p>可能唯一庆幸的就是自己还没有毕业，没有到绝望的境地</p><p>相比于更早开始学习的人，可能晚了一些</p><p>但是，这也恰恰是拉开人与人间距离的一种方式吧</p>]]></content>
    
    
    <categories>
      
      <category>鱼酱碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>兔酱碎碎念/大二寒假记事</title>
    <link href="/2020/01/16/%E5%85%94%E9%85%B1%E7%A2%8E%E7%A2%8E%E5%BF%B5/%E5%A4%A7%E4%BA%8C%E5%AF%92%E5%81%87%E8%AE%B0%E4%BA%8B/"/>
    <url>/2020/01/16/%E5%85%94%E9%85%B1%E7%A2%8E%E7%A2%8E%E5%BF%B5/%E5%A4%A7%E4%BA%8C%E5%AF%92%E5%81%87%E8%AE%B0%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<p><code>14号</code></p><p>今年是10号回的家，14号那天上午没有到铺子里帮忙。弟弟妹妹去补习班，店里还有其他姨姨帮忙照看。我去剪了头发，气到爆炸。下午，奶奶洗了一次衣服，妈妈带着我买了一双运动鞋当新年的新鞋。习惯网购的我觉得和网上五六十元的老爹鞋毫无区别，其他时间就是当咸鱼了。</p><p><code>15号</code></p><p>15号和今天一样，整个上午都在店里帮忙，下午在家里看《爱情公寓 五》。《爱情公寓》的终结篇很搞笑，但比以前几季更感触至深的就是它的现实感了。每个人都不再是嘻嘻哈哈的玩闹，更多的是对人生的过法，面对着不得不面对的各种现实问题——花销，婚姻，夫妻之间的信任等等。在生活中也体现了不同的人有不同的人生。</p><p>一菲是大学老师，事业有成，家庭美满。张伟是律师，虽然没有很成功。但有目标，爱情也正在赶来的路上。吕子乔和美嘉没有工作，也没有未来的目标，爱情刚开花要结果，但仍旧磕磕绊绊。</p><p>这三个人住在同一个地方，但却有了不同的人生，喜剧片中的现实感也是很让人感慨。</p><p>时间一年年的变，《爱情公寓》在变，我们也在变，《爱情公寓》杀青了，我们却仍旧要走下去。今年是2020年，这个数字的确很让人惊动，是惊喜还是畏惧？可不论是哪种都要继续走下去。还记得元旦那天晚上，怎么过元旦呢？有玩游戏的，有看跨年晚会的，还有……待在电脑前写实验报告的，哈哈哈……当时当真内心有点儿害怕，或许是因为对未来不知何去何从的害怕吧。20年就意味着整整20岁了，而且也将面临更多。开学以后就步入大二的下学期了，在将来要更有目标的生活，其次也要想找赚些钱来慢慢攒出还贷款的钱（这也是放假后，忽然有的想法）</p><p>“找方向是主要，攒钱是其次。”  ——要落实到行动</p><p>还有的变化就是对亲人多了一份体谅，慢慢地理解了他们为什么这么苦，也学会了要多爱他们一分，因为他们很辛苦很累。</p><p>也少了对生活状况的抱怨和不甘，可能生来起跑线就并没有对齐，但你能做的就是在你当前的生命中奋起搏击，不断地向上攀爬，因为越向上越接近阳光。你和别人不一样，每个人都不一样，你要为自己变得更优秀，也要带着家人感受一代代茁壮成长。很开心我们的每一代都是更好的一代，这便足矣。</p><p>最近也有在好好的爱家人，比起金钱这些更金贵吧。趁眼下多爱他们，一分是一分，随时面临分离，所以要珍惜能在世上的时间。从起初到做家务，到后来的烧饭，按摩，保暖脚……慢慢地学会爱。</p><p>“好好爱家人。”</p><p>总之，2020年是新的一年，变了很多，成长了很多。你也要变得更好。</p><p><code>16号</code></p><p>今天上午在店里待了一上午。天气很暖和，心情也很愉悦，至少不是双手双脚冷，双手很暖和。早上醒来以后每日一想，为什么他们去补习班，我却要早起。凭什么我要卖东西受冻，而有的人和我一样大的年龄却可以在家里享受？可终究半分钟后下了床，这一切可能是因为每个人都有不同的生活，有着不一样的命运（还好自己喜欢早起，其实这也没有什么，可仍抵不住要吐槽一番）。今天下午没有什么安排出门的计划，因闺蜜七天没有扣我，也没有回我今天的消息而搁置。</p>]]></content>
    
    
    <categories>
      
      <category>鱼酱碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
